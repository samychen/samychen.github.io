[{"title":"Hello World","date":"2017-03-06T15:56:21.406Z","path":"2017/03/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"安卓开发规范","date":"2016-03-11T07:17:50.000Z","path":"2016/03/11/安卓开发规范/","text":"#安卓开发规范 @(Android高级)[开发规范] 摘要 [TOC] 1 前言为了利于项目维护以及规范开发，促进成员之间Code Review的效率，必须按照一定的开发规范。 2 AS规范工欲善其事，必先利其器。 尽量使用最新版的IDE进行开发； 编码格式统一为UTF-8； 编辑完.java, .xml等文件后一定要格式化（基本格式方面使用 AS 默认模板即可）； 删除多余的import，减少警告出现，可利用AS的Optimize Imports(Settings → Keymap → Optimize Imports)快捷键 3 命名规范 代码中的命名严禁使用拼音与英文混合的方式,更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解,避免歧义。 注意：即使纯拼音命名方式也要避免采用。但alibaba、taobao、youku、hangzhou等国际通用的名称,可视同英文。 3.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。 采用反域名命名规则，全部使用小写字母。一级包名是顶级域名，通常为com,edu,gov,net,org等，二级包名为公司名，三级包名根据应用进行命名，四级包名为模块名或层级名。| 包名 |此包中包含 || :——————-|:—————–:||com.xx.应用名称缩写.activity|用户界面中所有的Activity类||com.xx.应用名称缩写.fragment|界面中所有的Fragment类||com.xx.应用名称缩写.base|基础共享的类||com.xx.应用名称缩写.adapter|页面用到的Adapter类 (适配器的类)||com.xx.应用名称缩写.view|自定义的View类||自定义的View类|自定义的View类||com.xx.应用名称缩写.util|此包中包含：公共工具方法类（util模块名||com.xx.应用名称缩写.bean|下面可分：vo、po、dto 此包中包含：JavaBean类||com.xx.应用名称缩写.model|此包中包含：模型类||com.xx.应用名称缩写.db|数据库操作类||com.xx.应用名称缩写.view (或者 com.xx.应用名称缩写.widget )|自定义的View类等||com.xx.应用名称缩写.service|Service服务||com.xx.应用名称缩写.receiver|BroadcastReceiver服务||com.xx.应用名称缩写.config|所有的配置相关的类| 注意：如果项目采用MVP，所有M、V、P抽取出来的接口都放置在相应模块的i包下，所有的实现都放置在相应模块的impl下 3.2 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如HTML, URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity 类 Activity为后缀标识 欢迎页面类WelcomeActivity Adapter类 Adapter 为后缀标识 新闻详情适配器 NewDetailAdapter 解析类 Parser为后缀标识 首页解析类HomePosterParser 工具方法类 Utils或Manager为后缀标识（与系统或第三方的Utils区分）或功能+Utils 线程池管理类：ThreadPoolManager日志工具类：LogUtils（Logger也可）打印工具类：PrinterUtils 数据库类 以DBHelper后缀标识 新闻数据库：NewDBHelper Service类 以Service为后缀标识 时间服务TimeService BroadcastReceiver类 以Receiver为后缀标识 推送接收JPushReceiver ContentProvider类 以Provider为后缀标识 ShareProvider 自定义的共享基础类 以Base开头 BaseActivity,BaseFragment 测试类的命名以它要测试的类的名称开始，以Test结束。例如：HashTest或HashIntegrationTest。 接口（interface）：命名规则与类一样采用大驼峰命名法，多以able或ible结尾，如 interface Runnable、interface Accessible。 注意：如果项目采用MVP，所有Model、View、Presenter的接口都以I为前缀，不加后缀，其他的接口采用上述命名规则。 3.3 方法名方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。|方法 |说明 ||:————-|:————-:||intXX()|初始化相关方法,使用init为前缀标识，如初始化布局initView()||isXX() checkXX()|方法返回值为boolean型的请使用is或check为前缀标识||getXX()|返回某个值的方法，使用get为前缀标识||setXX()|设置某个属性值||handleXX()/processXX()|对数据进行处理的方法||displayXX()/showXX()|弹出提示框和提示信息，使用display/show为前缀标识||updateXX()|更新数据||saveXX()|保存数据||resetXX()|重置数据||clearXX()|清楚数据||removeXX()|移除数据或者视图等，如removeView();||drawXX()|绘制数据或效果相关的，使用draw前缀标识| 3.4 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？ 每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableListNAMES = ImmutableList.of(\"Ed\", \"Ann\");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = \"non-final\";final String nonStatic = \"non-static\";static final SetmutableCollection = new HashSet();static final ImmutableSetmutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;\"these\", \"can\", \"change\"&#125;; 3.5 非常量字段名非常量字段名以lowerCamelCase风格的基础上改造为如下风格：基本结构为scopeVariableNameType。 scope：范围 非公有，非静态字段命名以m开头。 静态字段命名以s开头。 公有非静态字段命名以p开头。 公有静态字段（全局变量）命名以g开头。 例子：12345678public class MyClass &#123; int mPackagePrivate; private int mPrivate; protected int mProtected; private static MyClass sSingleton; public int pField; public static int gField;&#125; 使用1字符前缀来表示作用范围，1个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。 Type：类型 考虑到Android中使用很多UI控件，为避免控件和普通成员变量混淆以及更好达意，所有用来表示控件的成员变量统一加上控件缩写作为后缀（文末附有缩写表）。 对于普通变量一般不添加类型后缀，如果统一添加类型后缀，请参考文末的缩写表。 用统一的量词通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。 注意：如果项目中使用ButterKnife，则不添加m前缀，以lowerCamelCase风格命名。例如，请使用mCustomerStrFirst和mCustomerStrLast，而不要使用mFirstCustomerStr和mLastCustomerStr。|量词列表|量词后缀说明||:———–|:————-:||First|一组变量中的第一个||Last|一组变量中的最后一个||Next|一组变量中的下一个变量||Prev|一组变量中的上一个||Cur|一组变量中的当前变量|说明： 集合添加如下后缀：List、Map、Set 数组添加如下后缀：Arr 注意：所有的VO（值对象）统一采用标准的lowerCamelCase风格编写，所有的DTO（数据传输对象）就按照接口文档中定义的字段名编写。 3.6 参数名参数名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 3.7 局部变量名局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 3.8 临时变量 临时变量通常被取名为i、j、k、m和n，它们一般用于整型；c、d、e，它们一般用于字符型。 如：for (int i = 0; i &lt; len ; i++)。 3.9 类型变量名 类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。以类命名方式(参考3.2 类名)，后面加个大写的T(如：RequestT, FooBarT)。 4 资源文件规范4.1 资源布局文件（XML文件（layout布局文件）） 全部小写，采用下划线命名法 4.1.1 contentView命名 必须以全部单词小写，单词间以下划线分割，使用名词或名词词组。 所有Activity或Fragment的contentView必须与其类名对应，对应规则为：将所有字母都转为小写，将类型和功能调换（也就是后缀变前缀）。 例如：activity_main.xml 4.1.2 Dialog命名 规则：dialog_描述.xml 例如：dialog_hint.xml 4.1.3 PopupWindow命名 规则：ppw_描述.xml 例如：ppw_info.xml 4.1.4 列表项命名 规则：item_描述.xml 例如：item_city.xml 4.1.5 包含项命名 规则：模块_(位置)描述.xml 例如：activity_main_head.xml、activity_main_bottom.xml 注意：通用的包含项命名采用：项目名称缩写_描述.xml 例如：xxxx_title.xml 4.2 资源文件（图片drawable文件夹下） 全部小写，采用下划线命名法，加前缀区分 命名模式：可加后缀 _small 表示小图， _big 表示大图，逻辑名称可由多个单词加下划线组成，采用以下规则： 用途模块名逻辑名称用途模块名颜色用途逻辑名称用途颜色说明：用途也指控件类型（具体见附录UI控件缩写表） 例如： 名称 说明 btn_main_home.png 按键 divider_maket_white.png 分割线 ic_edit.png 图标 bg_main.png 背景 btn_red.png 红色按钮 btn_red_big.png 红色大按键 ic_head_small.png 小头像 bg_input.png 输入框背景颜色 divider_white.png 白色分割线 如果有多种形态，如按钮选择器：btn_xx.xml(selector)|名称 |说明||:—————–|:————–:||btnxx|按钮图片使用btn整体效果（selector）||btn_xxnormal|按钮图片使用btn正常情况效果||btn_xxpressed|按钮图片使用btn点击时候效果||btn_xx_focused|state_focused聚焦效果||btn_xx_hovered|state_hovered悬停效果||btn_xx_activated |state_activated激活的||bghead|背景图片使用bg功能_说明||def_searchcell|默认图片使用def功能_说明||ic_morehelp|图标图片使用ic功能_说明||seg_listline|具有分隔特征的图片使用seg功能_说明||selok|选择图标使用sel功能_说明| 注意：使用AndroidStudio的插件SelectorChapek可以快速生成selector，前提是命名要规范 4.3 动画文件（anim文件夹下） 全部小写，采用下划线命名法，加前缀区分。 具体动画采用以下规则：模块名_逻辑名称。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。 普通的tween动画采用如下表格中的命名方式：动画类型_方向 名称 说明 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小 4.4 values中name命名 4.4.1 colors.xml colors的name命名使用下划线命名法，在你的colors.xml文件中应该只是映射颜色的名称一个ARGB值，而没有其它的。不要使用它为不同的按钮来定义ARGB值。 不要这样做123456789&lt;resources&gt; &lt;color name=\"button_foreground\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"button_background\"&gt;#2A91BD&lt;/color&gt; &lt;color name=\"comment_background_inactive\"&gt;#5F5F5F&lt;/color&gt; &lt;color name=\"comment_background_active\"&gt;#939393&lt;/color&gt; &lt;color name=\"comment_foreground\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"comment_foreground_important\"&gt;#FF9D2F&lt;/color&gt; ... &lt;color name=\"comment_shadow\"&gt;#323232&lt;/color&gt; 使用这种格式，你会非常容易的开始重复定义ARGB值，这使如果需要改变基本色变的很复杂。同时，这些定义是跟一些环境关联起来的，如button或者comment, 应该放到一个按钮风格中，而不是在color.xml文件中。 相反，这样做12345678910111213141516&lt;resources&gt; &lt;!-- grayscale --&gt; &lt;color name=\"white\" &gt;#FFFFFF&lt;/color&gt; &lt;color name=\"gray_light\"&gt;#DBDBDB&lt;/color&gt; &lt;color name=\"gray\" &gt;#939393&lt;/color&gt; &lt;color name=\"gray_dark\" &gt;#5F5F5F&lt;/color&gt; &lt;color name=\"black\" &gt;#323232&lt;/color&gt; &lt;!-- basic colors --&gt; &lt;color name=\"green\"&gt;#27D34D&lt;/color&gt; &lt;color name=\"blue\"&gt;#2A91BD&lt;/color&gt; &lt;color name=\"orange\"&gt;#FF9D2F&lt;/color&gt; &lt;color name=\"red\"&gt;#FF432F&lt;/color&gt; &lt;/resources&gt; 向应用设计者那里要这个调色板，名称不需要跟”green”、”blue”等等相同。”brand_primary”、”brand_secondary”、”brand_negative”这样的名字也是完全可以接受的。 像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。 通常一个具有审美价值的UI来说，减少使用颜色的种类是非常重要的。 4.4.2 dimens.xml 像对待colors.xml一样对待dimens.xml文件 与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。 一个好的例子，如下所示：123456789101112131415161718192021&lt;resources&gt; &lt;!-- font sizes --&gt; &lt;dimen name=\"font_larger\"&gt;22sp&lt;/dimen&gt; &lt;dimen name=\"font_large\"&gt;18sp&lt;/dimen&gt; &lt;dimen name=\"font_normal\"&gt;15sp&lt;/dimen&gt; &lt;dimen name=\"font_small\"&gt;12sp&lt;/dimen&gt; &lt;!-- typical spacing between two views --&gt; &lt;dimen name=\"spacing_huge\"&gt;40dp&lt;/dimen&gt; &lt;dimen name=\"spacing_large\"&gt;24dp&lt;/dimen&gt; &lt;dimen name=\"spacing_normal\"&gt;14dp&lt;/dimen&gt; &lt;dimen name=\"spacing_small\"&gt;10dp&lt;/dimen&gt; &lt;dimen name=\"spacing_tiny\"&gt;4dp&lt;/dimen&gt; &lt;!-- typical sizes of views --&gt; &lt;dimen name=\"button_height_tall\"&gt;60dp&lt;/dimen&gt; &lt;dimen name=\"button_height_normal\"&gt;40dp&lt;/dimen&gt; &lt;dimen name=\"button_height_short\"&gt;32dp&lt;/dimen&gt;&lt;/resources&gt; 布局时在写margins和paddings时，你应该使用spacing_xxxx尺寸格式来布局，而不是像对待string字符串一样直接写值。 这样写会非常有感觉，会使组织和改变风格或布局是非常容易。 4.4.3 strings.xml strings的name命名使用下划线命名法，采用以下规则：模块名+逻辑名称 名称 说明 main_menu_about 主菜单按键文字 friend_title 好友模块标题栏 friend_dialog_del 好友删除提示 login_check_email 登录验证 dialog_title 弹出框标题 button_ok 确认键 loading 加载文字 4.4.4 styles.xml 几乎每个项目都需要适当的使用style文件，因为对于一个视图来说有一个重复的外观是很常见的，将所有的外观细节属性（colors、padding、font）放在style文件中。 在应用中对于大多数文本内容，最起码你应该有一个通用的style文件，例如：1234&lt;style name=\"ContentText\"&gt; &lt;item name=\"android:textSize\"&gt;@dimen/font_normal&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/basic_black&lt;/item&gt;&lt;/style&gt; 应用到TextView中:123456&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/price\" style=\"@style/ContentText\" /&gt; 你或许需要为按钮控件做同样的事情，不要停止在那里。将一组相关的和重复android:**的属性放到一个通用的style中。 将一个大的style文件分割成多个文件， 你可以有多个styles.xml 文件。Android SDK支持其它文件，styles这个文件名称并没有作用，起作用的是在文件 里xml的&lt;style&gt;标签。因此你可以有多个style文件styles.xml、style_home.xml、style_item_details.xml、styles_forms.xml。 不同于资源文件路径需要为系统构建起的有意义，在res/values目录下的文件可以任意命名。 4.5 layout中的id命名 命名模式为：view缩写模块名逻辑名，比如btn_main_search 使用AndroidStudio的插件ButterKnife Zelezny，生成注解非常方便，原生的话可以使用Android Code Generator插件。 5 版本统一规范Android开发存在着众多版本的不同，比如compileSdkVersion、minSdkVersion、targetSdkVersion以及项目中依赖第三方库的版本，不同的module及不同的开发人员都有不同的版本，所以需要一个统一版本规范的文件。 6 注释规范为了减少他人阅读你代码的痛苦值，请在关键地方做好注释。6.1 类注释 每个类完成后应该有作者姓名和联系方式的注释，对自己的代码负责。123456789101112/** * &lt;pre&gt; * author : Blankj * e-mail : xxx@xx * time : 2017/03/07 * desc : xxxx描述 * version: 1.0 * &lt;/pre&gt; */public class WelcomeActivity &#123; ...&#125; 具体可以在AS中自己配制，Settings → Editor → File and Code Templates → Includes → File Header，输入123456789/** * &lt;pre&gt; * author : $&#123;USER&#125; * e-mail : xxx@xx * time : $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125; * desc : * version: 1.0 * &lt;/pre&gt; */ 这样便可在每次新建类的时候自动加上该头注释。 6.2 方法注释 每一个成员方法（包括自定义成员方法、覆盖方法、属性方法）的方法头都必须做方法头注释，在方法前一行输入/** + 回车或者设置Fix doc comment(Settings → Keymap → Fix doc comment)快捷键，AS便会帮你生成模板，我们只需要补全参数即可，如下所示。12345678910111213/** * bitmap转byteArr * * @param bitmap bitmap对象 * @param format 格式 * @return 字节数组 */public static byte[] bitmap2Bytes(Bitmap bitmap, CompressFormat format) &#123; if (bitmap == null) return null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); bitmap.compress(format, 100, baos); return baos.toByteArray();&#125; 6.3 块注释 块注释与其周围的代码在同一缩进级别。它们可以是/ … /风格，也可以是// …风格(//后最好带一个空格）。对于多行的/ … /注释，后续行必须从开始， 并且与前一行的对齐。以下示例注释都是OK的。1234/* * This is // And so /* Or you can * okay. // is this. * even do this. */ */ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/ … /。 7 测试规范 业务开发完成之后，开发人员做单元测试，单元测试完成之后，保证单元测试全部通过同时单元测试代码覆盖率达到一定程度（这个需要开发和测试约定，理论上越高越好），开发提测。 // TODO... 8 其他规范 合理布局，有效运用、、标签； Activity和Fragment里面有许多重复的操作以及操作步骤，所以我们都需要提供一个BaseActivity和BaseFragment，让所有的Activity和Fragment都继承这个基类。 方法基本上都按照调用的先后顺序在各自区块中排列； 相关功能作为小区块放在一起（或者封装掉）； 当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法； 数据提供统一的入口。无论是在 MVP、MVC 还是 MVVM 中，提供一个统一的数据入口，都可以让代码变得更加易于维护。比如可使用一个DataManager，把 http、preference、eventpost、database 都放在DataManger里面进行操作，我们只需要与DataManger打交道； 多用组合, 少用继承； 提取方法, 去除重复代码。对于必要的工具类抽取也很重要，这在以后的项目中是可以重用的。 可引入 Dagger2 减少模块之间的耦合性。Dagger2 是一个依赖注入框架，使用代码自动生成创建依赖关系需要的代码。减少很多模板化的代码，更易于测试，降低耦合，创建可复用可互换的模块； 项目引入RxJava + RxAndroid这些响应式编程，可以极大的减少逻辑代码； 通过引入事件总线，如：EventBus、AndroidEventBus、RxBus，它允许我们在DataLayer中发送事件，以便ViewLayer中的多个组件都能够订阅到这些事件，减少回调； 尽可能使用局部变量； 及时关闭流； 尽量减少对变量的重复计算； 如下面的操作：123for (int i = 0; i &lt; list.size(); i++) &#123; ...&#125; 建议替换为：123for (int i = 0, int length = list.size(); i &lt; length; i++) &#123; ...&#125; 尽量采用懒加载的策略，即在需要的时候才创建； 例如：1234String str = \"aaa\";if (i == 1) &#123; list.add(str);&#125; 建议替换为：1234if (i == 1) &#123; String str = \"aaa\"; list.add(str);&#125; 不要在循环中使用try…catch…，应该把其放在最外层； 使用带缓冲的输入输出流进行IO操作； 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销； 尽量在合适的场合使用单例；使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据 + “”最慢； 使用AS自带的Lint来优化代码结构（什么，你不会？右键module、目录或者文件，选择Analyze → Inspect Code）； 最后不要忘了内存泄漏的检测；","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"Android studio关于build/outputs/apk/中apk或arr或jar无法删除的解决方法","date":"2015-12-12T15:27:49.000Z","path":"2015/12/12/Android-studio关于build-outputs-apk-中apk或arr或jar无法删除的解决方法/","text":"android studio关于build/outputs/apk/中apk或arr或jar无法删除的解决方法Error:Execution failed for task ‘:app:clean’.&gt; Unable to delete file 后面的文件地址，可能是apk，可能是arr，也可能是classes.jar 在使用Android Studio开发时，部分朋友会遇到这个问题，但是又不是每个人都会遇到。而我则是经常遇到，经过长期开机关机的方式来删除build后，终于决定解决这个问题。还是不负有心人啊，终于找到解决方案，在此分享给大家。其实解决不难，只要2步即可。1、下载工具LockHunter.exe，下载地址：http://pan.baidu.com/s/1bpFlPL12、在Android Studio中的build.gradle中配置：task clean(type: Exec) { ext.lockhunter = ‘\\”C:\\Program Files\\LockHunter\\LockHunter.exe\\“‘ def buildDir = file(new File(“build”)) commandLine ‘cmd’, “$lockhunter”, ‘/delete’, ‘/silent’, buildDir}备注：ext.lockhunter 是你安装lockhunter的地址。 写进的build.gradle是写在应用APP里面的，而不是项目的。 —————————分割线———————————————————–有部分朋友使用上述方法还是不能成功，请接着看： 在出现问题的时候，点击build，同时把手机拔掉，卸载APP，然后插回，在AS上再运行重装。 如果这个方法还不行，那么请把瞬时启动关闭。具体位置： 两个方法一起使用，必定成功。","tags":[{"name":"安卓","slug":"安卓","permalink":"http://samychen.com/tags/安卓/"}]},{"title":"ListView源码分析（二）","date":"2015-09-26T05:15:15.000Z","path":"2015/09/26/ListView源码分析（二）/","text":"ListView的setAdapter实现查看GrepCode网站ListView源码发现setAdapter主要有以下几个重要方法： layoutChildren，fillFromTop，fillDown /fillUpmakeAndAddView，obtainView，setupChild 先简单看下layoutChildren源码1234567891011121314151617181920212223242526272829303132@Override protected void layoutChildren() &#123; ......... boolean dataChanged = mDataChanged; if (dataChanged) &#123; handleDataChanged(); &#125; ......... // Clear out old views detachAllViewsFromParent(); switch (mLayoutMode) &#123; ......... case LAYOUT_FORCE_BOTTOM: sel = fillUp(mItemCount - 1, childrenBottom); adjustViewsUpOrDown(); break; case LAYOUT_FORCE_TOP: mFirstPosition = 0; sel = fillFromTop(childrenTop); adjustViewsUpOrDown(); break; ......... &#125; ......... &#125; setAdapter之后dataChanged为true，执行handleDataChanged()方法。1234567891011121314@Override protected void handleDataChanged() &#123; ......... // Nothing is selected. Give up and reset everything. mLayoutMode = mStackFromBottom ? LAYOUT_FORCE_BOTTOM : LAYOUT_FORCE_TOP; mSelectedPosition = INVALID_POSITION; mSelectedRowId = INVALID_ROW_ID; mNextSelectedPosition = INVALID_POSITION; mNextSelectedRowId = INVALID_ROW_ID; mNeedSync = false; mSelectorPosition = INVALID_POSITION; checkSelectionChanged(); &#125; 注意这个方法注意是设置mLayoutMode，通常是LAYOUT_FORCE_TOP，即从顶部开始一个一个的往下添加childview。&emsp;&emsp;布局中ListView默认没有设置android:stackfrombottom属性，因此回到layoutChildren()方法中，执行LAYOUT_FORCE_TOP条件语句，设置mFirstPosition=0后，将childrenTop(=0或padding top 后的值)，进入fillFromTop方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Fills the list from top to bottom, starting with mFirstPosition * * @param nextTop The location where the top of the first item should be * drawn * * @return The view that is currently selected */ private View fillFromTop(int nextTop) &#123; mFirstPosition = Math.min(mFirstPosition, mSelectedPosition); mFirstPosition = Math.min(mFirstPosition, mItemCount - 1); if (mFirstPosition &lt; 0) &#123; mFirstPosition = 0; &#125; return fillDown(mFirstPosition, nextTop); &#125; /** * Fills the list from pos down to the end of the list view. * * @param pos The first position to put in the list * * @param nextTop The location where the top of the item associated with pos * should be drawn * * @return The view that is currently selected, if it happens to be in the * range that we draw. */ //第一次进来pos = 0，nexttop 是 padding.top private View fillDown(int pos, int nextTop) &#123; View selectedView = null; int end = (mBottom - mTop);//可视区高度 if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; end -= mListPadding.bottom;//减去paddingbotton属性值 &#125; while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123; // is this the selected item? boolean selected = pos == mSelectedPosition; View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected); nextTop = child.getBottom() + mDividerHeight; if (selected) &#123; selectedView = child; &#125; pos++; &#125; return selectedView; &#125; 可视区域的高度(mBottom - mTop)，如果ListView条目很少，可视区高度不超过屏幕高度，最大不超过屏幕高度。&emsp;&emsp;while循环中，判断累计添加到listview中child的高度，不超过可视区域（添加最后一个child时，有可能只显示部分），且添加的child的下标不超过总的个数（否则系统会报 OutOfBounds 的异常）。在循环中，会去调用makeAndAddView，这个方法不会真正的去添加child，但会调用之后的setupChild来真正添加到listview中：123456789101112131415161718192021222324252627282930313233343536373839404142/** * Obtain the view and add it to our list of children. The view can be made * fresh, converted from an unused view, or used as is if it was in the * recycle bin. * * @param position Logical position in the list * @param y Top or bottom edge of the view to add * @param flow If flow is true, align top edge to y. If false, align bottom * edge to y. * @param childrenLeft Left edge where children should be positioned * @param selected Is this position selected? * @return View that was added */ private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; View child; //两种情况：1.数据源没有发生改变 2.数据源发生改变 if (!mDataChanged) &#123; // Try to use an existing view for this position child = mRecycler.getActiveView(position); if (child != null) &#123; if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(child, ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP, position, getChildCount()); &#125; // Found it -- we&apos;re using an existing child // This just needs to be positioned setupChild(child, position, y, flow, childrenLeft, selected, true); return child;//数据源没有发生改变，调用mRecycler.getActiveView(position); &#125; &#125; // Make a new view for this position, or convert an unused view if possible child = obtainView(position, mIsScrap);//数据源发生改变，调用obtainView() // This needs to be positioned and measured setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child; &#125; 该方法分两种情况： adapter中的数据发生了变化，初始setAdapter，或之后我们将adapter中的数据做了新增/删除后，调用Adapter.notifyDataSetChanged；变化了，就会从RecycleBin中的mScrapView中，取之前滑出屏幕的view，即convertView来复用； 若没有变化，则从RecycleBin的mActiveView中取当前显示的view（ 为啥会有这种情况？当listview稳定后，我们不滚动它，但有可能点击或长按 ），这时就会走到这里。&emsp;&emsp;obtainView就是从RecycleBin中，取移出去的View，传给Adapter.getView方法（convertView）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*** Get a view and have it show the data associated with the specified * position. This is called when we have already discovered that the view is * not available for reuse in the recycle bin. The only choices left are * converting an old view or making a new one. * * @param position The position to display * @param isScrap Array of at least 1 boolean, the first entry will become true if * the returned view was taken from the scrap heap, false if otherwise. * * @return A view displaying the data associated with the specified position */ View obtainView(int position, boolean[] isScrap) &#123; isScrap[0] = false; View scrapView; scrapView = mRecycler.getScrapView(position);//获取scrapView View child; if (scrapView != null) &#123;//如果缓存中有，将这个convertView传给Adapter.getView方法 if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(scrapView, ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP, position, -1); &#125; child = mAdapter.getView(position, scrapView, this); if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(child, ViewDebug.RecyclerTraceType.BIND_VIEW, position, getChildCount()); &#125; if (child != scrapView) &#123;//判断从getView方法中返回的view是否与scrapview一致 //如果一致，表明是复用的，反之，则程序又去创建了一个新的view（浪费了一块内存），且将得到的scrapview重新加入到RecycleBin.mScrapView中； mRecycler.addScrapView(scrapView, position); if (mCacheColorHint != 0) &#123; child.setDrawingCacheBackgroundColor(mCacheColorHint); &#125; if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(scrapView, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, position, -1); &#125; &#125; else &#123; isScrap[0] = true; child.dispatchFinishTemporaryDetach(); &#125; &#125; else &#123;//如果缓存中没有，则convertView为null，在Adapter中，需要自己去LayoutInflater一个view child = mAdapter.getView(position, null, this); if (mCacheColorHint != 0) &#123; child.setDrawingCacheBackgroundColor(mCacheColorHint); &#125; if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(child, ViewDebug.RecyclerTraceType.NEW_VIEW, position, getChildCount()); &#125; &#125; return child; &#125; 这个方法，实际上是在AbsListView类中的。RecycleBin类，它的作用就是一个View的缓存，将移出屏幕外的view回收，并给新移入到屏幕内的view来复用，这样就能节省大量内存。 回到makeAndAddView方法，将child传给setupChild，开始真正的加入到listView中去显示。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Add a view as a child and make sure it is measured (if necessary) and * positioned properly. * * @param child The view to add * @param position The position of this child * @param y The y position relative to which this view will be positioned * @param flowDown If true, align top edge to y. If false, align bottom * edge to y. * @param childrenLeft Left edge where children should be positioned * @param selected Is this position selected? * @param recycled Has this view been pulled from the recycle bin? If so it * does not need to be remeasured. */private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,boolean selected, boolean recycled) &#123; final boolean isSelected = selected &amp;&amp; shouldShowSelector(); final boolean updateChildSelected = isSelected != child.isSelected(); final int mode = mTouchMode; final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp; mMotionPosition == position; final boolean updateChildPressed = isPressed != child.isPressed(); final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested(); // Respect layout params that are already in the view. Otherwise make some up... // noinspection unchecked AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams(); if (p == null) &#123; p = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0); &#125; p.viewType = mAdapter.getItemViewType(position); if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123; attachViewToParent(child, flowDown ? -1 : 0, p); &#125; else &#123; p.forceAdd = false; if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; p.recycledHeaderFooter = true; &#125; addViewInLayout(child, flowDown ? -1 : 0, p, true); &#125; if (updateChildSelected) &#123; child.setSelected(isSelected); &#125; if (updateChildPressed) &#123; child.setPressed(isPressed); &#125; if (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mCheckStates != null) &#123; if (child instanceof Checkable) &#123; ((Checkable) child).setChecked(mCheckStates.get(position)); &#125; else if (getContext().getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123; child.setActivated(mCheckStates.get(position)); &#125; &#125; //如果需要测量,先测量子view if (needToMeasure) &#123; int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, mListPadding.left + mListPadding.right, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125; else &#123; cleanupLayoutState(child); &#125; final int w = child.getMeasuredWidth(); final int h = child.getMeasuredHeight(); final int childTop = flowDown ? y : y - h; if (needToMeasure) &#123; final int childRight = childrenLeft + w; final int childBottom = childTop + h; child.layout(childrenLeft, childTop, childRight, childBottom); &#125; else &#123; child.offsetLeftAndRight(childrenLeft - child.getLeft()); child.offsetTopAndBottom(childTop - child.getTop()); &#125; if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123; child.setDrawingCacheEnabled(true); &#125; if (recycled &amp;&amp; (((AbsListView.LayoutParams)child.getLayoutParams()).scrappedFromPosition) != position) &#123; child.jumpDrawablesToCurrentState(); &#125; &#125; &emsp;&emsp;attachViewToParent 和 addViewInLayout两者大致差不多，都是将view添加到parent view的array中，区别在于，attachView是不用去requestLayout的，而addViewInLayout的最后一个参数指明（true不用requestLayout，false则需要requestLayout），这两个方法都在ViewGroup中。&emsp;&emsp;flowDown ? -1 : 0 ， -1 和 0 的区别？我们看下attachViewToParent代码吧：12345678910111213141516171819202122232425262728293031323334/** * Attaches a view to this view group. Attaching a view assigns this group as the parent, * sets the layout parameters and puts the view in the list of children so it can be retrieved * by calling &#123;@link #getChildAt(int)&#125;. * * This method should be called only for view which were detached from their parent. * * @param child the child to attach * @param index the index at which the child should be attached * @param params the layout parameters of the child * * @see #removeDetachedView(View, boolean) * @see #detachAllViewsFromParent() * @see #detachViewFromParent(View) * @see #detachViewFromParent(int) */ protected void attachViewToParent(View child, int index, LayoutParams params) &#123; child.mLayoutParams = params; if (index &lt; 0) &#123; index = mChildrenCount; &#125; addInArray(child, index); child.mParent = this; child.mPrivateFlags = (child.mPrivateFlags &amp; ~DIRTY_MASK &amp; ~DRAWING_CACHE_VALID) | DRAWN | INVALIDATED; this.mPrivateFlags |= INVALIDATED; if (child.hasFocus()) &#123; requestChildFocus(child, child.findFocus()); &#125; &#125; 如果是-1，则将index = mChildrenCount，即从当前child view数组的尾部开始加入，如果是0， 则从当前child view的头部开始加入。&emsp;&emsp;默认情况下，添加到listview中的item，即child都会measure一次高度和宽度，然后，调用child.layout，通知新添加的child，layout一下它里面的children。&emsp;&emsp;然后，然后就没有了然后，整个流程走完，回到ListView.layoutChildren中，adjustViewsUpOrDown将所有child调整对齐，刷新一下RecycleBin的Active和Scrap缓存，调用updateScrollIndicators更新一下滚动条的值，若有注意OnScrollListener，也通知一下invokeOnItemScrollListener。","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"ListView源码分析(一)","date":"2015-09-12T05:12:23.000Z","path":"2015/09/12/ListView源码分析（一）/","text":"&emsp;&emsp;这几天把ListView源码看了下，基本整理下思路并写了这篇博客，也是对学习源码的一个记录。 首先看ListView的构造方法干了些什么12345678910111213141516171819202122232425262728293031323334353637383940414243public ListView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle);//父类AbsListview中初始化一些属性，比如焦点setFocusableInTouchMode（true），绘制setWillNotDraw(false)等 TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.ListView, defStyle, 0); CharSequence[] entries = a.getTextArray( com.android.internal.R.styleable.ListView_entries); if (entries != null) &#123; setAdapter(new ArrayAdapter&lt;CharSequence&gt;(context, com.android.internal.R.layout.simple_list_item_1, entries)); &#125; //获取item分割线 drawable 可以自定义 final Drawable d = a.getDrawable(com.android.internal.R.styleable.ListView_divider); if (d != null) &#123; // If a divider is specified use its intrinsic height for divider height setDivider(d); &#125; //头部样式 final Drawable osHeader = a.getDrawable( com.android.internal.R.styleable.ListView_overScrollHeader); if (osHeader != null) &#123; setOverscrollHeader(osHeader); &#125; //尾部样式 final Drawable osFooter = a.getDrawable( com.android.internal.R.styleable.ListView_overScrollFooter); if (osFooter != null) &#123; setOverscrollFooter(osFooter); &#125; // Use the height specified, zero being the default final int dividerHeight = a.getDimensionPixelSize( com.android.internal.R.styleable.ListView_dividerHeight, 0); if (dividerHeight != 0) &#123; setDividerHeight(dividerHeight); &#125; mHeaderDividersEnabled = a.getBoolean(R.styleable.ListView_headerDividersEnabled, true); mFooterDividersEnabled = a.getBoolean(R.styleable.ListView_footerDividersEnabled, true); a.recycle(); &#125; 上面构造方法做了一些初始化工作，并设置了默认样式 ####onMeasure()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Sets up mListPadding super.onMeasure(widthMeasureSpec, heightMeasureSpec); //格式化并取出MeasureSpec的模式和测量值大小 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childWidth = 0; int childHeight = 0; int childState = 0; mItemCount = mAdapter == null ? 0 : mAdapter.getCount(); if (mItemCount &gt; 0 &amp;&amp; (widthMode == MeasureSpec.UNSPECIFIED ||heightMode == MeasureSpec.UNSPECIFIED)) &#123; final View child = obtainView(0, mIsScrap); //测量childview measureScrapChild(child, 0, widthMeasureSpec); childWidth = child.getMeasuredWidth(); childHeight = child.getMeasuredHeight(); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (recycleOnMeasure() &amp;&amp; mRecycler.shouldRecycleViewType( ((LayoutParams) child.getLayoutParams()).viewType)) &#123; mRecycler.addScrapView(child, -1); &#125; &#125; if (widthMode == MeasureSpec.UNSPECIFIED) &#123; widthSize = mListPadding.left + mListPadding.right + childWidth + getVerticalScrollbarWidth(); &#125; else &#123; widthSize |= (childState&amp;MEASURED_STATE_MASK); &#125; if (heightMode == MeasureSpec.UNSPECIFIED) &#123; heightSize = mListPadding.top + mListPadding.bottom + childHeight + getVerticalFadingEdgeLength() * 2; &#125; if (heightMode == MeasureSpec.AT_MOST) &#123; // TODO: after first layout we should maybe start at the first visible position, not 0 heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1); &#125; setMeasuredDimension(widthSize , heightSize); mWidthMeasureSpec = widthMeasureSpec; &#125;private void measureScrapChild(View child, int position, int widthMeasureSpec) &#123; LayoutParams p = (LayoutParams) child.getLayoutParams(); if (p == null) &#123; p = (AbsListView.LayoutParams) generateDefaultLayoutParams(); child.setLayoutParams(p); &#125; p.viewType = mAdapter.getItemViewType(position); p.forceAdd = true; int childWidthSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, mListPadding.left + mListPadding.right, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125; 上述操作对ListView的测量并赋值给成员变量 ，注意ListView第一次创建的时候并没有mAdapter的存在,只有在setAdapter被我们调用过后才会执行这些方法,也就是说在setAdapter中一定会调用requestLayout方法重新走一遍流程。 ####onLayout方法 &emsp;&emsp;ListView中并没有onLayout方法,那也就是说一定是在他的父类AbsListView中,我们可以看到它调用了layoutChildren(),从方法名看应该是对子view进行布局,这个layoutChildren是一个空实现方法,也就是说应该是通过AbsListView的子类ListVIew和GridView进行实现123456789101112131415161718192021222324protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mInLayout = true; //拿到view 数量 final int childCount = getChildCount(); if (changed) &#123; for (int i = 0; i &lt; childCount; i++) &#123; getChildAt(i).forceLayout(); &#125; mRecycler.markChildrenDirty(); &#125; // 由子类ListView 和 GridView实现,是核心布局方法代码,也是listview与adapter交互数据的主要入口函数 layoutChildren(); mInLayout = false; mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR; // TODO: Move somewhere sane. This doesn&apos;t belong in onLayout(). if (mFastScroll != null) &#123; mFastScroll.onItemCountChanged(getChildCount(), mItemCount); &#125; &#125; 这里注意两个对象： View[] mActiveViews:存放的是当前ListView可以使用的待激活的子item view ArrayList[] mScrapViews:存放的是在ListView滑动过程中滑出屏幕来回收以便下次利用的子item view 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Override protected void layoutChildren() &#123; ... final int firstPosition = mFirstPosition; final RecycleBin recycleBin = mRecycler; // 只有在调用adapter.notifyDatasetChanged()方法一直到layout()布局结束, //dataChanged为true,默认为false,这里如果调用notifyDatasetChanged,就会将Item添加到ReyclerBin当中,这个 //ReyclerBin封装了这两个集合用来存放对应的符合条件的item,用来实现复用机制 //1.View[] mActiveViews : 存放的是当前ListView可以使用的待激活的子item view //2.ArrayList&lt;View&gt;[] mScrapViews : 存放的是在ListView滑动过程中滑出屏幕来回收以便下次利用的子item view if (dataChanged) &#123; // dataChanged为true,说明当前listview是有数据的了,把当前所有的item view // 存放到RecycleBin对象的mScrapViews中保存 for (int i = 0; i &lt; childCount; i++) &#123; recycleBin.addScrapView(getChildAt(i), firstPosition+i); &#125; &#125; else &#123; // dataChanged默认为false,第一次执行此方法走这里 //将view添加到 activeViews[] 中 recycleBin.fillActiveViews(childCount, firstPosition); &#125; ... switch (mLayoutMode) &#123; ... default: //一般情况下走这里 if (childCount == 0) &#123; // 第一次布局的时候,因为还没有setAdapter,没有走mAdpate.getCount方法,所以childCount必然为0 if (!mStackFromBottom) &#123; final int position = lookForSelectablePosition(0, true); setSelectedPositionInt(position); // 从上到上布局listview能显示得下的子view,具体的填充view的方法,下面讲到 sel = fillFromTop(childrenTop); &#125; else &#123; final int position = lookForSelectablePosition(mItemCount - 1, false); setSelectedPositionInt(position); sel = fillUp(mItemCount - 1, childrenBottom); &#125; &#125; else &#123; // 非第一次layout,也就说执行了nitifyDatasetChanged方法之后 if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123; sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop()); &#125; else if (mFirstPosition &lt; mItemCount) &#123; // 通常情况走这里,fillSpecific()会调用fillUp()和fillDown()布局子view sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop()); &#125; else &#123; sel = fillSpecific(0, childrenTop); &#125; &#125; break; &#125; //到这里,ListView中的view就被填充完毕. ... //布局完成之后记录状态 mLayoutMode = LAYOUT_NORMAL; mDataChanged = false; &#125; Item布局的填充在layoutChidren中有几个以fill开头的方法就是具体的Item的填充方法。fillSpecific()会根据mStackFromBottom参数判断填充方向,通过fillUp,fillDown进行填充123456789101112131415161718192021222324252627282930313233343536373839404142private View fillSpecific(int position, int top) &#123; boolean tempIsSelected = position == mSelectedPosition; View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected); // Possibly changed again in fillUp if we add rows above this one. mFirstPosition = position; View above; View below; final int dividerHeight = mDividerHeight; //根据填充方向,如果mStackFromBottom为false,表示从顶部向底部填充,true反之 //mStackFromBottom 可以通过 xml文件android:stackFromBottom=&quot;false&quot;设置,默认为false if (!mStackFromBottom) &#123; //具体填充方法 above = fillUp(position - 1, temp.getTop() - dividerHeight); // This will correct for the top of the first view not touching the top of the list adjustViewsUpOrDown(); //具体填充方法 below = fillDown(position + 1, temp.getBottom() + dividerHeight); int childCount = getChildCount(); if (childCount &gt; 0) &#123; correctTooHigh(childCount); &#125; &#125; else &#123; below = fillDown(position + 1, temp.getBottom() + dividerHeight); // This will correct for the bottom of the last view not touching the bottom of the list adjustViewsUpOrDown(); above = fillUp(position - 1, temp.getTop() - dividerHeight); int childCount = getChildCount(); if (childCount &gt; 0) &#123; correctTooLow(childCount); &#125; &#125; if (tempIsSelected) &#123; return temp; &#125; else if (above != null) &#123; return above; &#125; else &#123; return below; &#125;&#125; 具体填充布局可以看我的另一篇博客ListView源码分析(二) ####setAdaptersetAdapter中通过mAdapter.registerDataSetObserver(mDataSetObserver)注册一个AdapterDataSetObserver订阅者，每当调用notifyDataSetChange的时候,就会触发AdapterDataSetObserver的onChanged的方法,这个是观察者模式，这个方法最终调用requestLayout方法，也就是说我们每次setAdapter之后就会重新布局,这时候mAdapter不为空。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Overridepublic void setAdapter(ListAdapter adapter) &#123; if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mAdapter.unregisterDataSetObserver(mDataSetObserver); //将一些成员变量还原设置为初始默认值 //mLayoutMode = LAYOUT_NORMAL resetList(); // mRecycler的mScrapViews清空并执行listview.removeDetachedView //mScrapViews 存放边界之外的view mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; // 如果listview有headerView或者FooterView则会生成包装adapter,生成一个含有HeaderView 和footerView的adapter mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; mAdapter = adapter; &#125; mOldSelectedPosition = INVALID_POSITION;//-1 mOldSelectedRowId = INVALID_ROW_ID;//Long.MIN_VALUE // AbsListView#setAdapter will update choice mode states. //给父亲 adblistView 设置 adapter super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; //调用adapter的getCount 得到条目个数 mItemCount = mAdapter.getCount(); checkFocus(); //注册观察者,这个观察者每当调用notifyDataSetChange的时候就会触发 mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); // 设置listview的数据源类型,并在mRecycler中初始化对应个数的scrapViews list mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; if (mStackFromBottom) &#123; position = lookForSelectablePosition(mItemCount - 1, false); &#125; else &#123; position = lookForSelectablePosition(0, true); &#125; setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) &#123; // Nothing selected checkSelectionChanged(); &#125; &#125; else &#123; mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); &#125; // 会调用顶层viewRootImpl.performTraversals(),导致视图重绘,listview刷新 requestLayout();&#125; ####notifyDataSetChanged这个方法在BaseAdapter中123public void notifyDataSetChanged() &#123; mDataSetObservable.notifyChanged();&#125; 这时候根据观察者模式,会调用订阅者AdapterDataSetObserver的onChanged方法,上面提到过,最终还是会调用requestLayout进行重新布局1234567891011121314151617181920@Overridepublic void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); // 同样,最终调用viewRootImpl.performTraversals(),导致视图重绘,执行listview的 // measure layout 方法等 requestLayout();&#125;","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"Http协议与TCP协议易混淆点（一）","date":"2015-03-22T05:22:46.000Z","path":"2015/03/22/Http协议与TCP协议易混淆点（一）/","text":"###Http协议与TCP协议1.TCP协议对应于传输层，而HTTP协议对应于应用层，从本质上来说，二者没有可比性。2.Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。 &emsp;&emsp;所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，成为无状态连接。 那么问题来了：每次创建新连接不耗费性能吗？&emsp;&emsp;从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性。也就是说，在打开一个网页之后，客户端与服务器之间的传输数据的TCP连接不马上关闭，客户端再次访问时会使用，但是Keep-Alive保持时间不是有限的，超时之后还是会断开，所以我们还把其看做是每次连接完成后就会关闭。后来，通过Session, Cookie等相关技术，也能保持一些用户的状态。但是还是每次都使用一个连接，依然是无状态连接。 为什么HTTP是无状态的短连接，而TCP是有状态的长连接？Http不是建立在TCP的基础上吗，为什么还能是短连接？&emsp;&emsp;Http就是在每次请求完成后就把TCP连接关了，所以是短连接。而我们直接通过Socket编程使用TCP协议的时候，因为我们自己可以通过代码区控制什么时候打开连接什么时候关闭连接，只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一直存在，相关状态数据会一直保存着。","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"APP开发屏幕适配","date":"2015-02-12T05:19:39.000Z","path":"2015/02/12/APP开发屏幕适配/","text":"支持不同屏幕尺寸通过下列方法支持不同的屏幕尺寸： 确保您的布局能够根据屏幕适当地调整大小 根据屏幕配置提供合适的 UI 布局 确保对正确的屏幕应用正确的布局 提供可正常缩放的位图具体适配方案：1、使用“wrap_content”和“match_parent”&emsp;&emsp;为确保您的布局能够灵活地适应不同的屏幕尺寸，您应该为某些视图组件的宽度和高度使用 “wrap_content” 和 “match_parent”，代替硬编码。2、使用 RelativeLayout&emsp;&emsp;RelativeLayout允许您根据组件之间的空间关系指定布局。3、使用尺寸限定符&emsp;&emsp; 上述两种方案无法为每一种屏幕尺寸提供最佳用户体验。 因此，您的应用不仅应实现灵活布局，还应针对不同的屏幕配置提供多种备选布局；可以利用配置限定符来实现此目的，它允许运行组件根据当前设备配置（如针对不同屏幕尺寸的不同布局设计）自动选择合适的资源。&emsp;&emsp; 例如，许多应用都针对大屏幕实现了“双窗格”模式（应用可以在一个窗格中显示项目列表，在另一个窗格中显示项目内容）。 平板电脑和 TV 足够大，可在一个屏幕上同时容纳两个窗格，但手机屏幕只能独立显示它们。 因此，如需实现这些布局，您可以建立以下文件：res/layout/main.xml，单窗格（默认）布局：xmlns:android=\"http://schemas.android.com/apk/res/android\"123456789 android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-large/main.xml，双窗格布局：1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 注意第二个布局目录名称中的 large 限定符。在屏幕归类为大屏幕的设备（例如，7 英寸及更大尺寸的平板电脑）上，将选择此布局。 对于小型设备，将选择另一个布局（无限定符）。4、使用最小宽度限定符&emsp;&emsp;Android 在 Android 3.2 中引入了“最小宽度”限定符。允许您将目标锁定在具有特定最小宽度（单位：dp）的屏幕。&emsp;&emsp; 例如，典型的 7 英寸平板电脑最小宽度为 600dp，因此，如果您希望您的 UI 在这些屏幕上显示两个窗格（但在较小屏幕上显示单个列表），您同样可以为单窗格布局和双窗格布局使用前文中的两种布局，但不使用 large 尺寸限定符，而是使用 sw600dp 为最小宽度是 600dp 的屏幕指定双窗格布局： res/layout/main.xml，单窗格（默认）布局： 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-sw600dp/main.xml，双窗格布局：1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 这意味着，最小宽度大于或等于 600dp 的设备将选择 layout-sw600dp/main.xml（双窗格）布局，而屏幕较小的设备将选择 layout/main.xml（单窗格）布局。 不过，这种方法在低于 3.2 版本的设备上不太奏效，因为它们无法将 sw600dp 识别为尺寸限定符，所以您仍需使用 large 限定符。因此，您应该建立一个与 res/layout-sw600dp/main.xml 完全相同的、名为 res/layout-large/main.xml 的文件。下文介绍的技巧可让您避免因此而产生重复的布局文件5、使用布局别名&emsp;&emsp;最小宽度限定符仅在 Android 3.2 及更高版本上提供。因此，您仍应使用兼容早期版本的抽象尺寸容器（小、正常、大和超大）。 例如，如果您想让自己设计的 UI 在手机上显示单窗格 UI，但在 7 英寸平板电脑、TV 及其他大屏设备上显示多窗格 UI，则需要提供下列文件： res/layout/main.xml: 单窗格布局 res/layout-large: 多窗格布局 res/layout-sw600dp: 多窗格布局 后两个文件完全相同，因为其中一个将由 Android 3.2 设备匹配，另一个是为了照顾使用早期版本 Android 的平板电脑和 TV 的需要。 为避免为平板电脑和 TV 产生相同的重复文件（以及由此带来的维护难题），您可以使用别名文件。 例如，您可以定义下列布局: res/layout/main.xml，单窗格布局 res/layout/main_twopanes.xml，双窗格布局 并添加以下两个文件： res/values-large/layout.xml: 123&lt;resources&gt; &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; res/values-sw600dp/layout.xml： 123&lt;resources&gt; &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; 后两个文件内容完全相同，但它们实际上并未定义布局， 而只是将 main 设置为 main_twopanes 的别名。由于这些文件具有 large 和 sw600dp 选择器，因此它们适用于任何 Android 版本的平板电脑和电视（低于 3.2 版本的平板电脑和电视匹配 large，高于 3.2 版本者将匹配 sw600dp）6、使用屏幕方向限定符&emsp;&emsp;某些布局在横向和纵向屏幕方向下都表现不错，但其中大多数布局均可通过调整做进一步优化。 在 News Reader 示例应用中，以下是布局在各种屏幕尺寸和屏幕方向下的行为： 小屏幕，纵向：单窗格，带徽标小屏幕，横向：单窗格，带徽标7 英寸平板电脑，纵向：单窗格，带操作栏7 英寸平板电脑，横向：双窗格，宽，带操作栏10 英寸平板电脑，纵向：双窗格，窄，带操作栏10 英寸平板电脑，横向：双窗格，宽，带操作栏TV，横向：双窗格，宽，带操作栏&emsp;&emsp;因此，以上每一种布局都在 res/layout/ 目录下的某个 XML 文件中定义。如果之后需要将每一种布局分配给各种屏幕配置，应用会使用布局别名将它们与每一种配置进行匹配： res/layout/onepane.xml: 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/onepane_with_bar.xml: 1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:id=&quot;@+id/linearLayout1&quot; android:gravity=&quot;center&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:src=&quot;@drawable/logo&quot; android:paddingRight=&quot;30dp&quot; android:layout_gravity=&quot;left&quot; android:layout_weight=&quot;0&quot; /&gt; &lt;View android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/view1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;Button android:id=&quot;@+id/categorybutton&quot; android:background=&quot;@drawable/button_bg&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;0&quot; android:layout_width=&quot;120dp&quot; style=&quot;@style/CategoryButtonStyle&quot;/&gt; &lt;/LinearLayout&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes.xml： 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes_narrow.xml： 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;200dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 至此所有可能的布局均已定义，现在只需使用配置限定符将正确的布局映射到每一种配置。 现在您可以使用布局别名技巧来完成这项工作： res/values/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane_with_bar&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-land/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-port/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-large-land/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-large-port/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes_narrow&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; 7、使用九宫格位图（.9.png）","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"Java中的常用集合类","date":"2014-05-23T05:24:37.000Z","path":"2014/05/23/Java中的常用集合类/","text":"java中的常用集合类 1、ArrayList：ArrayList 里面的数据都是有序的，并且可以重复ArayList 缺点：删除慢，随机插入慢举例：如何将数组中的元素变为集合 12String name[] = &#123;&quot;Tom&quot;,&quot;jack&quot;&#125;;List&lt;String &gt;list = Arrays.asList(name); 2、LinkedList共性：有序 可以重复（里面的元素）区别：数据的存储方式不同 ArrayList本质：数组 LinkedList本质：链表优点：随机插入快，随机删除快缺点：随机获取元素慢，逐个遍历每个元素，而ArrayList是通过下标获取元素 3、HashSet共性：持有对象，全部放到[ ]中区别：1.存入的对象是无序的（相对无序） HashSet 的排序规则是根据hashCode产生的 2.存入HashSet容器的对象不能重复 HashSet先判断两个对象的hashCode是否相同，再判断 两个对象的Equals是否相同 注意：放入HashSe中的对象类型，必须覆盖hashCode()方法和Equals方法 放入Se中的对象类型，必须覆盖hashCode()方法和Equals方法，严格的还需要覆盖toString方法，Set无序，没有get方法 4、HashMap特点：Map以键值对（key：value）的形式存储数据，Map中的键可以是int，也可以是其他任意数据类型键必须唯一，值可以相同放入Map中的键必须要覆盖Object类hashCode和Equals，toString方法HashMap常用方法： containsKey(Object key)containsValue(Object value) map.values()返回Map中的所有值map.keySet()返回Map中所有的键 Map的迭代方法entrySet使用：如何打印系统的所有环境变量 123456Map&lt;String,String&gt;envMap = System.getenv(); for(Map.Entry&lt;String,String&gt;entry:envMap.entrySet())&#123; String key = entry.getKey(); String value = entry.getValue(); System.out.println(&quot;key = &quot;+key,&quot;value = &quot;+vaule);&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"比较器comparable和comparator的区别","date":"2014-05-12T05:24:37.000Z","path":"2014/05/12/比较器comparable和comparator的区别/","text":"比较器comparable和comparator的区别 Java提供了一个集合工具类，里面有排序方法，Collections使用它提供的方法来完成排序注意：Collection不是Collections，Collections是在Collection上进行操作的集合的一个工具类，就如Arrays是数组的工具类 1234567891011public class ComparableTest &#123; public static void main(String[] args) &#123; String names[] = &#123; &quot;Jack&quot;, &quot;Adam&quot;, &quot;Bob&quot; &#125;; List&lt;String&gt; list = Arrays.asList(names); System.out.println(list); //排序的方式String已经替我们完成了 //String会调用compareTo（）方法实现排序的功能 Collections.sort(list); System.out.println(list); &#125;&#125; String类实现Comparable接口，当调用sort规则时，String会调用compareTo方法实现排序功能 123456789101112131415161718public class StudentComparable &#123; public static void main(String[] args) &#123; Student stu[] = &#123; new Student(&quot;005&quot;, &quot;Jackson&quot;, 3, 3, &quot;football&quot;), new Student(&quot;001&quot;, &quot;Jerry&quot;, 1, 3, &quot;football&quot;), new Student(&quot;002&quot;, &quot;Adam&quot;, 5, 2, &quot;Tennis&quot;) &#125;; //错误原因：1Student没有实现Comparable接口 // 2 没有指定排序规则（id、name、hobby） List&lt;Student&gt; list = Arrays.asList(stu); //如何比较排序？ Collections.sort方法进行排序，它会回调 容器中Student对象的 compareTo方法 Collections.sort(list); for(Student student : list)&#123; System.out.println(student); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class Student implements Comparable&lt;Student&gt;&#123; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getGrade() &#123; return grade; &#125; public void setGrade(int grade) &#123; this.grade = grade; &#125; public int getClassNo() &#123; return classNo; &#125; public void setClassNo(int classNo) &#123; this.classNo = classNo; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125; @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;, grade=&quot; + grade + &quot;, classNo=&quot; + classNo + &quot;, hobby=&quot; + hobby + &quot;]&quot;; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + classNo; result = prime * result + grade; result = prime * result + ((hobby == null) ? 0 : hobby.hashCode()); result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (classNo != other.classNo) return false; if (grade != other.grade) return false; if (hobby == null) &#123; if (other.hobby != null) return false; &#125; else if (!hobby.equals(other.hobby)) return false; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; public Student(String id,String name,int grade,int classNo,String hobby) &#123; this.id =id; this.name = name; this.grade = grade; this.classNo = classNo; this.hobby = hobby; &#125; private String id; private String name; private int grade; private int classNo; private String hobby; /** * Comparable 的compareTo方法为我们提供了比较的功能， * 如何比较 * 怎么做需要在Student类中实现 * 我的规则：按照学生的ID进行排序 */ @Override public int compareTo(Student o) &#123; //两个对象需要做比较 //this的id 如果大于 o 的id 返回的是正数 //this的id 如果等于 o 的id 返回的是0 //this的id 如果小于 o 的id 返回的是负数// int result = -(this.getId().compareTo(o.getId()));// return result; // if(this.getId().compareTo(o.getId()) &gt;0)&#123;// return 1;// &#125;else if(this.getId().compareTo(o.getId())&lt;0)&#123;// return -1;// &#125;// return 0; //按照年级进行排序 if(this.getGrade() &gt; o.getGrade())&#123; return 1; &#125;else if(this.getGrade() &lt; o.getGrade())&#123; return -1; &#125; return 0; &#125; //制定一个策略：输入1 id 输入2 name 输入3 爱好排序&#125; 如果只比较一次 ，可以使用匿名内部类节约资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CheLueCompator &#123; public static void main(String[] args) &#123; Student stu[] = &#123; new Student(&quot;005&quot;, &quot;Jackson&quot;, 3, 6, &quot;football&quot;), new Student(&quot;001&quot;, &quot;Zero&quot;, 1, 3, &quot;basketball&quot;), new Student(&quot;002&quot;, &quot;Adam&quot;, 5, 2, &quot;tennis&quot;) &#125;; List&lt;Student&gt; list = Arrays.asList(stu); sortList(list); &#125; public static void sortList(List&lt;Student&gt; list) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入排序编号 1按照学生名称 2按照爱好 3按照班级编号&quot;); int num = input.nextInt(); switch (num) &#123; case 1: //两个参数 1需要排序的列表 2排序的策略 （按照名称排序） //匿名内部类：接口回调（由谁回调谁？）sort方法回调匿名内部类 //好莱坞原则：sort理解为好莱坞 ，匿名内部类理解为演员 //你不要找我，如果有需要我来找你，前提（匿名内部类需要向好莱坞进行注册） //如何注册（匿名内部类作为参数传入sort方法），sort方法需要的时候会回调匿名内部类的方法 Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //调用String的compareTo()方法 return o1.getName().compareTo(o2.getName()); &#125; &#125;); break; case 2: Collections.sort(list,new StuHobbyCompator()); break; case 3: Collections.sort(list,new StuClassNoCompator()); break; default: System.out.println(&quot;Error&quot;); break; &#125; input.close(); iteratorStu(list); &#125; public static void iteratorStu(List&lt;Student&gt; list) &#123; for(Student student : list)&#123; System.out.println(student); &#125; &#125;&#125; Comparable和Comparator的区别 1、Comparable:在java.lang包，通常由实体类(Student)来实现，用来定义默认的排序规则StudentComparable.java回调容器中Student对象的 compareTo方法Comparator:在java.util包，排序的工具类，是一种策略，通常一个实体类(Student)有一种默认的排序法，还有多种排序策略Comparable 定义在 Person类的内部: public class Persion implements Comparable {..比较Person的大小..},因为已经实现了比较器,那么我们的Person现在是一个可以比较大小的对象了,它的比较功能和String完全一样 2、ComparatorComparator 是定义在Person的外部的, 此时我们的Person类的结构不需要有任何变化,如 public class Person{ String name; int age }, 然后我们另外定义一个比较器: public PersonComparator implements Comparator() {..比较Person的大小..},用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。在PersonComparator里面实现了怎么比较两个Person的大小. 所以,用这种方法,当我们要对一个 personList进行排序的时候, 我们除了了要传递personList过去, 还需要把PersonComparator传递过去,因为怎么比较Person的大小是在PersonComparator里面实现的, 如: Collections.sort( personList , new PersonComparator() ).一个是自已完成比较，一个是外部程序实现比较的差别而已。3、Comparator 和 Comparable 的实例实现Comparable接口要覆盖compareTo方法, 在compareTo方法里面实现比较 12345678910111213public class Person implements Comparable &#123; String name; int age public int compareTo(Person another) &#123; int i = 0; i = name.compareTo(another.name); // 使用字符串的比较 if(i == 0) &#123; // 如果名字一样,比较年龄, 返回比较年龄结果 return age - another.age; &#125; else &#123; return i; // 名字不一样, 返回比较名字的结果. &#125; &#125;&#125; 这时我们可以直接用 Collections.sort( personList ) 对其排序了. 实现Comparator需要覆盖 compare 方法： 12345678910111213141516public class Person&#123; String name; int age&#125;class PersonComparator implements Comparator &#123; public int compare(Person one, Person another) &#123; int i = 0; i = one.name.compareTo(another.name); // 使用字符串的比较，即调用String的比较丰富 if(i == 0) &#123; // 如果名字一样,比较年龄,返回比较年龄结果 return one.age - another.age; &#125; else &#123; return i; // 名字不一样, 返回比较名字的结果. &#125; &#125;&#125; Collections.sort( personList , new PersonComparator()) 可以对其排序 4、总结 两种方法各有优劣, 用Comparable 简单, 只要实现Comparable 接口的对象直接就成为一个可以比较的对象,但是需要修改源代码, 用Comparator 的好处是不需要修改源代码, 而是另外实现一个比较器, 当某个自定义的对象需要作比较的时候,把比较器和对象一起传递过去就可以比大小了, 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]}]