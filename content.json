[{"title":"Hello World","date":"2017-03-06T15:56:21.406Z","path":"2017/03/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Java8新特性之lambda表达式入门（二）","date":"2016-07-30T05:44:18.000Z","path":"2016/07/30/Java8新特性之lambda表达式入门（二）/","text":"Lambda表达式是Java SE 8中一个重要的新特性。 lambda表达式允许你通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。 Lambda表达式还增强了集合库。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及 java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。 Lambda表达式的语法基本语法:(parameters) -&gt; expression或(parameters) -&gt;{ statements; }下面是Java lambda表达式的简单例子:1234567891011121314// 1. 不需要参数,返回值为 5() -&gt; 5// 2. 接收一个参数(数字类型),返回其2倍的值x -&gt; 2 * x// 3. 接受2个参数(数字),并返回他们的差值(x, y) -&gt; x – y// 4. 接收2个int型整数,返回他们的和(int x, int y) -&gt; x + y// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)(String s) -&gt; System.out.print(s) 基本的Lambda例子现在,我们已经知道什么是lambda表达式,让我们先从一些基本的例子开始。 在本节中,我们将看到lambda表达式如何影响我们编码的方式。 假设有一个玩家List ,程序员可以使用 for 语句 (“for 循环”)来遍历,在Java SE 8中可以转换为另一种形式:1234567891011121314151617String[] atp = &#123;&quot;Rafael Nadal&quot;, &quot;Novak Djokovic&quot;, &quot;Stanislas Wawrinka&quot;, &quot;David Ferrer&quot;,&quot;Roger Federer&quot;, &quot;Andy Murray&quot;,&quot;Tomas Berdych&quot;, &quot;Juan Martin Del Potro&quot;&#125;;List&lt;String&gt; players = Arrays.asList(atp);// 以前的循环方式for (String player : players) &#123; System.out.print(player + &quot;; &quot;);&#125;// 使用 lambda 表达式以及函数操作(functional operation)players.forEach((player) -&gt; System.out.print(player + &quot;; &quot;)); // 在 Java 8 中使用双冒号操作符(double colon operator)players.forEach(System.out::println); 正如您看到的,lambda表达式可以将我们的代码缩减到一行。 另一个例子是在图形用户界面程序中,匿名类可以使用lambda表达式来代替。 同样,在实现Runnable接口时也可以这样使用:12345678910// 使用匿名内部类btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent event) &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;); // 或者使用 lambda expressionbtn.setOnAction(event -&gt; System.out.println(&quot;Hello World!&quot;)); 下面是使用lambdas 来实现 Runnable接口 的示例:12345678910111213141516171819202122232425// 1.1使用匿名内部类new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Hello world !&quot;); &#125;&#125;).start();// 1.2使用 lambda expressionnew Thread(() -&gt; System.out.println(&quot;Hello world !&quot;)).start();// 2.1使用匿名内部类Runnable race1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Hello world !&quot;); &#125;&#125;;// 2.2使用 lambda expressionRunnable race2 = () -&gt; System.out.println(&quot;Hello world !&quot;); // 直接调用 run 方法(没开新线程哦!)race1.run();race2.run(); Runnable 的 lambda表达式,使用块格式,将五行代码转换成单行语句。 接下来,在下一节中我们将使用lambdas对集合进行排序。 使用Lambdas排序集合在Java中,Comparator 类被用来排序集合。 在下面的例子中,我们将根据球员的 name, surname, name 长度 以及最后一个字母。 和前面的示例一样,先使用匿名内部类来排序,然后再使用lambda表达式精简我们的代码。在第一个例子中,我们将根据name来排序list。 使用旧的方式,代码如下所示:12345678910111213String[] players = &#123;&quot;Rafael Nadal&quot;, &quot;Novak Djokovic&quot;, &quot;Stanislas Wawrinka&quot;, &quot;David Ferrer&quot;, &quot;Roger Federer&quot;, &quot;Andy Murray&quot;, &quot;Tomas Berdych&quot;, &quot;Juan Martin Del Potro&quot;, &quot;Richard Gasquet&quot;, &quot;John Isner&quot;&#125;; // 1.1 使用匿名内部类根据 name 排序 playersArrays.sort(players, new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; return (s1.compareTo(s2)); &#125;&#125;); 使用lambdas,可以通过下面的代码实现同样的功能:123456// 1.2 使用 lambda expression 排序 playersComparator&lt;String&gt; sortByName = (String s1, String s2) -&gt; (s1.compareTo(s2));Arrays.sort(players, sortByName);// 1.3 也可以采用如下形式:Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2))); 其他的排序如下所示。 和上面的示例一样,代码分别通过匿名内部类和一些lambda表达式来实现Comparator12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 1.1 使用匿名内部类根据 surname 排序 playersArrays.sort(players, new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; return (s1.substring(s1.indexOf(&quot; &quot;)).compareTo(s2.substring(s2.indexOf(&quot; &quot;)))); &#125;&#125;);// 1.2 使用 lambda expression 排序,根据 surnameComparator&lt;String&gt; sortBySurname = (String s1, String s2) -&gt; ( s1.substring(s1.indexOf(&quot; &quot;)).compareTo( s2.substring(s2.indexOf(&quot; &quot;)) ) );Arrays.sort(players, sortBySurname);// 1.3 或者这样,怀疑原作者是不是想错了,括号好多...Arrays.sort(players, (String s1, String s2) -&gt; ( s1.substring(s1.indexOf(&quot; &quot;)).compareTo( s2.substring(s2.indexOf(&quot; &quot;)) ) ) );// 2.1 使用匿名内部类根据 name lenght 排序 playersArrays.sort(players, new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; return (s1.length() - s2.length()); &#125;&#125;);// 2.2 使用 lambda expression 排序,根据 name lenghtComparator&lt;String&gt; sortByNameLenght = (String s1, String s2) -&gt; (s1.length() - s2.length());Arrays.sort(players, sortByNameLenght);// 2.3 or thisArrays.sort(players, (String s1, String s2) -&gt; (s1.length() - s2.length()));// 3.1 使用匿名内部类排序 players, 根据最后一个字母Arrays.sort(players, new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; return (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1)); &#125;&#125;);// 3.2 使用 lambda expression 排序,根据最后一个字母Comparator&lt;String&gt; sortByLastLetter = (String s1, String s2) -&gt; (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));Arrays.sort(players, sortByLastLetter);// 3.3 or thisArrays.sort(players, (String s1, String s2) -&gt; (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1))); 就是这样,简洁又直观。 在下一节中我们将探索更多lambdas的能力,并将其与 stream 结合起来使用。 使用Lambdas和StreamsStream是对集合的包装,通常和lambda一起使用。 使用lambdas可以支持许多操作,如 map, filter, limit, sorted, count, min, max, sum, collect 等等。 同样,Stream使用懒运算,他们并不会真正地读取所有数据,遇到像getFirst() 这样的方法就会结束链式语法。 在接下来的例子中,我们将探索lambdas和streams 能做什么。 我们创建了一个Person类并使用这个类来添加一些数据到list中,将用于进一步流操作。 Person 只是一个简单的POJO类:1234567891011121314151617public class Person &#123;private String firstName, lastName, job, gender;private int salary, age;public Person(String firstName, String lastName, String job, String gender, int age, int salary) &#123; this.firstName = firstName; this.lastName = lastName; this.gender = gender; this.age = age; this.job = job; this.salary = salary;&#125;// Getter and Setter // . . . . .&#125; 接下来,我们将创建两个list,都用来存放Person对象:1234567891011121314151617181920212223242526272829List&lt;Person&gt; javaProgrammers = new ArrayList&lt;Person&gt;() &#123; &#123; add(new Person(&quot;Elsdon&quot;, &quot;Jaycob&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 43, 2000)); add(new Person(&quot;Tamsen&quot;, &quot;Brittany&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 23, 1500)); add(new Person(&quot;Floyd&quot;, &quot;Donny&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 33, 1800)); add(new Person(&quot;Sindy&quot;, &quot;Jonie&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 32, 1600)); add(new Person(&quot;Vere&quot;, &quot;Hervey&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 22, 1200)); add(new Person(&quot;Maude&quot;, &quot;Jaimie&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 27, 1900)); add(new Person(&quot;Shawn&quot;, &quot;Randall&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 30, 2300)); add(new Person(&quot;Jayden&quot;, &quot;Corrina&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 35, 1700)); add(new Person(&quot;Palmer&quot;, &quot;Dene&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 33, 2000)); add(new Person(&quot;Addison&quot;, &quot;Pam&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 34, 1300)); &#125;&#125;;List&lt;Person&gt; phpProgrammers = new ArrayList&lt;Person&gt;() &#123; &#123; add(new Person(&quot;Jarrod&quot;, &quot;Pace&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 34, 1550)); add(new Person(&quot;Clarette&quot;, &quot;Cicely&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 23, 1200)); add(new Person(&quot;Victor&quot;, &quot;Channing&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 32, 1600)); add(new Person(&quot;Tori&quot;, &quot;Sheryl&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 21, 1000)); add(new Person(&quot;Osborne&quot;, &quot;Shad&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 32, 1100)); add(new Person(&quot;Rosalind&quot;, &quot;Layla&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 25, 1300)); add(new Person(&quot;Fraser&quot;, &quot;Hewie&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 36, 1100)); add(new Person(&quot;Quinn&quot;, &quot;Tamara&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 21, 1000)); add(new Person(&quot;Alvin&quot;, &quot;Lance&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 38, 1600)); add(new Person(&quot;Evonne&quot;, &quot;Shari&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 40, 1800)); &#125;&#125;; 现在我们使用forEach方法来迭代输出上述列表:123System.out.println(&quot;所有程序员的姓名:&quot;);javaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));phpProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName())); 我们同样使用forEach方法,增加程序员的工资5%:12345System.out.println(&quot;给程序员加薪 5% :&quot;);Consumer&lt;Person&gt; giveRaise = e -&gt; e.setSalary(e.getSalary() / 100 * 5 + e.getSalary());javaProgrammers.forEach(giveRaise);phpProgrammers.forEach(giveRaise); 另一个有用的方法是过滤器filter() ,让我们显示月薪超过1400美元的PHP程序员:1234System.out.println(&quot;下面是月薪超过 $1,400 的PHP程序员:&quot;)phpProgrammers.stream() .filter((p) -&gt; (p.getSalary() &gt; 1400)) .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName())); 我们也可以定义过滤器,然后重用它们来执行其他操作:123456789101112131415161718// 定义 filtersPredicate&lt;Person&gt; ageFilter = (p) -&gt; (p.getAge() &gt; 25);Predicate&lt;Person&gt; salaryFilter = (p) -&gt; (p.getSalary() &gt; 1400);Predicate&lt;Person&gt; genderFilter = (p) -&gt; (&quot;female&quot;.equals(p.getGender()));System.out.println(&quot;下面是年龄大于 24岁且月薪在$1,400以上的女PHP程序员:&quot;);phpProgrammers.stream() .filter(ageFilter) .filter(salaryFilter) .filter(genderFilter) .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));// 重用filtersSystem.out.println(&quot;年龄大于 24岁的女性 Java programmers:&quot;);javaProgrammers.stream() .filter(ageFilter) .filter(genderFilter) .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName())); 使用limit方法,可以限制结果集的个数:1234567891011System.out.println(&quot;最前面的3个 Java programmers:&quot;);javaProgrammers.stream() .limit(3) .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));System.out.println(&quot;最前面的3个女性 Java programmers:&quot;);javaProgrammers.stream() .filter(genderFilter) .limit(3) .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName())); 排序呢? 我们在stream中能处理吗? 答案是肯定的。 在下面的例子中,我们将根据名字和薪水排序Java程序员,放到一个list中,然后显示列表:12345678910111213141516System.out.println(&quot;根据 name 排序,并显示前5个 Java programmers:&quot;);List&lt;Person&gt; sortedJavaProgrammers = javaProgrammers .stream() .sorted((p, p2) -&gt; (p.getFirstName().compareTo(p2.getFirstName()))) .limit(5) .collect(toList());sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; %n&quot;, p.getFirstName(), p.getLastName())); System.out.println(&quot;根据 salary 排序 Java programmers:&quot;);sortedJavaProgrammers = javaProgrammers .stream() .sorted( (p, p2) -&gt; (p.getSalary() - p2.getSalary()) ) .collect( toList() );sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; %n&quot;, p.getFirstName(), p.getLastName())); 如果我们只对最低和最高的薪水感兴趣,比排序后选择第一个/最后一个 更快的是min和max方法:123456789101112131415System.out.println(&quot;工资最低的 Java programmer:&quot;);Person pers = javaProgrammers .stream() .min((p1, p2) -&gt; (p1.getSalary() - p2.getSalary())) .get()System.out.printf(&quot;Name: %s %s; Salary: $%,d.&quot;, pers.getFirstName(), pers.getLastName(), pers.getSalary())System.out.println(&quot;工资最高的 Java programmer:&quot;);Person person = javaProgrammers .stream() .max((p, p2) -&gt; (p.getSalary() - p2.getSalary())) .get()System.out.printf(&quot;Name: %s %s; Salary: $%,d.&quot;, person.getFirstName(), person.getLastName(), person.getSalary()) 上面的例子中我们已经看到 collect 方法是如何工作的。 结合 map 方法,我们可以使用 collect 方法来将我们的结果集放到一个字符串,一个 Set 或一个TreeSet中:1234567891011121314151617System.out.println(&quot;将 PHP programmers 的 first name 拼接成字符串:&quot;);String phpDevelopers = phpProgrammers .stream() .map(Person::getFirstName) .collect(joining(&quot; ; &quot;)); // 在进一步的操作中可以作为标记(token) System.out.println(&quot;将 Java programmers 的 first name 存放到 Set:&quot;);Set&lt;String&gt; javaDevFirstName = javaProgrammers .stream() .map(Person::getFirstName) .collect(toSet());System.out.println(&quot;将 Java programmers 的 first name 存放到 TreeSet:&quot;);TreeSet&lt;String&gt; javaDevLastName = javaProgrammers .stream() .map(Person::getLastName) .collect(toCollection(TreeSet::new)); Streams 还可以是并行的(parallel)。 示例如下:12345System.out.println(&quot;计算付给 Java programmers 的所有money:&quot;);int totalSalary = javaProgrammers .parallelStream() .mapToInt(p -&gt; p.getSalary()) .sum(); 我们可以使用summaryStatistics方法获得stream 中元素的各种汇总数据。 接下来,我们可以访问这些方法,比如getMax, getMin, getSum或getAverage:1234567891011//计算 count, min, max, sum, and average for numbersList&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);IntSummaryStatistics stats = numbers .stream() .mapToInt((x) -&gt; x) .summaryStatistics();System.out.println(&quot;List中最大的数字 : &quot; + stats.getMax());System.out.println(&quot;List中最小的数字 : &quot; + stats.getMin());System.out.println(&quot;所有数字的总和 : &quot; + stats.getSum());System.out.println(&quot;所有数字的平均值 : &quot; + stats.getAverage());","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"Java https请求 HttpsURLConnection","date":"2016-07-18T06:15:30.000Z","path":"2016/07/18/Java-https请求-HttpsURLConnection/","text":"有关tomcat 6.0如何配置https服务的文章可以参考：http://blog.csdn.net/zhou_zion/article/details/6759171以下主要讲解如何使用https发起post请求：参考文档：梁栋前辈的《Java加密与解密的艺术》123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import java.io.BufferedReader;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.net.MalformedURLException;import java.net.URL;import java.security.GeneralSecurityException;import java.security.KeyStore;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.KeyManagerFactory;import javax.net.ssl.SSLContext;import javax.net.ssl.TrustManagerFactory;public class HttpsPost &#123; /** * 获得KeyStore. * @param keyStorePath * 密钥库路径 * @param password * 密码 * @return 密钥库 * @throws Exception */ public static KeyStore getKeyStore(String password, String keyStorePath) throws Exception &#123; // 实例化密钥库 KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;); // 获得密钥库文件流 FileInputStream is = new FileInputStream(keyStorePath); // 加载密钥库 ks.load(is, password.toCharArray()); // 关闭密钥库文件流 is.close(); return ks; &#125; /** * 获得SSLSocketFactory. * @param password * 密码 * @param keyStorePath * 密钥库路径 * @param trustStorePath * 信任库路径 * @return SSLSocketFactory * @throws Exception */ public static SSLContext getSSLContext(String password, String keyStorePath, String trustStorePath) throws Exception &#123; // 实例化密钥库 KeyManagerFactory keyManagerFactory = KeyManagerFactory .getInstance(KeyManagerFactory.getDefaultAlgorithm()); // 获得密钥库 KeyStore keyStore = getKeyStore(password, keyStorePath); // 初始化密钥工厂 keyManagerFactory.init(keyStore, password.toCharArray()); // 实例化信任库 TrustManagerFactory trustManagerFactory = TrustManagerFactory .getInstance(TrustManagerFactory.getDefaultAlgorithm()); // 获得信任库 KeyStore trustStore = getKeyStore(password, trustStorePath); // 初始化信任库 trustManagerFactory.init(trustStore); // 实例化SSL上下文 SSLContext ctx = SSLContext.getInstance(&quot;TLS&quot;); // 初始化SSL上下文 ctx.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null); // 获得SSLSocketFactory return ctx; &#125; /** * 初始化HttpsURLConnection. * @param password * 密码 * @param keyStorePath * 密钥库路径 * @param trustStorePath * 信任库路径 * @throws Exception */ public static void initHttpsURLConnection(String password, String keyStorePath, String trustStorePath) throws Exception &#123; // 声明SSL上下文 SSLContext sslContext = null; // 实例化主机名验证接口 HostnameVerifier hnv = new MyHostnameVerifier(); try &#123; sslContext = getSSLContext(password, keyStorePath, trustStorePath); &#125; catch (GeneralSecurityException e) &#123; e.printStackTrace(); &#125; if (sslContext != null) &#123; HttpsURLConnection.setDefaultSSLSocketFactory(sslContext .getSocketFactory()); &#125; HttpsURLConnection.setDefaultHostnameVerifier(hnv); &#125; /** * 发送请求. * @param httpsUrl * 请求的地址 * @param xmlStr * 请求的数据 */ public static void post(String httpsUrl, String xmlStr) &#123; HttpsURLConnection urlCon = null; try &#123; urlCon = (HttpsURLConnection) (new URL(httpsUrl)).openConnection(); urlCon.setDoInput(true); urlCon.setDoOutput(true); urlCon.setRequestMethod(&quot;POST&quot;); urlCon.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(xmlStr.getBytes().length)); urlCon.setUseCaches(false); //设置为gbk可以解决服务器接收时读取的数据中文乱码问题 urlCon.getOutputStream().write(xmlStr.getBytes(&quot;gbk&quot;)); urlCon.getOutputStream().flush(); urlCon.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader( urlCon.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 测试方法. * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; // 密码 String password = &quot;123456&quot;; // 密钥库 String keyStorePath = &quot;tomcat.keystore&quot;; // 信任库 String trustStorePath = &quot;tomcat.keystore&quot;; // 本地起的https服务 String httpsUrl = &quot;https://localhost:8443/service/httpsPost&quot;; // 传输文本 String xmlStr = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;&lt;fruitShop&gt;&lt;fruits&gt;&lt;fruit&gt;&lt;kind&gt;萝卜&lt;/kind&gt;&lt;/fruit&gt;&lt;fruit&gt;&lt;kind&gt;菠萝&lt;/kind&gt;&lt;/fruit&gt;&lt;/fruits&gt;&lt;/fruitShop&gt;&quot;; HttpsPost.initHttpsURLConnection(password, keyStorePath, trustStorePath); // 发起请求 HttpsPost.post(httpsUrl, xmlStr); &#125;&#125; 1234567891011121314151617import javax.net.ssl.HostnameVerifier;import javax.net.ssl.SSLSession;/** * 实现用于主机名验证的基接口。 * 在握手期间，如果 URL 的主机名和服务器的标识主机名不匹配，则验证机制可以回调此接口的实现程序来确定是否应该允许此连接。 */public class MyHostnameVerifier implements HostnameVerifier &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; if(&quot;localhost&quot;.equals(hostname))&#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 接收请求的Web应用： web.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;rollBack&lt;/servlet-name&gt; &lt;servlet-class&gt;rollBack&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;rollBack&lt;/servlet-name&gt; &lt;url-pattern&gt;/httpsPost&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; rollBack servlet123456789101112131415161718192021222324252627282930import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class rollBack extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取请求流 ServletInputStream sis = request.getInputStream(); BufferedReader in = new BufferedReader(new InputStreamReader(sis)); String line; if((line = in.readLine()) != null)&#123; System.out.println(line); &#125; in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 使用apache的httpClient是一个最常用的开源的java第三方工具包需要httpclent.jar创建client的工具类1234567891011121314151617181920public static CloseableHttpClient createSSLClientDefault()&#123;try &#123; SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() &#123; //信任所有 public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; return true; &#125; &#125;).build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext); return HttpClients.custom().setSSLSocketFactory(sslsf).build(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; return HttpClients.createDefault();&#125; 12345678通过这个client访问https的url地址关键代码：//上面的工具类CloseableHttpClient httpClient = HttpClientUtil.createSSLClientDefault();HttpGet get = new HttpGet();get.setURI(new URI(&quot;你的https://地址&quot;));httpClient.execute(get）//...........后续操作 SSLContextBuilderAndroid Https请求的简单使用(Volley Https请求的示例)","tags":[{"name":"SSL，Https","slug":"SSL，Https","permalink":"http://samychen.com/tags/SSL，Https/"}]},{"title":"https加密过程","date":"2016-07-12T06:17:02.000Z","path":"2016/07/12/https加密过程/","text":"HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。 客户端发起HTTPS请求 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 2.务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 3.传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 4.客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 5.传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6.服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7.传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8.客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。","tags":[{"name":"SSL，Https","slug":"SSL，Https","permalink":"http://samychen.com/tags/SSL，Https/"}]},{"title":"http与https网络请求","date":"2016-07-08T06:17:02.000Z","path":"2016/07/08/http与https网络请求/","text":"HTTPS，即安全的超文本传输协议，采用了SSL技术，被广泛使用以保证Web应用系统的安全性。访问Web应用的编程接口大多封装了SSL，使得访问HTTPS和访问HTTP一样简单。 本文将在简要介绍JSSE的基础上，详细描述使用JSSE访问HTTPS的方法，主要说明了如何访问带有未经验证证书的HTTPS站点。Java安全套接扩展 (Java Secure Socket Extension, JSSE)是实现Internet安全通信的一系列包的集合。它是一个SSL和TLS的纯Java实现，可以透明地提供数据加密、服务器认证、信息完整性等功能，可以使我们像使用普通的套接字一样使用JSSE建立的安全套接字。JSSE是一个开放的标准，不只是Sun公司才能实现一个JSSE，事实上其他公司有自己实现的JSSE。在深入了解JSSE之前，需要了解一个有关Java安全的概念：客户端的TrustStore文件。客户端的TrustStore文件中保存着被客户端所信任的服务器的证书信息。客户端在进行SSL连接时，JSSE将根据这个文件中的证书决定是否信任服务器端的证书。 JSSE中，有一个信任管理器类负责决定是否信任远端的证书，这个类有如下的处理规则： 1 ) 如果系统属性javax.net.sll.trustStore指定了TrustStore文件，那么信任管理器就去jre安装路径下的lib/security/目录中寻找并使用这个文件来检查证书。2 ) 如果该系统属性没有指定TrustStore文件，它就会去jre安装路径下寻找默认的TrustStore文件，这个文件的相对路径为：lib/security/jssecacerts。3 ) 如果 jssecacerts不存在，但是cacerts存在(它随J2SDK一起发行，含有数量有限的可信任的基本证书)，那么这个默认的TrustStore文件就是cacerts。 直接使用类HttpsURLConnection访问Web页面Java提供了一种非常简洁的方法来访问HTTPS网页，即使用类HttpsURLConnection、URL等。这几个类为支持HTTPS对JSSE相关类做了进一步的封装，例子如下所示：1234567891011121314151617181920URL reqURL = new URL(&quot;https://www.sun.com&quot; ); //创建URL对象HttpsURLConnection httpsConn = (HttpsURLConnection)reqURL.openConnection();/*下面这段代码实现向Web页面发送数据，实现与网页的交互访问httpsConn.setDoOutput(true); OutputStreamWriter out = new OutputStreamWriter(huc.getOutputStream(), &quot;8859_1&quot;); out.write( &quot;……&quot; ); out.flush(); out.close();*///取得该连接的输入流，以读取响应内容 InputStreamReader insr = new InputStreamReader(httpsConn.getInputStream();//读取服务器的响应内容并显示int respInt = insr.read();while( respInt != -1)&#123; System.out.print((char)respInt); respInt = insr.read();&#125; 这段代码能够正常执行，然而把访问的URL改为https://login.bjut.edu.cn 时，程序将抛出异常javax.net.ssl.SSLException，这是由于https://login.bjut.edu.cn 站点的安全证书不被JSSE所信任。根据JSSE简介中对信任管理器的分析，一种解决这个问题的方法是按照信任管理器的处理规则，把站点的证书放到证书库文件jssecacerts中，或者把证书存放到任一TrustStore文件中，然后设置系统属性javax.net.sll.trustStore指向该文件。另一种解决方法则是自己实现信任管理器类，让它信任我们指定的证书。下面分别介绍这两种方法。 将证书导入到TrustStore文件中 Java提供了命令行工具keytool用于创建证书或者把证书从其它文件中导入到Java自己的TrustStore文件中。把证书从其它文件导入到TrustStore文件中的命令行格式为：keytool -import -file src_cer_file –keystore dest_cer_store其中，src_cer_file为存有证书信息的源文件名，dest_cer_store为目标TrustStore文件。 在使用keytool之前，首先要取得源证书文件，这个源文件可使用IE浏览器获得，IE浏览器会把访问过的HTTPS站点的证书保存到本地。从IE浏览器导出证书的方法是打开“Internet 选项”，选择“内容”选项卡，点击“证书…”按钮，在打开的证书对话框中，选中一个证书，然后点击“导出…”按钮，按提示一步步将该证书保存到一文件中。最后就可利用keytool把该证书导入到Java的TrustStore文件中。为了能使Java程序找到该文件，应该把这个文件复制到jre安装路径下的lib/security/目录中。 这样，只需在程序中设置系统属性javax.net.sll.trustStore指向文件dest_cer_store，就能使JSSE信任该证书，从而使程序可以访问使用未经验证的证书的HTTPS站点。 使用这种方法，编程非常简单，但需要手工导出服务器的证书。当服务器证书经常变化时，就需要经常进行手工导出证书的操作。下面介绍的实现X509证书信任管理器类的方法将避免手工导出证书的问题。 X509证书信任管理器类的实现及应用 在JSSE中，证书信任管理器类就是实现了接口X509TrustManager的类。我们可以自己实现该接口，让它信任我们指定的证书。 接口X509TrustManager有下述三个公有的方法需要我们实现： ⑴ void checkClientTrusted(X509Certificate[] chain, String authType)throws CertificateException 该方法检查客户端的证书，若不信任该证书则抛出异常。由于我们不需要对客户端进行认证，因此我们只需要执行默认的信任管理器的这个方法。JSSE中，默认的信任管理器类为TrustManager。⑵void checkServerTrusted(X509Certificate[] chain, String authType)throws CertificateException 该方法检查服务器的证书，若不信任该证书同样抛出异常。通过自己实现该方法，可以使之信任我们指定的任何证书。在实现该方法时，也可以简单的不做任何处理，即一个空的函数体，由于不会抛出异常，它就会信任任何证书。 ⑶ X509Certificate[] getAcceptedIssuers()返回受信任的X509证书数组。 自己实现了信任管理器类，如何使用呢？类HttpsURLConnection似乎并没有提供方法设置信任管理器。其实，HttpsURLConnection通过SSLSocket来建立与HTTPS的安全连接，SSLSocket对象是由SSLSocketFactory生成的。HttpsURLConnection提供了方法setSSLSocketFactory(SSLSocketFactory)设置它使用的SSLSocketFactory对象。SSLSocketFactory通过SSLContext对象来获得，在初始化SSLContext对象时，可指定信任管理器对象。下面用一个图简单表示这几个JSSE类的关系：假设自己实现的X509TrustManager类的类名为：MyX509TrustManager，下面的代码片断说明了如何使用MyX509TrustManager：1234567891011//创建SSLContext对象，并使用我们指定的信任管理器初始化TrustManager[] tm = &#123;new MyX509TrustManager ()&#125;; SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;,&quot;SunJSSE&quot;); sslContext.init(null, tm, new java.security.SecureRandom()); //从上述SSLContext对象中得到SSLSocketFactory对象SSLSocketFactory ssf = sslContext.getSocketFactory();//创建HttpsURLConnection对象，并设置其SSLSocketFactory对象HttpsURLConnection httpsConn = (HttpsURLConnection)myURL.openConnection();httpsConn.setSSLSocketFactory(ssf); 这样，HttpsURLConnection对象就可以正常连接HTTPS了，无论其证书是否经权威机构的验证，只要实现了接口X509TrustManager的类MyX509TrustManager信任该证书。 小结 本文主要介绍了在HTTPS的证书未经权威机构认证的情况下，访问HTTPS站点的两种方法，一种方法是把该证书导入到Java的TrustStore文件中，另一种是自己实现并覆盖JSSE缺省的证书信任管理器类。两种方法各有优缺点，第一种方法不会影响JSSE的安全性，但需要手工导入证书；第二种方法虽然不用手工导入证书，但需要小心使用，否则会带来一些安全隐患。","tags":[{"name":"SSL，Https","slug":"SSL，Https","permalink":"http://samychen.com/tags/SSL，Https/"}]},{"title":"SSL+socket 详解-概念","date":"2016-07-02T06:11:30.000Z","path":"2016/07/02/SSL-socket-详解-概念/","text":"一、SSL概述SSL协议采用数字证书及数字签名进行双端实体认证，用非对称加密算法进行密钥协商，用对称加密算法将数据加密后进行传输以保证数据的保密性，并且通过计算数字摘要来验证数据在传输过程中是否被篡改和伪造，从而为敏感数据的传输提供了一种安全保障手段。 SSL协议提供的服务主要有：1）认证用户和服务器，确保数据发送到正确的客户机和服务器认证用户和服务器的合法性，使它们能够确信数据将被发送到正确的客户机和服务器上。客户机和服务器都有各自的识别号，这些识别号由公开密钥进行编号，为验证用户是否合法，SSL协议要求在握手交换数据时进行数字认证，以此确保用户的合法性。2）加密数据以防止数据中途被窃取SSL协议所采用的加密技术既有对称密钥技术，也有公开密钥技术。在客户机和服务器进行数据交换前，交换SSL初始握手信息，在SSL握手信息中采用了各种加密技术对其进行加密，以保证其机密性和数据的完整性，并且用数字证书进行鉴别，这样就可以防止非法用户进行破译。3）维护数据的完整性，确保数据在传输过程中不被改变SSL协议采用Hash函数和机密共享的方法提供信息的完整性服务，建立客户机和服务器之间的安全通道，使所有经过SSL协议处理的业务在传输过程中能全部完整准确无误的到达目的地。 SSL体系结构：SSL协议位于TCP/IP协议模型的网络层和应用层之间,使用TCP来提供一种可靠的端到端的安全服务,它是客户/服务器应用之间的通信不被攻击抓取,并且始终对服务器进行认证,还可以选择对客户进行认证。SSL体系结构如图1所示。 二、SSL体系结构：SSL协议位于TCP/IP协议模型的网络层和应用层之间,使用TCP来提供一种可靠的端到端的安全服务,它是客户/服务器应用之间的通信不被攻击抓取,并且始终对服务器进行认证,还可以选择对客户进行认证。在SSL通讯中，首先采用非对称加密交换信息，使得服务器获得浏览器端提供的对称加密的密钥，然后利用该密钥进行通讯过程中信息的加密和解密。为了保证消息在传递过程中没有被篡改，可以加密HASH编码来确保信息的完整性。SSL通讯过程，如图2所示。一般情况下，当客户端是保密信息的传递者时，客户端不需要数字证书验证自己身份的真实性，如电子银行的应用，客户需要将自己的账号和密码发送给银行，因此银行的服务器需要安装数字证书来表明自己身份的有效性。在某些应用中，服务器端也需要对客户端的身份进行验证，这时客户端也需要安装数字证书以保证通讯时服务器可以辨别出客户端的身份，验证过程类似于服务器身份的验证过程。 三、SSL Socket双向认证的实现SSL Socket通信是对Socket通信的拓展。在Socket通信的基础上添加了一层安全性保护，提供了更高的安全性，包括身份验证、数据加密以及完整性验证。SSL Socket双向认证实现技术： JSSE（Java Security Socket Extension），它实现了SSL和TSL（传输层安全）协议。在JSSE中包含了数据加密，服务器验证，消息完整性和客户端验证等技术。通过使用JSSE，可以在客户机和服务器之间通过TCP/IP协议安全地传输数据。为了实现消息认证： 服务器端需要：1、KeyStore： 其中保存服务器端的私钥 2、Trust KeyStore： 其中保存客户端的授权证书 客户端需要：1、KeyStore：其中保存客户端的私钥 2、Trust KeyStore：其中保存服务端的授权证书 密钥和授权证书的生成方法：使用Java自带的keytool命令，在命令行生成。1、生成服务器端私钥kserver.keystore文件 keytool -genkey -alias serverkey -validity 1 -keystore kserver.keystore2、根据私钥，导出服务器端安全证书keytool -export -alias serverkey -keystore kserver.keystore -file server.crt3、将服务器端证书，导入到客户端的Trust KeyStore中keytool -import -alias serverkey -file server.crt -keystore tclient.keystore4、生成客户端私钥kclient.keystore文件 keytool -genkey -alias clientkey -validity 1 -keystore kclient.keystore5、根据私钥，导出客户端安全证书keytool -export -alias clientkey -keystore kclient.keystore -file client.crt6、将客户端证书，导入到服务器端的Trust KeyStore中keytool -import -alias clientkey -file client.crt -keystore tserver.keystore 生成的文件分成两组，服务器端保存：kserver.keystore tserver.keystore 客户端保存：kclient.keystore tclient.kyestore。 客户端采用kclient.keystore中的私钥进行数据加密，发送给服务端，服务器端采用tserver.keystore中的client.crt证书对数据解密，如果解密成功，证明消息来自可信的客户端，进行逻辑处理； 服务器端采用kserver.keystore中的私钥进行数据加密，发送给客户端，客户端采用tclient.keystore中的server.crt证书对数据解密，如果解密成功，证明消息来自可信的服务器端，进行逻辑处理。如果解密失败，那么证明消息来源错误。不进行逻辑处理。 SSL Socket双向认证的安全性：（1）可以确保数据传送到正确的服务器端和客户端。（2）可以防止消息传递过程中被窃取。（3）防止消息在传递过程中被修改.。 在系统运行中可能出现以下情况：（1） 服务器端、客户端都持有正确的密钥和安全证书，此时服务器端和客户端可以进行正常通信。（2） 客户端的密钥和安全证书不正确，此时服务器端和客户端不可以进行正常通信。（3） 客户端未持有密钥和安全证书，此时服务器端和客户端也不可以进行正常通信。","tags":[{"name":"SSL","slug":"SSL","permalink":"http://samychen.com/tags/SSL/"}]},{"title":"Android 使用 HTTPS","date":"2016-07-01T06:13:23.000Z","path":"2016/07/01/Android-使用-HTTPS/","text":"如果你的项目的网络框架是okhttp，那么使用https还是挺简单的，因为okhttp默认支持HTTPS。传送门Android 使用 HTTPS 配置的步骤。1.step 配置hostnameVerifier12345new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;； 2.step配置 sslSocketFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public static SSLSocketFactory getSslSocketFactory(InputStream[] certificates, InputStream bksFile, String password)&#123; try&#123; TrustManager[] trustManagers = prepareTrustManager(certificates); KeyManager[] keyManagers = prepareKeyManager(bksFile, password); SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); TrustManager trustManager = null; if (trustManagers != null)&#123; trustManager = new MyTrustManager(chooseTrustManager(trustManagers)); &#125; else&#123; trustManager = new UnSafeTrustManager(); &#125; sslContext.init(keyManagers, new TrustManager[]&#123;trustManager&#125;, new SecureRandom()); return sslContext.getSocketFactory(); &#125; catch (NoSuchAlgorithmException e)&#123; throw new AssertionError(e); &#125; catch (KeyManagementException e)&#123; throw new AssertionError(e); &#125; catch (KeyStoreException e)&#123; throw new AssertionError(e); &#125; &#125; private class UnSafeHostnameVerifier implements HostnameVerifier&#123; @Override public boolean verify(String hostname, SSLSession session)&#123; return true; &#125; &#125; private static class UnSafeTrustManager implements X509TrustManager&#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType)throws CertificateException&#123;&#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType)throws CertificateException&#123;&#125; @Override public X509Certificate[] getAcceptedIssuers()&#123; return new X509Certificate[]&#123;&#125;; &#125; &#125; private static TrustManager[] prepareTrustManager(InputStream... certificates)&#123; if (certificates == null || certificates.length &lt;= 0) return null; try&#123; CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null); int index = 0; for (InputStream certificate : certificates)&#123; String certificateAlias = Integer.toString(index++); keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate)); try&#123; if (certificate != null) certificate.close(); &#125; catch (IOException e)&#123; &#125; &#125; TrustManagerFactory trustManagerFactory = null; trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); return trustManagers; &#125; catch (NoSuchAlgorithmException e)&#123; e.printStackTrace(); &#125; catch (CertificateException e)&#123; e.printStackTrace(); &#125; catch (KeyStoreException e)&#123; e.printStackTrace(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; private static KeyManager[] prepareKeyManager(InputStream bksFile, String password)&#123; try&#123; if (bksFile == null || password == null) return null; KeyStore clientKeyStore = KeyStore.getInstance(&quot;BKS&quot;); clientKeyStore.load(bksFile, password.toCharArray()); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(clientKeyStore, password.toCharArray()); return keyManagerFactory.getKeyManagers(); &#125; catch (KeyStoreException e)&#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e)&#123; e.printStackTrace(); &#125; catch (UnrecoverableKeyException e)&#123; e.printStackTrace(); &#125; catch (CertificateException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; private static X509TrustManager chooseTrustManager(TrustManager[] trustManagers)&#123; for (TrustManager trustManager : trustManagers)&#123; if (trustManager instanceof X509TrustManager)&#123; return (X509TrustManager) trustManager; &#125; &#125; return null; &#125; private static class MyTrustManager implements X509TrustManager&#123; private X509TrustManager defaultTrustManager; private X509TrustManager localTrustManager; public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException&#123; TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); var4.init((KeyStore) null); defaultTrustManager = chooseTrustManager(var4.getTrustManagers()); this.localTrustManager = localTrustManager; &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException&#123;&#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException&#123; try&#123; defaultTrustManager.checkServerTrusted(chain, authType); &#125; catch (CertificateException ce)&#123; localTrustManager.checkServerTrusted(chain, authType); &#125; &#125; @Override public X509Certificate[] getAcceptedIssuers()&#123; return new X509Certificate[0];//当使用证书链时，第一个证书总是发送者的 &#125; &#125; Android的私钥和信任证书的格式必须是BKS格式的，通过配置本地JDK，让keytool可以生成BKS格式的私钥和信任证书,java本身没有BouncyCastle密库调用 getSslSocketFactory(null,null,null) 即可。3.step设置OkhttpClient。 方法 getSslSocketFactory(null,null,null) 的第一个参数 本来要传入自签名证书的，当传入null 即可忽略自签名证书。如果你想尝试不忽略自签名证书 你可以调用下面的方法获取 SSLSocketFactory。并设置到OkhttpClient中。123456789101112131415161718192021222324252627282930313233343536373839404142434445public static SSLSocketFactory getSSlFactory(Context context) &#123; try &#123; CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); InputStream caInput = new BufferedInputStream(context.getAssets().open(&quot;client.cer&quot;));//把证书打包在asset文件夹中 Certificate ca; try &#123; ca = cf.generateCertificate(caInput); LogUtil.d(&quot;Longer&quot;, &quot;ca=&quot; + ((X509Certificate) ca).getSubjectDN()); LogUtil.d(&quot;Longer&quot;, &quot;key=&quot; + ((X509Certificate) ca).getPublicKey()); &#125; finally &#123; caInput.close(); &#125; // Create a KeyStore containing our trusted CAs String keyStoreType = KeyStore.getDefaultType(); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, ca); // Create a TrustManager that trusts the CAs in our KeyStore String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); // Create an SSLContext that uses our TrustManager SSLContext s = SSLContext.getInstance(&quot;TLSv1&quot;, &quot;AndroidOpenSSL&quot;); s.init(null, tmf.getTrustManagers(), null); return s.getSocketFactory(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (NoSuchProviderException e) &#123; e.printStackTrace(); &#125; return null; &#125; 通过上面的几步配置即可使用https的自签名证书 和 单向验证的Https了。Glide 访问Https的图片1.step在build.gradle 引入下面的aar /提供的Module/compile ‘com.github.bumptech.glide:okhttp3-integration:1.4.0@aar’ 2.step123456789101112131415OkHttpClient okhttpClient = new OkHttpClient.Builder() .connectTimeout(30, TimeUnit.SECONDS) .retryOnConnectionFailure(true) //设置出现错误进行重新连接。 .connectTimeout(15, TimeUnit.SECONDS) .readTimeout(60 * 1000, TimeUnit.MILLISECONDS) .sslSocketFactory(HttpsUtils.getSslSocketFactory(null,null,null)) .hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;) .build(); //让Glide能用HTTPS Glide.get(this).register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(okhttpClient)); 设置已经验证证书的的OkhttpClient 到Glide 既可。google开发https参考 SSLContext 初始化public final void init(KeyManager[] km,TrustManager[] tm,SecureRandom random) throws KeyManagementException 初始化此上下文。前两个参数都可以为 null，在这种情况下将搜索装入的安全提供者来寻找适当工厂的最高优先级实现。同样，安全的 random 参数也可以为 null，在这种情况下将使用默认的实现。只有数组中的第一个特定密钥和/或信任管理器实现类型的实例被使用。（例如，只有数组中的第一个 javax.net.ssl.X509KeyManager 被使用。） 参数：km 验证密钥源或 nulltm 同位体验证信任决策源或 nullrandom 此生成器的随机源或 null抛出：KeyManagementExceptionjava SSLSocket","tags":[{"name":"SSL，Https，安卓","slug":"SSL，Https，安卓","permalink":"http://samychen.com/tags/SSL，Https，安卓/"}]},{"title":"App启动优化","date":"2016-06-07T08:09:54.000Z","path":"2016/06/07/App启动优化/","text":"对于Android平台上的线程优先级设置来说可以处理很多并发线程的阻塞问题，比如很多无关紧要的线程会占用大量的CPU时间，虽然通过了MultiThread来解决慢速I/O但是合理分配优先级对于并发编程来说十分重要。Android在线程方面主要使用的是Java本身的Thread类，我们可以在Thread或Runnable接口中的run方法首句加入Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //设置线程优先级为后台，这样当多个线程并发后很多无关紧要的线程分配的CPU时间将会减少，有利于主线程的处理 现场优先级： int THREAD_PRIORITY_AUDIO //标准音乐播放使用的线程优先级 int THREAD_PRIORITY_BACKGROUND //标准后台程序 int THREAD_PRIORITY_DEFAULT // 默认应用的优先级 int THREAD_PRIORITY_DISPLAY //标准显示系统优先级，主要是改善UI的刷新 int THREAD_PRIORITY_FOREGROUND //标准前台线程优先级 int THREAD_PRIORITY_LESS_FAVORABLE //低于favorable int THREAD_PRIORITY_LOWEST //有效的线程最低的优先级 int THREAD_PRIORITY_MORE_FAVORABLE //高于favorable int THREAD_PRIORITY_URGENT_AUDIO //标准较重要音频播放优先级 int THREAD_PRIORITY_URGENT_DISPLAY //标准较重要显示优先级，对于输入事件同样适用。 一、工具：adb 或Python adb计算app启动时间 adb shell am start -w packagename/activity 三个返回结果ThisTime，TotalTime，WaitTime WaitTime就是app启动时间：WaitTime=startTime-endTime startTime：记录的刚准备调用startActivityAndWait()的时间点 endTime：记录的是startActivityAndWait()函数调用返回的时间点 ThisTime、TotalTime 的计算在 frameworks\\base\\services\\core\\java\\com\\android\\server\\am\\ActivityRecord.java 文件的 reportLaunchTimeLocked() 函数中。 curTime表示该函数调用的时间点. displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点. mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点. displayStartTime和mLaunchStartTime的区别：分两种情况 正常情况下点击桌面图标只启动一个有界面的 Activity，此时 displayStartTime 与mLaunchStartTime 便指向同一时间点，此时 ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的 Activity 做逻辑处理(如占位界面)，接着又启动一个有界面的Activity，在这种启动一连串 Activity 的情况下（知乎的启动就是属于这种情况），displayStartTime 便指向最后一个 Activity 的开始启动时间点，mLaunchStartTime 指向第一个无界面Activity的开始启动时间点，此时 ThisTime！=TotalTime。这两种情况如下图： 如果只关心某个应用自身启动耗时，参考TotalTime；如果关心系统启动应用耗时，参考WaitTime；如果关心应用有界面Activity启动耗时，参考ThisTime。 二、热启动 如果是你按Back键，并没有将应用进程杀掉的话，那么执行上述命令就会快一些，因为不用创建进程了，只需要启动一个Activity即可。这也就是我们说的应用热启动。 游戏启动的话，就不适用用命令行的方法来启动了，因为从用户点击桌面图标到登录界面，既有系统的部分也有游戏自己的部分。 系统部分：游戏也有一个 Activity，所以启动的时候还是会去启动这个 Activity，所以系统启动部分也就是用户点击桌面桌面响应到这个Activity启动。 游戏部分：一般游戏的主 Activity 启动后，还会做一些比较耗时的事情，这时候你看到的界面是不能操作的，比如：加载游戏数据、联网更新数据、读取和更新配置文件、游戏引擎初始化等操作。从游戏开发的角度来看，到了真正用户能操作的界面才算是一个游戏真正加载完成的时间。 那么这个时间，就得使用 Log 来记录了，因为加载游戏数据、联网更新数据、读取和更新配置文件、游戏引擎初始化这些操作，都是游戏自己的逻辑，与系统无关，所以得由游戏自己定义加载完成的点。 对于游戏的启动时间，我们更倾向于计算从点击桌面图标到用户可以与游戏进行交互这个时间段作为一个游戏的启动时间 三、冷启动 应用不在后台时第一次启动，系统和App本身都有更多的工作要从头开始！、 应用在冷启动之前，要执行三个任务： 加载启动App； App启动之后立即展示出一个空白的Window； 创建App的进程； 而这三个任务执行完毕之后会马上执行以下任务： 创建App对象； 启动Main Thread； 创建启动的Activity对象； 加载View； 布置屏幕； 进行第一次绘制； 而一旦App进程完成了第一次绘制，系统进程就会用Main Activity替换已经展示的Background Window，此时用户就可以使用App了。 作为普通应用，App进程的创建等环节我们是无法主动控制的，可以优化的也就是Application、Activity创建以及回调等过程。 同样，Google也给出了启动加速的方向： 利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验； 避免在启动时做密集沉重的初始化（Heavy app initialization）； 定位问题：避免I/O操作、反序列化、网络操作、布局嵌套等。 备注：方向1属于治标不治本，只是表面上快；方向2、3可以真实的加快启动速度。 接下来我们就在项目中实际应用。 gold.xitu.io/post/5874bff0128fe1006b443fa0","tags":[{"name":"安卓","slug":"安卓","permalink":"http://samychen.com/tags/安卓/"}]},{"title":"一个可以进页面自动显示刷新效果的SwipeRefreshLayout","date":"2016-05-12T06:08:57.000Z","path":"2016/05/12/一个可以进页面自动显示刷新效果的SwipeRefreshLayout/","text":"SwipeRefreshLayout出来已经有一段时间了，先后换过两种刷新效果，都在V4包下面，新的刷新效果还是很赞的，很多app都采用了这种刷新效果，我最近也在往这边靠，在研究的时候发现，原始的SwipeRefreshLayout只支持手势下拉才能出现刷新效果，看到《简书》安卓客户端每次都有那种切换页面就自动出来刷新效果，自己也试了下，直接设置setRefreshing(true)这个方法是不能看到效果的，于是对源码进行了改造，不说多了，直接上代码12345678910111213141516171819202122232425262728public class AutoSwipeRefreshLayout extends SwipeRefreshLayout &#123; public AutoSwipeRefreshLayout(Context context) &#123; super(context); &#125; public AutoSwipeRefreshLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; /** * 自动刷新 */ public void autoRefresh() &#123; try &#123; Field mCircleView = SwipeRefreshLayout.class.getDeclaredField(mCircleView); mCircleView.setAccessible(true); View progress = (View) mCircleView.get(this); progress.setVisibility(VISIBLE); Method setRefreshing = SwipeRefreshLayout.class.getDeclaredMethod(setRefreshing, boolean.class, boolean.class); setRefreshing.setAccessible(true); setRefreshing.invoke(this, true, true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码看起来比较简单，确实花了不少功夫去阅读源码，除了添加了一个可以自动刷新的方法，没有修改其他的，用法也是和普通SwipeRefreshLayout一样，只不过可以在第一次加载数据的时候调用autoRefresh（）就可以看到刷新效果了，看效果图：","tags":[{"name":"安卓","slug":"安卓","permalink":"http://samychen.com/tags/安卓/"}]},{"title":"android之View坐标系（view获取自身坐标的方法和点击事件中坐标的获取）","date":"2016-05-11T06:06:15.000Z","path":"2016/05/11/android之View坐标系（view获取自身坐标的方法和点击事件中坐标的获取）/","text":"在做一个view背景特效的时候被坐标的各个获取方法搞晕了，几篇抄来抄去的博客也没弄很清楚。 现在把整个总结一下。 其实只要把下面这张图看明白就没问题了。涉及到的方法一共有下面几个：view获取自身坐标：getLeft(),getTop(),getRight(),getBottom()view获取自身宽高：getHeight(),getWidth()motionEvent获取坐标：getX(),getY(),getRawX(),getRawY()首先是view的几个方法，获取自身的宽高的这两个方法很清楚，不用多说，获取坐标的这几个就有点混乱了。根据上面的图应该会比较容易明白，图中屏幕上放了一个ViewGroup布局，里面有个View控件getTop：获取到的，是view自身的顶边到其父布局顶边的距离getLeft：获取到的，是view自身的左边到其父布局左边的距离getRight：获取到的，是view自身的右边到其父布局左边的距离getBottom：获取到的，是view自身的底边到其父布局顶边的距离 这些方法获取到的数据可以用在什么地方呢？比如要实现一个自定义的特殊布局，像http://blog.csdn.net/singwhatiwanna/article/details/42614953这里要实现的是一个水波纹特效布局，该布局内的任何控件点击后都会出现波纹效果那么在点击了布局内的一个控件之后，就要通过不断刷新布局，去更新这个控件上面的波纹半径，为了节省资源，每次刷新布局都时候不会整个布局都刷新，而只是通过postInvalidateDelayed(INVALIDATE_DURATION, left, top, right, bottom); 在布局的画布上每次只去更新点击事件所点击的对应的控件的位置，那么这里就可以用view的那四个方法，分别获取自身的四条边对应的坐标从而让布局去刷新重绘。 当然博客中是使用绝对坐标去计算的，因为这里实现的是一个布局，可能里面还会嵌套另外的布局，经过多次嵌套之后所获取到的值，是相对于控件直接对应的父布局（这个布局有可能已经是我们重写的布局的子布局了）的距离，这样去刷新的区域肯定是不准确的，所以博客里面使用相对屏幕的绝对坐标计算需要刷新的控件区域。 如果这里自定义的不是布局，而只是一个控件的话，就可以通过以上方法获取到坐标，然后要求自己所在的布局去重绘这一区域就可以了。当然这只是一种思路，其实没必要去要求布局重绘，完全可以直接view自身重绘就可以了。 然后是motionEvent的方法： getX()：获取点击事件相对控件左边的x轴坐标，即点击事件距离控件左边的距离 getY()：获取点击事件相对控件顶边的y轴坐标，即点击事件距离控件顶边的距离 getRawX()：获取点击事件相对整个屏幕左边的x轴坐标，即点击事件距离整个屏幕左边的距离 getRawY()：获取点击事件相对整个屏幕顶边的y轴坐标，即点击事件距离整个屏幕顶边的距离 这些方法可以用在什么地方呢？ getRawX和getRawY在之前那篇博客里广泛使用了，可以去那里看用法，getX()和getY()这两个方法在对view进行自定义的时候可能用的会比较多。 ###MotionEvent中getRawX、getRawY与getX、getY以及View中的getScrollX、getScrollY 1.getRawX、getRawY与getX、getY的区别在编写android的自定义控件，或者判断用户手势操作时，往往需要使用MotionEvent中的getRawX()、getRawY()与getX()、getY()取得触摸点在X轴与Y轴上的距离，这四个方法都返回一个float类型的参数，单位为像素（Pixel）。getRawX()、getRawY()返回的是触摸点相对于屏幕的位置，而getX()、getY()返回的则是触摸点相对于View的位置。以下两张图直观的表现了这几个方法的区别，在屏幕中央放置了一个Button，并为它注册了OnTouchListener，图中绿圆点为触摸点位置。 2.View中的getScrollX、getScrollYgetScrollX()与getScrollY()的值由调用View的scrollTo(int x, int y)或者scrollBy(int x, int y)产生，其中scrollTo是将View中的内容移动到指定的坐标x、y处，此x、y是相对于View的左上角，而不是屏幕的左上角。scrollBy(int x, int y)则是改变View中的相对位置，参数x、y为距离上一次的相对位置。文字解释总是不好理解的，那么我们就直接上图吧，直观一些。 （图1） （图2） （图3）1.图1中，屏幕中心放置了一个button，而button的内容被放置在了它的左上角。2.调用button的scrollTo(-100, -100)方法，结果如图2所示，button内的内容被移至相对button左上角(-100，-100)的位置3.对图2的button调用scrollBy(-100,-100)方法，结果如图3所示，button内的内容被移至相对于图2的(-100,-100)位置这时的getScrollX()与getScrollY()的值为： 06-15 15:44:56.072 20471-20471/com.test.yangy.studiotest V/ScrollActivity﹕ btn scroll X=-20006-15 15:44:56.072 20471-20471/com.test.yangy.studiotest V/ScrollActivity﹕ btn scroll Y=-200 值得注意的是，当View中的内容向右移动时，getScrollX()的值为负数，同理，向scrollTo与scrollBy的x中传入负数，view中的内容向右移动，反之向左。当View中的内容向下移动时，getScrollY()的值为负数，同理，向scrollTo与scrollBy的y中传入负数，view中的内容向下移动，反之向上。","tags":[{"name":"安卓","slug":"安卓","permalink":"http://samychen.com/tags/安卓/"}]},{"title":"Java8新特性之lambda表达式入门","date":"2016-05-02T05:41:42.000Z","path":"2016/05/02/Java8新特性之lambda表达式入门/","text":"功能接口 只包含一个方法的接口被称为功能接口，Lambda 表达式用用于任何功能接口适用的地方，java.awt.event.ActionListener 就是一个功能接口，因为它只有一个方法： void actionPerformed(ActionEvent) 一、lambda引入原因 1、更加紧凑的代码 比如Java中现有的匿名内部类以及监听器(listeners)和事件处理器(handlers）都显得很冗长 2、修改方法的能力 比如Collection接口的contains方法，当且仅当传入的元素真正包含在集合中，才返回true。而假如我们想对一个字符串集合，传入一个字符串，只要这个字符串出现在集合中（忽略大小写）就返回true。 简单地说，我们想要的是传入“一些我们自己的代码”到已有的方法中，已有的方法将会执行我们传入的代码。Lambda表达式能很好地支持这点 3、更好地支持多核处理 例如，通过Java 8新增的Lambda表达式，我们可以很方便地并行操作大集合，充分发挥多核CPU的潜能。 并行处理函数如filter、map和reduce。 实例1 FileFilter12345678910File dir =newFile(&quot;/an/dir/&quot;);FileFilter directoryFilter=newFileFilter() &#123;public boolean accept(File file) &#123;returnfile.isDirectory();&#125;&#125;; 通过Lambda表达式这段代码可以简化为如下：123456File dir =newFile(&quot;/an/dir/&quot;);FileFilter directoryFilter= (File f) -&gt;f.isDirectory();File[] dirs= dir.listFiles(directoryFilter); 进一步简化：1234File dir =newFile(&quot;/an/dir/&quot;)；File[] dirs= dir.listFiles((File f) -&gt; f.isDirectory()); Lambda表达式利用了类型推断（type inference）技术： 编译器知道FileFilter只有一个方法accept()，所以accept()方法肯定对应(File f) -&gt; f.isDirectory()，就是利用了类型推断，而且accept()方法只有一个File类型的参数，所以(File f) -&gt;f.isDirectory()中的File f就是这个参数了，.NET把类型推断做得更绝，如果上面用.NET Lambda表达式写法的话是这样的：File[] dirs= dir.ListFiles(f =&gt;f.isDirectory());即压根就不需要出现File类型指示。 实例2 Event Handler12345678910Button bt =newButton();bt.addActionListener(newActionListener() &#123;public void actionPerformed(ActionEvent e) &#123;ui.showSomething();&#125;&#125;); 使用Lambda表达式后：123456Button bt =newButton();ActionListener listener= event -&gt;&#123; ui.showSomething(); &#125;;bt.addActionListener(listener); 进一步简化：1234Button bt =newButton();bt.addActionListener(event-&gt; &#123; ui.showSomething(); &#125;); newActionListener的内部类只有actionPerformed方法，event就是参数 actionPerformed()方法的返回类型是void，所以需要特殊处理，即在ui.showSomething();左右加上花括号。（想象下不加会怎么样？如果不加的话，若showSomething()方法返回值是整数类型，那么就意味着actionPerformed()返回整数类型，显然不是，所以必须加花括号用来标记）。 如果Lambda表达式主体部分包含多条语句，也必须用花括号，并且return语句不能省。 比如下面这个：123456789101112File dir =newFile(&quot;/an/dir/&quot;);File[] dirs= dir.listFiles((File f) -&gt;&#123;System.out.println(&quot;Log:...&quot;);return f.isDirectory();&#125;); 函数集合 Java 8 的类库包含一个新的包 java.util.functions ，这个包中有很多新的功能接口，这些接口可与集合 API 一起使用。 外循环、内循环和Map、Reduce、Filter 一直到现在，处理Java集合的标准做法是采用外循环。比如：123456List list =newArrayList();list.add(&quot;hello&quot;);list.add(&quot;world&quot;);for(intitem: list) &#123;//处理item&#125; 还有迭代器循环，它们都是外循环，并且都是顺序处理（sequential handling）。顺序特性也常常引发ConcurrentModificationException，只要我们尝试着并发修改集合。 Lambda表达式提供了内循环机制。 我们工作中可能经常面临下面的需求： 过滤掉一个集合中不符合条件的元素得到一个新集合 对集合中的每个元素进行某种转换，并且对转换后的集合进行处理 统计整个集合的某个属性，比如统计集合元素值的总和或平均值 这些任务即filter、map和reduce，他们的共同特点是： 需要对集合中的每个元素运行一小段相同的代码。 传统的实现这些任务的代码让人感到很乏味，幸运的是Java 8提供了完成这些任务的更简洁的方案，当然还是利用Lambda表达式，但也引入了一个新的类库java.util.functions，包含Predicate、Mapper和Block。 Java 8中，一个Predicate（谓词）是这样一个方法：它根据变量的值进行评估(evaluate），返回true或false。java.util.functions.Predicate 比如下面：12345678910List list =getMyStrings();for(String myString: list) &#123;if(myString.contains(possible)) &#123;System.out.println(myString+ &quot; contains &quot; +possible);&#125;&#125; 使用Predicate和Filter后得到下面代码：123456List list =getMyStrings();Predicate matched = s -&gt;s.equalsIgnoreCase(possible);list.filter(matched); 进一步简化：1234List list =getMyStrings();list.filter(s-&gt; s.equalsIgnoreCase(possible)); 使用谓词 (Predicate) 来筛选集合：12345678910List names = Arrays.asList(&quot;Alice&quot;,&quot;Bob&quot;,&quot;Charlie&quot;,&quot;Dave&quot;);List filteredNames = names.filter(e -&gt; e.length() &gt;=4).into(new ArrayList());for(String name : filteredNames) &#123;System.out.println(name);&#125; 这里我们有两个新方法： Iterable filter(Predicate) 用于获取元素满足某个谓词返回 true 的结果","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"Invalid double崩溃分析","date":"2016-04-12T06:06:15.000Z","path":"2016/04/12/Invalid-double崩溃分析/","text":"第一次遇到 java.lang.NumberFormatException: Invalid double: “0,3”这样包含逗号的浮点数异常，第一感觉就是服务器给的数据错误，但前段时间复现了这个异常，才发现是代码不规范导致了这样的异常： 崩溃的详细log如下：123456789101112131415161718192021222324252627282930E/AndroidRuntime: FATAL EXCEPTION: mainProcess: com.frank.lollipopdemo, PID: 10898java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.frank.lollipopdemo/com.frank.lollipopdemo.MainActivity&#125;: java.lang.NumberFormatException: Invalid double: &quot;0,3&quot; at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2325) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2387) at android.app.ActivityThread.access$800(ActivityThread.java:151) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1303) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5254) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698) Caused by: java.lang.NumberFormatException: Invalid double: &quot;0,3&quot; at java.lang.StringToReal.invalidReal(StringToReal.java:63) at java.lang.StringToReal.initialParse(StringToReal.java:164) at java.lang.StringToReal.parseDouble(StringToReal.java:282) at java.lang.Double.parseDouble(Double.java:301) at com.frank.lollipopdemo.MainActivity.onCreate(MainActivity.java:43) at android.app.Activity.performCreate(Activity.java:5990) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1106) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2278) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2387) at android.app.ActivityThread.access$800(ActivityThread.java:151) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1303) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5254) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903) atcom.android.internal.os.ZygoteInit.main(ZygoteInit.java:698) 而出错的代码是这样的：123456789101112131415161718192021222324protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_title = (TextView) findViewById(R.id.tv_title); tv_content = (TextView) findViewById(R.id.tv_content); String jsonVal = &quot;0.31415926&quot;; String title = remain1Places(jsonVal);// -&gt; 0.3 tv_title.setText(title); tv_content.setText(getPercent(Double.parseDouble(title)));// -&gt; ##.##% &#125; public static String remain1Places(String string) &#123; if (TextUtils.isEmpty(string)) &#123; return &quot;&quot;; &#125; return String.format(&quot;%.1f&quot;, Double.parseDouble(string)); &#125; public static String getPercent(double value) &#123; NumberFormat numberFormat = NumberFormat.getPercentInstance(); numberFormat.setMinimumFractionDigits(1); numberFormat.setMaximumFractionDigits(2); return numberFormat.format(value); &#125; 想把浮点数”0.31415926”保留一位小数，就使用了String.format()方法完成，而且完全不顾编译器对我们的建议： 之后，我们想把保留了一位小数后的浮点数”0.3”转成百分比的形式”30.0%”，当然先转成double，然后利用NumberFormat格式化成百分比。 看似没有问题，但是当我们把系统语言换成法语(France)之后，程序直接Crash，而且当我们只显示remain1Places()后的title时，发现”0.31415926”变成了”0,3”，而不是”0.3”，这就直接导致了Double.parseDouble(“0,3”)抛出一个数据格式异常。 那为什么String.format()会将小数点的”句点(.)“换成了”逗号(,)“呢？摘自维基百科： A decimal mark is a symbol used to separate the integer part from the fractional part of a number written in decimal form. Different countries officially designate different symbols for the decimal mark. The choice of symbol for the decimal mark also affects the choice of symbol for the thousands separator used in digit grouping, so the latter is also treated in this article. 可以看到，有很多地区都是用逗号(,)作为小数点的，如19,90€表示19.9欧元；但计算机程序中的浮点数必须用句点(.)作为小数点，如double price = 19.90;表示浮点数19.9。所以在使用double的包装类Double的parseDouble(String)或valueOf(String)方法将字符串表示的double值转成double时，字符串所表示的double值必须是用句点(.)分隔的浮点数，也就是计算机的浮点数表示形式。Double.valueOf(String)方法仅仅调用了Double.parseDouble(String)并返回Double对象。 Double.parseDouble(String)方法返回原语类型的double变量。 因此，我们就可以断定这是一个本地化（Locale）的问题了。现在再来看一下编译器(lint)给我们String.format()方法的建议：Implicitly using the default locale is a common source of bugs: Use String.format(Locale, …) instead. 隐式地使用默认的区域设置是常见Bug源，请使用String.format(Locale, …)等方法替换它。 也就是说，String.format(String format, Object… args)会调用format(Locale.getDefault(), format, args)使用用户默认的区域设置返回格式化好且本地化好的字符串，因用户设置的不同而返回不同的字符串，进而出现Bug。如果你只是想格式化字符串而不是人为干预，应该用 String.format(Locale locale, String format, Object... args)方法，Locale参数用Locale.US就可以了。因此，我们应该重视本地化问题：将字符串所有字符转为大/小写的方法String.toLowerCase()/String.toUpperCase()并不一定能将字符真正的大/小写（如区域设置为土耳其时，i大写后还是i），因此应该指定要使用的区域设置String.toLowerCase(Locale locale)/String.toUpperCase(Locale locale)。格式化字符串的方法String.format(String format, Object… args)应该指定区域设置，以避免区域设置变化导致的Bug。千万不要将数字format()成字符串后再将该字符串转回原语类型，因为format()后的字符串可能不是合法的原语类型的数字了。即永远不要出现类似这样 Double.parseDouble(new DecimalFormat(“#.##”).format(doubleValue))的代码。建议使用NumberFormat，如：12345678910111213public static String remain1Places(String str) &#123; NumberFormat numberFormat = NumberFormat.getInstance(Locale.getDefault()); numberFormat.setMinimumFractionDigits(1); numberFormat.setMaximumFractionDigits(1); return numberFormat.format(Double.parseDouble(str));&#125;public static String getPercent(String str) &#123; NumberFormat numberFormat = NumberFormat.getPercentInstance(Locale.getDefault()); numberFormat.setMinimumFractionDigits(1); numberFormat.setMaximumFractionDigits(2); return numberFormat.format(Double.parseDouble(str));&#125;","tags":[{"name":"安卓","slug":"安卓","permalink":"http://samychen.com/tags/安卓/"}]},{"title":"Android动态添加权限","date":"2016-04-03T06:21:44.000Z","path":"2016/04/03/Android动态添加权限/","text":"一、工具 权限适配工具 PermissionsDispatcher 使用注解 @RuntimePermissions 是必须的注册当前activity或fragment @NeedsPermission 是必须要有的，在需要权限的方法上添加 @OnShowRationale 注释一个方法解释为什么需要这个(个)权限并提示用户判断是否允许 @OnPermissionDenied 当权限被拒绝时调用 @OnNeverAskAgain 当用户勾选了不再提示时调用 使用方法： 注意：同一组内的任何一个权限被授权了，其他权限也自动被授权。例如，一旦READ_CALENDAR被授权了，应用也有WRITE_CALENDAR权限了。 参考文档 Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177@RuntimePermissionspublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);findViewById(R.id.button_camera).setOnClickListener(this);findViewById(R.id.button_contacts).setOnClickListener(this);&#125;@Overridepublic void onClick(@NonNull View v) &#123;switch (v.getId()) &#123;case R.id.button_camera:// NOTE: delegate the permission handling to generated methodMainActivityPermissionsDispatcher.showCameraWithCheck(this);break;case R.id.button_contacts:// NOTE: delegate the permission handling to generated methodMainActivityPermissionsDispatcher.showContactsWithCheck(this);break;&#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;super.onRequestPermissionsResult(requestCode, permissions, grantResults);// NOTE: delegate the permission handling to generated methodMainActivityPermissionsDispatcher.onRequestPermissionsResult(this, requestCode, grantResults);&#125;@NeedsPermission(Manifest.permission.CAMERA)void showCamera() &#123;// NOTE: Perform action that requires the permission. If this is run by PermissionsDispatcher, the permission will have been grantedgetSupportFragmentManager().beginTransaction().replace(R.id.sample_content_fragment, CameraPreviewFragment.newInstance()).addToBackStack(&quot;camera&quot;).commitAllowingStateLoss();&#125;@NeedsPermission(&#123;Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS&#125;)void showContacts() &#123;// NOTE: Perform action that requires the permission.// If this is run by PermissionsDispatcher, the permission will have been grantedgetSupportFragmentManager().beginTransaction().replace(R.id.sample_content_fragment, ContactsFragment.newInstance()).addToBackStack(&quot;contacts&quot;).commitAllowingStateLoss();&#125;@OnShowRationale(Manifest.permission.CAMERA)void showRationaleForCamera(PermissionRequest request) &#123;// NOTE: Show a rationale to explain why the permission is needed, e.g. with a dialog.// Call proceed() or cancel() on the provided PermissionRequest to continue or abortshowRationaleDialog(R.string.permission_camera_rationale, request);&#125;@OnShowRationale(&#123;Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS&#125;)void showRationaleForContact(PermissionRequest request) &#123;// NOTE: Show a rationale to explain why the permission is needed, e.g. with a dialog.// Call proceed() or cancel() on the provided PermissionRequest to continue or abortshowRationaleDialog(R.string.permission_contacts_rationale, request);&#125;@OnPermissionDenied(Manifest.permission.CAMERA)void onCameraDenied() &#123;// NOTE: Deal with a denied permission, e.g. by showing specific UI// or disabling certain functionalityToast.makeText(this, R.string.permission_camera_denied, Toast.LENGTH_SHORT).show();&#125;@OnNeverAskAgain(Manifest.permission.CAMERA)void onCameraNeverAskAgain() &#123;Toast.makeText(this, R.string.permission_camera_never_askagain, Toast.LENGTH_SHORT).show();&#125;public void onBackClick(View view) &#123;getSupportFragmentManager().popBackStack();&#125;private void showRationaleDialog(@StringRes int messageResId, final PermissionRequest request) &#123;new AlertDialog.Builder(this).setPositiveButton(R.string.button_allow, new DialogInterface.OnClickListener() &#123;@Overridepublic void onClick(@NonNull DialogInterface dialog, int which) &#123;request.proceed();&#125;&#125;).setNegativeButton(R.string.button_deny, new DialogInterface.OnClickListener() &#123;@Overridepublic void onClick(@NonNull DialogInterface dialog, int which) &#123;request.cancel();&#125;&#125;).setCancelable(false).setMessage(messageResId).show();&#125;&#125; 权限适配工具 PermissionCompat","tags":[{"name":"安卓","slug":"安卓","permalink":"http://samychen.com/tags/安卓/"}]},{"title":"Java SSL Socket通讯实例二","date":"2016-03-12T05:38:32.000Z","path":"2016/03/12/Java-SSL-Socket通讯实例二/","text":"对于SSL/TLS协议，如果要每个开发者都自己去实现显然会带来不必要的麻烦，正是为了解决这个问题Java为广大开发者提供了Java安全套接字扩展——JSSE，它包含了实现Internet安全通信的一系列包的集合，是SSL和TLS的纯Java实现，同时它是一个开放的标准，每个公司都可以自己实现JSSE，通过它可以透明地提供数据加密、服务器认证、信息完整性等功能，就像使用普通的套接字一样使用安全套接字，大大减轻了开发者的负担，使开发者可以很轻松将SSL协议整合到程序中，并且JSSE能将安全隐患降到了最低点。在利用SSL/TLS进行安全通信时，客户端跟服务器端都必须要支持SSL/TLS协议，不然将无法进行通信。而且客户端和服务器端都可能要设置用于证实自己身份的安全证书，并且还要设置信任对方的哪些安全证书。关于身份认证方面有个名词叫客户端模式，一般情况客户端要对服务器端的身份进行验证，但是无需向服务器证实自己的身份，这样不用向对方证实自己身份的通信端我们就说它处于客户模式，否则成它处于服务器模式。SSLSocket的setUseClientMode(Boolean mode)方法可以设置客户端模式或服务器模式。下面看具体实现的过程① 解决证书问题。一般而言作为服务器端必须要有证书以证明这个服务器的身份，并且证书应该描述此服务器所有者的一些基本信息，例如公司名称、联系人名等。证书由所有人以密码形式签名，基本不可伪造，证书获取的途径有两个：一是从权威机构购买证书，权威机构担保它发出的证书的真实性，而且这个权威机构被大家所信任，进而你可以相信这个证书的有效性；另外一个是自己用JDK提供的工具keytool创建一个自我签名的证书，这种情况下一般是我只想要保证数据的安全性与完整性，避免数据在传送的过程中被窃听或篡改，此时身份的认证已不重要，重点已经在端与端传输的秘密性上，证书的作用只体现在加解密签名。SSL协议通信涉及密钥储存的文件格式比较多，很容易搞混，例如xxx.cer、xxx.pfx、xxx.jks、xxx.keystore、xxx.truststore等格式文件。如图3-1-7-3，搞清楚他们有助于理解后面的程序，.cer格式文件俗称证书，但这个证书中没有私钥，只包含了公钥；.pfx格式文件也称为证书，它一般供浏览器使用，而且它不仅包含了公钥，还包含了私钥，当然这个私钥是加密的，不输入密码是解不了密的；.jks格式文件表示java密钥存储器（java key store），它可以同时容纳N个公钥跟私钥，是一个密钥库；.keystore格式文件其实跟.jks基本是一样的，只是不同公司叫法不太一样，默认生成的证书存储库格式；.truststore格式文件表示信任证书存储库，它仅仅包含了通信对方的公钥，当然你可以直接把通信对方的jks作为信任库（就算如此你也只能知道通信对方的公钥，要知道密钥都是加密的，你无从获取，只要算法不被破解）。有些时候我们需要把pfx或cert转化为jks以便于用java进行ssl通信，例如一个银行只提供了pfx证书，而我们想用java进行ssl通信时就要将pfx转化为jks格式。图3-1-7-3 密钥存储文件格式 按照理论上，我们一共需要准备四个文件，两个keystore文件和两个truststore文件，通信双方分别拥有一个keystore和一个truststore，keystore用于存放自己的密钥和公钥，truststore用于存放所有需要信任方的公钥。这里为了方便直接使用jks即keystore替代truststore（免去证书导来导去），因为对方的keystore包含了自己需要的信任公钥。下面使用jdk自带的工具分别生成服务器端证书，通过如下命令并输入姓名、组织单位名称、组织名称、城市、省份、国家信息即可生成证书密码为tomcat的证书，此证书存放在密码也为tomcat的tomcat.jks证书存储库中。如果你继续创建证书将继续往tomcat.jks证书存储库中添加证书。如果你仅仅输入keytool -genkey -alias tomcat -keyalg RSA -keypass tomcat -storepass tomcat，不指定证书存储库的文件名及路径，则工具会在用户的home directory目录下生产一个“.keystore”文件作为证书存储库。类似的，客户端证书也用此方式进行生成。如下② 服务端TomcatSSLServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class TomcatSSLServer &#123; private static final String SSL_TYPE = &quot;SSL&quot;; private static final String KS_TYPE = &quot;JKS&quot;; private static final String X509 = &quot;SunX509&quot;; private final static int PORT = 443; private static TomcatSSLServer sslServer; private SSLServerSocket svrSocket; public static TomcatSSLServer getInstance() throws Exception &#123; if (sslServer == null) &#123; sslServer = new TomcatSSLServer(); &#125; return sslServer; &#125; private TomcatSSLServer() throws Exception&#123; SSLContext sslContext = createSSLContext(); SSLServerSocketFactory serverFactory = sslContext.getServerSocketFactory(); svrSocket =(SSLServerSocket) serverFactory.createServerSocket(PORT); svrSocket.setNeedClientAuth(true); String[] supported = svrSocket.getEnabledCipherSuites(); svrSocket.setEnabledCipherSuites(supported); &#125; private SSLContext createSSLContext() throws Exception&#123; KeyManagerFactory kmf = KeyManagerFactory.getInstance(X509); TrustManagerFactory tmf = TrustManagerFactory.getInstance(X509); String serverKeyStoreFile = &quot;c:\\\\tomcat.jks&quot;; String svrPassphrase = &quot;tomcat&quot;; char[] svrPassword = svrPassphrase.toCharArray(); KeyStore serverKeyStore = KeyStore.getInstance(KS_TYPE); serverKeyStore.load(new FileInputStream(serverKeyStoreFile), svrPassword); kmf.init(serverKeyStore, svrPassword); String clientKeyStoreFile = &quot;c:\\\\client.jks&quot;; String cntPassphrase = &quot;client&quot;; char[] cntPassword = cntPassphrase.toCharArray(); KeyStore clientKeyStore = KeyStore.getInstance(KS_TYPE); clientKeyStore.load(new FileInputStream(clientKeyStoreFile),cntPassword); tmf.init(clientKeyStore); SSLContext sslContext = SSLContext.getInstance(SSL_TYPE); sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null); return sslContext; &#125; public void startService() &#123; SSLSocket cntSocket = null; BufferedReader ioReader = null; PrintWriter ioWriter = null; String tmpMsg = null; while( true ) &#123; try &#123; cntSocket =(SSLSocket) svrSocket.accept(); ioReader = new BufferedReader(new InputStreamReader(cntSocket.getInputStream())); ioWriter = new PrintWriter(cntSocket.getOutputStream()); while ( (tmpMsg = ioReader.readLine()) != null) &#123; System.out.println(&quot;客户端通过SSL协议发送信息:&quot;+tmpMsg); tmpMsg=&quot;欢迎通过SSL协议连接&quot;; ioWriter.println(tmpMsg); ioWriter.flush(); &#125; &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(cntSocket != null) cntSocket.close(); &#125; catch(Exception ex) &#123;ex.printStackTrace();&#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; TomcatSSLServer.getInstance().startService(); &#125;&#125; 基本顺序是先得到一个SSLContext实例，再对SSLContext实例进行初始化，密钥管理器及信任管理器作为参数传入，证书管理器及信任管理器按照指定的密钥存储器路径和密码进行加载。接着设置支持的加密套件，最后让SSLServerSocket开始监听客户端发送过来的消息。 ③ 客户端TomcatSSLClient.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TomcatSSLClient &#123; private static final String SSL_TYPE = &quot;SSL&quot;; private static final String X509 = &quot;SunX509&quot;; private static final String KS_TYPE = &quot;JKS&quot;; private SSLSocket sslSocket; public TomcatSSLClient(String targetHost,int port) throws Exception &#123; SSLContext sslContext = createSSLContext(); SSLSocketFactory sslcntFactory =(SSLSocketFactory) sslContext.getSocketFactory(); sslSocket = (SSLSocket) sslcntFactory.createSocket(targetHost, port); String[] supported = sslSocket.getSupportedCipherSuites(); sslSocket.setEnabledCipherSuites(supported); &#125; private SSLContext createSSLContext() throws Exception&#123; KeyManagerFactory kmf = KeyManagerFactory.getInstance(X509); TrustManagerFactory tmf = TrustManagerFactory.getInstance(X509); String clientKeyStoreFile = &quot;c:\\\\client.jks&quot;; String cntPassphrase = &quot;client&quot;; char[] cntPassword = cntPassphrase.toCharArray(); KeyStore clientKeyStore = KeyStore.getInstance(KS_TYPE); clientKeyStore.load(new FileInputStream(clientKeyStoreFile),cntPassword); String serverKeyStoreFile = &quot;c:\\\\tomcat.jks&quot;; String svrPassphrase = &quot;tomcat&quot;; char[] svrPassword = svrPassphrase.toCharArray(); KeyStore serverKeyStore = KeyStore.getInstance(KS_TYPE); serverKeyStore.load(new FileInputStream(serverKeyStoreFile), svrPassword); kmf.init(clientKeyStore, cntPassword); tmf.init(serverKeyStore); SSLContext sslContext = SSLContext.getInstance(SSL_TYPE); sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null); return sslContext; &#125; public String sayToSvr(String sayMsg) throws IOException&#123; BufferedReader ioReader = new BufferedReader(new InputStreamReader( sslSocket.getInputStream())); PrintWriter ioWriter = new PrintWriter(sslSocket.getOutputStream()); ioWriter.println(sayMsg); ioWriter.flush(); return ioReader.readLine(); &#125; public static void main(String[] args) throws Exception &#123; TomcatSSLClient sslSocket = new TomcatSSLClient(&quot;127.0.0.1&quot;,443); BufferedReader ioReader = new BufferedReader(new InputStreamReader(System.in)); String sayMsg = &quot;&quot;; String svrRespMsg= &quot;&quot;; while( (sayMsg = ioReader.readLine())!= null ) &#123; svrRespMsg = sslSocket.sayToSvr(sayMsg); if(svrRespMsg != null &amp;&amp; !svrRespMsg.trim().equals(&quot;&quot;)) &#123; System.out.println(&quot;服务器通过SSL协议响应:&quot;+svrRespMsg); &#125; &#125; &#125;&#125; 客户端的前面操作基本跟服务器端的一样，先创建一个SSLContext实例，再用密钥管理器及信任管理器对SSLContext进行初始化，当然这里密钥存储的路径是指向客户端的client.jks。接着设置加密套件，最后使用SSLSocket进行通信。 注意服务器端有行代码svrSocket.setNeedClientAuth(true);它是非常重要的一个设置方法，用于设置是否验证客户端的身份。假如我们把它注释掉或设置为false，此时客户端将不再需要自己的密钥管理器，即服务器不需要通过client.jks对客户端的身份进行验证，把密钥管理器直接设置为null也可以跟服务器端进行通信。 最后谈谈信任管理器，它的职责是决定是否信任远端的证书，那么它凭借什么去判断呢？如果不显式设置信任存储器的文件路径，将遵循如下规则：①如果系统属性javax.net.ssl.truststore指定了truststore文件，那么信任管理器将去jre路径下的lib/security目录寻找这个文件作为信任存储器；②如果没设置①中的系统属性，则去寻找一个%java_home%/lib/security/jssecacerts文件作为信任存储器；③如果jssecacerts不存在而cacerts存在，则cacerts作为信任存储器。至此，一个利用JSSE实现BIO模式的SSL协议通信的例子已完成。","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"SwipeRefreshLayout和ListView的EmptyView共存冲突的问题","date":"2016-03-11T08:09:54.000Z","path":"2016/03/11/SwipeRefreshLayout和ListView的EmptyView共存冲突的问题/","text":"SwipeRefreshLayout是android官方的下拉刷新控件；它内部有且只能有一个子控件；当一个ListView嵌入到它内部时，就不能为ListView带一个EmptyView了；于是很自然的想到将ListView和EmptyView纳入到一个父控件中；典型的像下面这样的布局：1234567891011121314151617181920212223&lt;android.support.v4.widget.SwipeRefreshLayout android:id=&quot;@+id/swipeRefreshLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;ListView android:id=&quot;@+id/listView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:cacheColorHint=&quot;@android:color/transparent&quot; android:divider=&quot;@color/text_color_c4&quot; android:dividerHeight=&quot;@dimen/line_width&quot; android:footerDividersEnabled=&quot;true&quot; /&gt; &lt;include android:id=&quot;@+id/emptyView&quot; layout=&quot;@layout/empty_view_for_tang_friend_0&quot; /&gt; &lt;/FrameLayout&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 这样就可以实现ListView和EmptyView都下拉刷新了；但是问题来了，当ListView的数据超过一屏的时候，再往上滑，滑不上去了；这就是SwipeRefreshLayout和ListView的EmptyView共存冲突的问题（如果SwipeRefreshLayout中仅有一个ListView的话没问题，但现在多了一个EmptyView）； 解决办法有是有，虽然不那么优雅：1234567891011121314151617181920212223242526272829swipeRefreshLayout = (android.support.v4.widget.SwipeRefreshLayout) v.findViewById(R.id.swipeRefreshLayout); swipeRefreshLayout.setColorSchemeResources(R.color.text_color_c6, R.color.yellow, R.color.grey, R.color.red); swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; // TODO Auto-generated method stub //dosomething &#125; &#125;);listView = (ListView) v.findViewById(R.id.listView); listView.setOnScrollListener(new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView absListView, int i) &#123; &#125; @Override public void onScroll(AbsListView absListView, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; if (firstVisibleItem == 0) swipeRefreshLayout.setEnabled(true); else swipeRefreshLayout.setEnabled(false); &#125; &#125;); 在ListView滑动的时候做一个判断，看看是不是滑动到顶部了，到顶部了就swipeRefreshLayout.setEnabled(true);让SwipeRefreshLayout可以接受动作，这样就ok了。 上面的解决方案比较简单，但是有个小问题，就是当listView滑动到第一个Item（让第一个Item显示一半）的时候，再上滑就上不去了，始终显示半个Item。为了解决这个问题，只能使用笨办法了：将ListView和EmptyView分离，让他们两个分别被两个SwipeRefreshLayout包裹，如下面的布局：1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=&quot;@+id/swipeRefreshLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;cn.tangdada.tangbang.widget.LoadMoreListView android:id=&quot;@+id/listView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:cacheColorHint=&quot;@android:color/transparent&quot; android:divider=&quot;@color/text_color_c4&quot; android:dividerHeight=&quot;@dimen/line_width&quot; android:footerDividersEnabled=&quot;false&quot; /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=&quot;@+id/swipeRefreshLayoutEmptyView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:visibility=&quot;gone&quot; &gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:paddingLeft=&quot;32dp&quot; android:paddingRight=&quot;32dp&quot; android:text=&quot;@string/empty&quot; android:textColor=&quot;@color/text_color_c3&quot; android:textSize=&quot;@dimen/font_big&quot; /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/FrameLayout&gt; 然后需要在代码中控制显示EmptyView的时机，比如我这里的：12345678910111213141516171819202122232425262728private void updateViews(Object obj) &#123; ArrayList&lt;User&gt; list = (ArrayList&lt;User&gt;) obj; if (list.size() == 0) &#123; //listView.removeLoadMoreListener(); &#125; users.addAll(list); if (users.size() == 0) &#123; swipeRefreshLayout.setVisibility(View.GONE); swipeRefreshLayout.setRefreshing(false); swipeRefreshLayoutEmptyView.setVisibility(View.VISIBLE); swipeRefreshLayoutEmptyView.setRefreshing(false); &#125; else &#123; //listView.onLoadMoreComplete(); swipeRefreshLayout.setVisibility(View.VISIBLE); swipeRefreshLayout.setRefreshing(false); swipeRefreshLayoutEmptyView.setVisibility(View.GONE); swipeRefreshLayoutEmptyView.setRefreshing(false); &#125; notifyDataSetChanged(); &#125;","tags":[{"name":"安卓","slug":"安卓","permalink":"http://samychen.com/tags/安卓/"}]},{"title":"安卓开发规范","date":"2016-03-11T07:17:50.000Z","path":"2016/03/11/安卓开发规范/","text":"#安卓开发规范 @(Android高级)[开发规范] 摘要 [TOC] 1 前言为了利于项目维护以及规范开发，促进成员之间Code Review的效率，必须按照一定的开发规范。 2 AS规范工欲善其事，必先利其器。 尽量使用最新版的IDE进行开发； 编码格式统一为UTF-8； 编辑完.java, .xml等文件后一定要格式化（基本格式方面使用 AS 默认模板即可）； 删除多余的import，减少警告出现，可利用AS的Optimize Imports(Settings → Keymap → Optimize Imports)快捷键 3 命名规范 代码中的命名严禁使用拼音与英文混合的方式,更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解,避免歧义。 注意：即使纯拼音命名方式也要避免采用。但alibaba、taobao、youku、hangzhou等国际通用的名称,可视同英文。 3.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。 采用反域名命名规则，全部使用小写字母。一级包名是顶级域名，通常为com,edu,gov,net,org等，二级包名为公司名，三级包名根据应用进行命名，四级包名为模块名或层级名。| 包名 |此包中包含 || :——————-|:—————–:||com.xx.应用名称缩写.activity|用户界面中所有的Activity类||com.xx.应用名称缩写.fragment|界面中所有的Fragment类||com.xx.应用名称缩写.base|基础共享的类||com.xx.应用名称缩写.adapter|页面用到的Adapter类 (适配器的类)||com.xx.应用名称缩写.view|自定义的View类||自定义的View类|自定义的View类||com.xx.应用名称缩写.util|此包中包含：公共工具方法类（util模块名||com.xx.应用名称缩写.bean|下面可分：vo、po、dto 此包中包含：JavaBean类||com.xx.应用名称缩写.model|此包中包含：模型类||com.xx.应用名称缩写.db|数据库操作类||com.xx.应用名称缩写.view (或者 com.xx.应用名称缩写.widget )|自定义的View类等||com.xx.应用名称缩写.service|Service服务||com.xx.应用名称缩写.receiver|BroadcastReceiver服务||com.xx.应用名称缩写.config|所有的配置相关的类| 注意：如果项目采用MVP，所有M、V、P抽取出来的接口都放置在相应模块的i包下，所有的实现都放置在相应模块的impl下 3.2 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如HTML, URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity 类 Activity为后缀标识 欢迎页面类WelcomeActivity Adapter类 Adapter 为后缀标识 新闻详情适配器 NewDetailAdapter 解析类 Parser为后缀标识 首页解析类HomePosterParser 工具方法类 Utils或Manager为后缀标识（与系统或第三方的Utils区分）或功能+Utils 线程池管理类：ThreadPoolManager日志工具类：LogUtils（Logger也可）打印工具类：PrinterUtils 数据库类 以DBHelper后缀标识 新闻数据库：NewDBHelper Service类 以Service为后缀标识 时间服务TimeService BroadcastReceiver类 以Receiver为后缀标识 推送接收JPushReceiver ContentProvider类 以Provider为后缀标识 ShareProvider 自定义的共享基础类 以Base开头 BaseActivity,BaseFragment 测试类的命名以它要测试的类的名称开始，以Test结束。例如：HashTest或HashIntegrationTest。 接口（interface）：命名规则与类一样采用大驼峰命名法，多以able或ible结尾，如 interface Runnable、interface Accessible。 注意：如果项目采用MVP，所有Model、View、Presenter的接口都以I为前缀，不加后缀，其他的接口采用上述命名规则。 3.3 方法名方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。|方法 |说明 ||:————-|:————-:||intXX()|初始化相关方法,使用init为前缀标识，如初始化布局initView()||isXX() checkXX()|方法返回值为boolean型的请使用is或check为前缀标识||getXX()|返回某个值的方法，使用get为前缀标识||setXX()|设置某个属性值||handleXX()/processXX()|对数据进行处理的方法||displayXX()/showXX()|弹出提示框和提示信息，使用display/show为前缀标识||updateXX()|更新数据||saveXX()|保存数据||resetXX()|重置数据||clearXX()|清楚数据||removeXX()|移除数据或者视图等，如removeView();||drawXX()|绘制数据或效果相关的，使用draw前缀标识| 3.4 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？ 每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableListNAMES = ImmutableList.of(\"Ed\", \"Ann\");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = \"non-final\";final String nonStatic = \"non-static\";static final SetmutableCollection = new HashSet();static final ImmutableSetmutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;\"these\", \"can\", \"change\"&#125;; 3.5 非常量字段名非常量字段名以lowerCamelCase风格的基础上改造为如下风格：基本结构为scopeVariableNameType。 scope：范围 非公有，非静态字段命名以m开头。 静态字段命名以s开头。 公有非静态字段命名以p开头。 公有静态字段（全局变量）命名以g开头。 例子：12345678public class MyClass &#123; int mPackagePrivate; private int mPrivate; protected int mProtected; private static MyClass sSingleton; public int pField; public static int gField;&#125; 使用1字符前缀来表示作用范围，1个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。 Type：类型 考虑到Android中使用很多UI控件，为避免控件和普通成员变量混淆以及更好达意，所有用来表示控件的成员变量统一加上控件缩写作为后缀（文末附有缩写表）。 对于普通变量一般不添加类型后缀，如果统一添加类型后缀，请参考文末的缩写表。 用统一的量词通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。 注意：如果项目中使用ButterKnife，则不添加m前缀，以lowerCamelCase风格命名。例如，请使用mCustomerStrFirst和mCustomerStrLast，而不要使用mFirstCustomerStr和mLastCustomerStr。|量词列表|量词后缀说明||:———–|:————-:||First|一组变量中的第一个||Last|一组变量中的最后一个||Next|一组变量中的下一个变量||Prev|一组变量中的上一个||Cur|一组变量中的当前变量|说明： 集合添加如下后缀：List、Map、Set 数组添加如下后缀：Arr 注意：所有的VO（值对象）统一采用标准的lowerCamelCase风格编写，所有的DTO（数据传输对象）就按照接口文档中定义的字段名编写。 3.6 参数名参数名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 3.7 局部变量名局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 3.8 临时变量 临时变量通常被取名为i、j、k、m和n，它们一般用于整型；c、d、e，它们一般用于字符型。 如：for (int i = 0; i &lt; len ; i++)。 3.9 类型变量名 类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。以类命名方式(参考3.2 类名)，后面加个大写的T(如：RequestT, FooBarT)。 4 资源文件规范4.1 资源布局文件（XML文件（layout布局文件）） 全部小写，采用下划线命名法 4.1.1 contentView命名 必须以全部单词小写，单词间以下划线分割，使用名词或名词词组。 所有Activity或Fragment的contentView必须与其类名对应，对应规则为：将所有字母都转为小写，将类型和功能调换（也就是后缀变前缀）。 例如：activity_main.xml 4.1.2 Dialog命名 规则：dialog_描述.xml 例如：dialog_hint.xml 4.1.3 PopupWindow命名 规则：ppw_描述.xml 例如：ppw_info.xml 4.1.4 列表项命名 规则：item_描述.xml 例如：item_city.xml 4.1.5 包含项命名 规则：模块_(位置)描述.xml 例如：activity_main_head.xml、activity_main_bottom.xml 注意：通用的包含项命名采用：项目名称缩写_描述.xml 例如：xxxx_title.xml 4.2 资源文件（图片drawable文件夹下） 全部小写，采用下划线命名法，加前缀区分 命名模式：可加后缀 _small 表示小图， _big 表示大图，逻辑名称可由多个单词加下划线组成，采用以下规则： 用途模块名逻辑名称用途模块名颜色用途逻辑名称用途颜色说明：用途也指控件类型（具体见附录UI控件缩写表） 例如： 名称 说明 btn_main_home.png 按键 divider_maket_white.png 分割线 ic_edit.png 图标 bg_main.png 背景 btn_red.png 红色按钮 btn_red_big.png 红色大按键 ic_head_small.png 小头像 bg_input.png 输入框背景颜色 divider_white.png 白色分割线 如果有多种形态，如按钮选择器：btn_xx.xml(selector)|名称 |说明||:—————–|:————–:||btnxx|按钮图片使用btn整体效果（selector）||btn_xxnormal|按钮图片使用btn正常情况效果||btn_xxpressed|按钮图片使用btn点击时候效果||btn_xx_focused|state_focused聚焦效果||btn_xx_hovered|state_hovered悬停效果||btn_xx_activated |state_activated激活的||bghead|背景图片使用bg功能_说明||def_searchcell|默认图片使用def功能_说明||ic_morehelp|图标图片使用ic功能_说明||seg_listline|具有分隔特征的图片使用seg功能_说明||selok|选择图标使用sel功能_说明| 注意：使用AndroidStudio的插件SelectorChapek可以快速生成selector，前提是命名要规范 4.3 动画文件（anim文件夹下） 全部小写，采用下划线命名法，加前缀区分。 具体动画采用以下规则：模块名_逻辑名称。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。 普通的tween动画采用如下表格中的命名方式：动画类型_方向 名称 说明 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小 4.4 values中name命名 4.4.1 colors.xml colors的name命名使用下划线命名法，在你的colors.xml文件中应该只是映射颜色的名称一个ARGB值，而没有其它的。不要使用它为不同的按钮来定义ARGB值。 不要这样做123456789&lt;resources&gt; &lt;color name=\"button_foreground\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"button_background\"&gt;#2A91BD&lt;/color&gt; &lt;color name=\"comment_background_inactive\"&gt;#5F5F5F&lt;/color&gt; &lt;color name=\"comment_background_active\"&gt;#939393&lt;/color&gt; &lt;color name=\"comment_foreground\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"comment_foreground_important\"&gt;#FF9D2F&lt;/color&gt; ... &lt;color name=\"comment_shadow\"&gt;#323232&lt;/color&gt; 使用这种格式，你会非常容易的开始重复定义ARGB值，这使如果需要改变基本色变的很复杂。同时，这些定义是跟一些环境关联起来的，如button或者comment, 应该放到一个按钮风格中，而不是在color.xml文件中。 相反，这样做12345678910111213141516&lt;resources&gt; &lt;!-- grayscale --&gt; &lt;color name=\"white\" &gt;#FFFFFF&lt;/color&gt; &lt;color name=\"gray_light\"&gt;#DBDBDB&lt;/color&gt; &lt;color name=\"gray\" &gt;#939393&lt;/color&gt; &lt;color name=\"gray_dark\" &gt;#5F5F5F&lt;/color&gt; &lt;color name=\"black\" &gt;#323232&lt;/color&gt; &lt;!-- basic colors --&gt; &lt;color name=\"green\"&gt;#27D34D&lt;/color&gt; &lt;color name=\"blue\"&gt;#2A91BD&lt;/color&gt; &lt;color name=\"orange\"&gt;#FF9D2F&lt;/color&gt; &lt;color name=\"red\"&gt;#FF432F&lt;/color&gt; &lt;/resources&gt; 向应用设计者那里要这个调色板，名称不需要跟”green”、”blue”等等相同。”brand_primary”、”brand_secondary”、”brand_negative”这样的名字也是完全可以接受的。 像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。 通常一个具有审美价值的UI来说，减少使用颜色的种类是非常重要的。 4.4.2 dimens.xml 像对待colors.xml一样对待dimens.xml文件 与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。 一个好的例子，如下所示：123456789101112131415161718192021&lt;resources&gt; &lt;!-- font sizes --&gt; &lt;dimen name=\"font_larger\"&gt;22sp&lt;/dimen&gt; &lt;dimen name=\"font_large\"&gt;18sp&lt;/dimen&gt; &lt;dimen name=\"font_normal\"&gt;15sp&lt;/dimen&gt; &lt;dimen name=\"font_small\"&gt;12sp&lt;/dimen&gt; &lt;!-- typical spacing between two views --&gt; &lt;dimen name=\"spacing_huge\"&gt;40dp&lt;/dimen&gt; &lt;dimen name=\"spacing_large\"&gt;24dp&lt;/dimen&gt; &lt;dimen name=\"spacing_normal\"&gt;14dp&lt;/dimen&gt; &lt;dimen name=\"spacing_small\"&gt;10dp&lt;/dimen&gt; &lt;dimen name=\"spacing_tiny\"&gt;4dp&lt;/dimen&gt; &lt;!-- typical sizes of views --&gt; &lt;dimen name=\"button_height_tall\"&gt;60dp&lt;/dimen&gt; &lt;dimen name=\"button_height_normal\"&gt;40dp&lt;/dimen&gt; &lt;dimen name=\"button_height_short\"&gt;32dp&lt;/dimen&gt;&lt;/resources&gt; 布局时在写margins和paddings时，你应该使用spacing_xxxx尺寸格式来布局，而不是像对待string字符串一样直接写值。 这样写会非常有感觉，会使组织和改变风格或布局是非常容易。 4.4.3 strings.xml strings的name命名使用下划线命名法，采用以下规则：模块名+逻辑名称 名称 说明 main_menu_about 主菜单按键文字 friend_title 好友模块标题栏 friend_dialog_del 好友删除提示 login_check_email 登录验证 dialog_title 弹出框标题 button_ok 确认键 loading 加载文字 4.4.4 styles.xml 几乎每个项目都需要适当的使用style文件，因为对于一个视图来说有一个重复的外观是很常见的，将所有的外观细节属性（colors、padding、font）放在style文件中。 在应用中对于大多数文本内容，最起码你应该有一个通用的style文件，例如：1234&lt;style name=\"ContentText\"&gt; &lt;item name=\"android:textSize\"&gt;@dimen/font_normal&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/basic_black&lt;/item&gt;&lt;/style&gt; 应用到TextView中:123456&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/price\" style=\"@style/ContentText\" /&gt; 你或许需要为按钮控件做同样的事情，不要停止在那里。将一组相关的和重复android:**的属性放到一个通用的style中。 将一个大的style文件分割成多个文件， 你可以有多个styles.xml 文件。Android SDK支持其它文件，styles这个文件名称并没有作用，起作用的是在文件 里xml的&lt;style&gt;标签。因此你可以有多个style文件styles.xml、style_home.xml、style_item_details.xml、styles_forms.xml。 不同于资源文件路径需要为系统构建起的有意义，在res/values目录下的文件可以任意命名。 4.5 layout中的id命名 命名模式为：view缩写模块名逻辑名，比如btn_main_search 使用AndroidStudio的插件ButterKnife Zelezny，生成注解非常方便，原生的话可以使用Android Code Generator插件。 5 版本统一规范Android开发存在着众多版本的不同，比如compileSdkVersion、minSdkVersion、targetSdkVersion以及项目中依赖第三方库的版本，不同的module及不同的开发人员都有不同的版本，所以需要一个统一版本规范的文件。 6 注释规范为了减少他人阅读你代码的痛苦值，请在关键地方做好注释。6.1 类注释 每个类完成后应该有作者姓名和联系方式的注释，对自己的代码负责。123456789101112/** * &lt;pre&gt; * author : Blankj * e-mail : xxx@xx * time : 2017/03/07 * desc : xxxx描述 * version: 1.0 * &lt;/pre&gt; */public class WelcomeActivity &#123; ...&#125; 具体可以在AS中自己配制，Settings → Editor → File and Code Templates → Includes → File Header，输入123456789/** * &lt;pre&gt; * author : $&#123;USER&#125; * e-mail : xxx@xx * time : $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125; * desc : * version: 1.0 * &lt;/pre&gt; */ 这样便可在每次新建类的时候自动加上该头注释。 6.2 方法注释 每一个成员方法（包括自定义成员方法、覆盖方法、属性方法）的方法头都必须做方法头注释，在方法前一行输入/** + 回车或者设置Fix doc comment(Settings → Keymap → Fix doc comment)快捷键，AS便会帮你生成模板，我们只需要补全参数即可，如下所示。12345678910111213/** * bitmap转byteArr * * @param bitmap bitmap对象 * @param format 格式 * @return 字节数组 */public static byte[] bitmap2Bytes(Bitmap bitmap, CompressFormat format) &#123; if (bitmap == null) return null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); bitmap.compress(format, 100, baos); return baos.toByteArray();&#125; 6.3 块注释 块注释与其周围的代码在同一缩进级别。它们可以是/ … /风格，也可以是// …风格(//后最好带一个空格）。对于多行的/ … /注释，后续行必须从开始， 并且与前一行的对齐。以下示例注释都是OK的。1234/* * This is // And so /* Or you can * okay. // is this. * even do this. */ */ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/ … /。 7 测试规范 业务开发完成之后，开发人员做单元测试，单元测试完成之后，保证单元测试全部通过同时单元测试代码覆盖率达到一定程度（这个需要开发和测试约定，理论上越高越好），开发提测。 // TODO... 8 其他规范 合理布局，有效运用、、标签； Activity和Fragment里面有许多重复的操作以及操作步骤，所以我们都需要提供一个BaseActivity和BaseFragment，让所有的Activity和Fragment都继承这个基类。 方法基本上都按照调用的先后顺序在各自区块中排列； 相关功能作为小区块放在一起（或者封装掉）； 当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法； 数据提供统一的入口。无论是在 MVP、MVC 还是 MVVM 中，提供一个统一的数据入口，都可以让代码变得更加易于维护。比如可使用一个DataManager，把 http、preference、eventpost、database 都放在DataManger里面进行操作，我们只需要与DataManger打交道； 多用组合, 少用继承； 提取方法, 去除重复代码。对于必要的工具类抽取也很重要，这在以后的项目中是可以重用的。 可引入 Dagger2 减少模块之间的耦合性。Dagger2 是一个依赖注入框架，使用代码自动生成创建依赖关系需要的代码。减少很多模板化的代码，更易于测试，降低耦合，创建可复用可互换的模块； 项目引入RxJava + RxAndroid这些响应式编程，可以极大的减少逻辑代码； 通过引入事件总线，如：EventBus、AndroidEventBus、RxBus，它允许我们在DataLayer中发送事件，以便ViewLayer中的多个组件都能够订阅到这些事件，减少回调； 尽可能使用局部变量； 及时关闭流； 尽量减少对变量的重复计算； 如下面的操作：123for (int i = 0; i &lt; list.size(); i++) &#123; ...&#125; 建议替换为：123for (int i = 0, int length = list.size(); i &lt; length; i++) &#123; ...&#125; 尽量采用懒加载的策略，即在需要的时候才创建； 例如：1234String str = \"aaa\";if (i == 1) &#123; list.add(str);&#125; 建议替换为：1234if (i == 1) &#123; String str = \"aaa\"; list.add(str);&#125; 不要在循环中使用try…catch…，应该把其放在最外层； 使用带缓冲的输入输出流进行IO操作； 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销； 尽量在合适的场合使用单例；使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据 + “”最慢； 使用AS自带的Lint来优化代码结构（什么，你不会？右键module、目录或者文件，选择Analyze → Inspect Code）； 最后不要忘了内存泄漏的检测；","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"Java SSL Socket通讯实例一","date":"2016-02-22T05:39:47.000Z","path":"2016/02/22/Java-SSL-Socket通讯实例一/","text":"从最简单来说，Java里面只需要配置几个系统属性，创建及调用几个SSL相关的对象即可。这四个属性分别是:javax.net.ssl.keyStore本方的密码，证书等存放地点(KeyStore文件地址)。javax.net.ssl.keyStorePasswordKeyStore的密码。没有密码可以不填。javax.net.ssl.trustStore受信任证书的存放地点(TrustKeyStore文件地址)。javax.net.ssl.trustStorePasswordTrustKeyStore的密码。没有密码可以不填。 KeyStore类型默认是JKS类型的，不是的话，还需要设置 javax.NET.ssl.keyStoreType和javax.Net.ssl.trustStoreType。 Server端代码每一次收新的连接，都新开一个线程接待。生产上请用线程池等技术。更推荐用Netty或Mina等框架处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SslServer &#123; public static void main(String[] args) throws Exception &#123; System.setProperty(&quot;javax.net.debug&quot;, &quot;ssl,handshake&quot;); System.setProperty(&quot;javax.net.ssl.keyStore&quot;, &quot;./cfg/server.jks&quot;); System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, &quot;123456&quot;); System.setProperty(&quot;javax.net.ssl.trustStore&quot;, &quot;./cfg/clienttrust.jks&quot;); System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, &quot;123456&quot;); SSLServerSocketFactory serverSocketFactory = (SSLServerSocketFactory) SSLServerSocketFactory .getDefault(); SSLServerSocket serverSocket = (SSLServerSocket) serverSocketFactory .createServerSocket(9100); // 要求客户端身份验证 serverSocket.setNeedClientAuth(true); while (true) &#123; SSLSocket socket = (SSLSocket) serverSocket.accept(); Accepter accepter = new Accepter(socket); accepter.service(); &#125; &#125; static class Accepter implements Runnable &#123; private SSLSocket socket; public Accepter(SSLSocket socket) &#123; this.socket = socket; &#125; public void service() &#123; Thread thread = new Thread(this); thread.start(); &#125; @Override public void run() &#123; try &#123; InputStream inputStream = socket.getInputStream(); InputStreamReader inputstreamreader = new InputStreamReader( inputStream); BufferedReader bufferedreader = new BufferedReader( inputstreamreader); String string = null; while ((string = bufferedreader.readLine()) != null) &#123; System.out.println(string); System.out.flush(); &#125; &#125; catch (Exception e) &#123; // replace with other code e.printStackTrace(); &#125; &#125; &#125; &#125; Client代码建立连接，并发一个消息给Server。很简单。记得换行符以及调用flush方法。1234567891011121314151617181920212223public class SslClient &#123; public static void main(String[] args) throws Exception &#123; System.setProperty(&quot;javax.net.debug&quot;, &quot;ssl,handshake&quot;); System.setProperty(&quot;javax.net.ssl.keyStore&quot;, &quot;./cfg/client.jks&quot;); System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, &quot;123456&quot;); System.setProperty(&quot;javax.net.ssl.trustStore&quot;, &quot;./cfg/servertrust.jks&quot;); System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, &quot;123456&quot;); SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory .getDefault(); SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket( &quot;127.0.0.1&quot;, 9100); OutputStream outputStream = sslsocket.getOutputStream(); BufferedWriter bufferedWriter = new BufferedWriter( new OutputStreamWriter(outputStream)); bufferedWriter.write(&quot;沉睡的雄狮\\n&quot;); bufferedWriter.flush(); TimeUnit.SECONDS.sleep(2000); &#125; &#125; 结束语JDK后来加了SSLEngine这个类，具有异步通讯的能力。不过看官方文档，给出的代码很长。还是那句话，有条件的推荐用Netty或者Mina来处理通讯的问题，应该会比自己写的性能好一些。Java官方SSL Socket文档","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"失效的private修饰符","date":"2016-02-12T05:36:47.000Z","path":"2016/02/12/失效的private修饰符/","text":"在Java编程中，使用private关键字修饰了某个成员，只有这个成员所在的类和这个类的方法可以使用，其他的类都无法访问到这个private成员。 上面描述了private修饰符的基本职能，今天来研究一下private功能失效的情况。 Java内部类 在Java中相信很多人都用过内部类，Java允许在一个类里面定义另一个类，类里面的类就是内部类，也叫做嵌套类。一个简单的内部类实现可以如下1234class OuterClass &#123; class InnerClass&#123; &#125;&#125; 今天的问题和Java内部类相关，只涉及到部分和本文研究相关的内部类知识，具体关于Java内部类后续的文章会介绍。 第一次失效? 一个我们在编程中经常用到的场景，就是在一个内部类里面访问外部类的private成员变量或者方法，这是可以的。如下面的代码实现。123456789101112131415161718public class OuterClass &#123; private String language = &quot;en&quot;; private String region = &quot;US&quot;; public class InnerClass &#123; public void printOuterClassPrivateFields() &#123; String fields = &quot;language=&quot; + language + &quot;;region=&quot; + region; System.out.println(fields); &#125; &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.new InnerClass(); inner.printOuterClassPrivateFields(); &#125;&#125; 这是为什么呢，不是private修饰的成员只能被成员所述的类才能访问么？难道private真的失效了么？ 编译器在捣鬼？ 我们使用javap命令查看一下生成的两个class文件 OuterClass的反编译结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454615:30 $ javap -c OuterClassCompiled from &quot;OuterClass.java&quot;public class OuterClass extends java.lang.Object&#123;public OuterClass(); Code: 0: aload_0 1: invokespecial #11; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: ldc #13; //String en 7: putfield #15; //Field language:Ljava/lang/String; 10: aload_0 11: ldc #17; //String US 13: putfield #19; //Field region:Ljava/lang/String; 16: returnpublic static void main(java.lang.String[]); Code: 0: new #1; //class OuterClass 3: dup 4: invokespecial #27; //Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: new #28; //class OuterClass$InnerClass 11: dup 12: aload_1 13: dup 14: invokevirtual #30; //Method java/lang/Object.getClass:()Ljava/lang/Class; 17: pop 18: invokespecial #34; //Method OuterClass$InnerClass.&quot;&lt;init&gt;&quot;:(LOuterClass;)V 21: astore_2 22: aload_2 23: invokevirtual #37; //Method OuterClass$InnerClass.printOuterClassPrivateFields:()V 26: returnstatic java.lang.String access$0(OuterClass); Code: 0: aload_0 1: getfield #15; //Field language:Ljava/lang/String; 4: areturnstatic java.lang.String access$1(OuterClass); Code: 0: aload_0 1: getfield #19; //Field region:Ljava/lang/String; 4: areturn&#125; 咦？不对，在OuterClass中我们并没有定义这两个方法12345678910111213static java.lang.String access$0(OuterClass); Code: 0: aload_0 1: getfield #15; //Field language:Ljava/lang/String; 4: areturnstatic java.lang.String access$1(OuterClass); Code: 0: aload_0 1: getfield #19; //Field region:Ljava/lang/String; 4: areturn&#125; 从给出来的注释来看，access$0返回outerClass的language属性；access$1返回outerClass的region属性。并且这两个方法都接受OuterClass的实例作为参数。这两个方法为什么生成呢，有什么作用呢？我们看一下内部类的反编译结果就知道了。 OuterClass$InnerClass的反编译结果1234567891011121314151617181920212223242526272829303132333435363715:37 $ javap -c OuterClass\\$InnerClassCompiled from &quot;OuterClass.java&quot;public class OuterClass$InnerClass extends java.lang.Object&#123;final OuterClass this$0;public OuterClass$InnerClass(OuterClass); Code: 0: aload_0 1: aload_1 2: putfield #10; //Field this$0:LOuterClass; 5: aload_0 6: invokespecial #12; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: returnpublic void printOuterClassPrivateFields(); Code: 0: new #20; //class java/lang/StringBuilder 3: dup 4: ldc #22; //String language= 6: invokespecial #24; //Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 9: aload_0 10: getfield #10; //Field this$0:LOuterClass; 13: invokestatic #27; //Method OuterClass.access$0:(LOuterClass;)Ljava/lang/String; 16: invokevirtual #33; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: ldc #37; //String ;region= 21: invokevirtual #33; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 24: aload_0 25: getfield #10; //Field this$0:LOuterClass; 28: invokestatic #39; //Method OuterClass.access$1:(LOuterClass;)Ljava/lang/String; 31: invokevirtual #33; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 34: invokevirtual #42; //Method java/lang/StringBuilder.toString:()Ljava/lang/String; 37: astore_1 38: getstatic #46; //Field java/lang/System.out:Ljava/io/PrintStream; 41: aload_1 42: invokevirtual #52; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 45: return&#125; 下面代码调用access$0的代码,其目的是得到OuterClass的language 私有属性。113: invokestatic #27; //Method OuterClass.access$0:(LOuterClass;)Ljava/lang/String; 下面代码调用了access$1的代码，其目的是得到OutherClass的region 私有属性。128: invokestatic #39; //Method OuterClass.access$1:(LOuterClass;)Ljava/lang/String; 注意：在内部类构造的时候，会将外部类的引用传递进来，并且作为内部类的一个属性，所以内部类会持有一个其外部类的引用。this$0就是内部类持有的外部类引用，通过构造方法传递引用并赋值。 12345678910final OuterClass this$0;public OuterClass$InnerClass(OuterClass); Code: 0: aload_0 1: aload_1 2: putfield #10; //Field this$0:LOuterClass; 5: aload_0 6: invokespecial #12; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: return 小结 这部分private看上去失效可，实际上并没有失效，因为当内部类调用外部类的私有属性时，其真正的执行是调用了编译器生成的属性的静态方法（即acess$0,access$1等）来获取这些属性值。这一切都是编译器的特殊处理。这次也失效？ 如果说上面的写法很常用，那么这样的写法是不是很少接触，但是却可以运行。1234567891011public class AnotherOuterClass &#123; public static void main(String[] args) &#123; InnerClass inner = new AnotherOuterClass().new InnerClass(); System.out.println(&quot;InnerClass Filed = &quot; + inner.x); &#125; class InnerClass &#123; private int x = 10; &#125;&#125; 和上面一样，使用javap反编译看一下。不过这次我们先看一下InnerClass的结果12345678910111213141516171819202122232416:03 $ javap -c AnotherOuterClass\\$InnerClassCompiled from &quot;AnotherOuterClass.java&quot;class AnotherOuterClass$InnerClass extends java.lang.Object&#123;final AnotherOuterClass this$0;AnotherOuterClass$InnerClass(AnotherOuterClass); Code: 0: aload_0 1: aload_1 2: putfield #12; //Field this$0:LAnotherOuterClass; 5: aload_0 6: invokespecial #14; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: aload_0 10: bipush 10 12: putfield #17; //Field x:I 15: returnstatic int access$0(AnotherOuterClass$InnerClass); Code: 0: aload_0 1: getfield #17; //Field x:I 4: ireturn&#125; 又出现了，编译器又自动生成了一个获取私有属性的后门方法access$0一次来获取x的值。 AnotherOuterClass.class的反编译结果 1234567891011121314151617181920212223242526272829303132333416:08 $ javap -c AnotherOuterClassCompiled from &quot;AnotherOuterClass.java&quot;public class AnotherOuterClass extends java.lang.Object&#123;public AnotherOuterClass(); Code: 0: aload_0 1: invokespecial #8; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: returnpublic static void main(java.lang.String[]); Code: 0: new #16; //class AnotherOuterClass$InnerClass 3: dup 4: new #1; //class AnotherOuterClass 7: dup 8: invokespecial #18; //Method &quot;&lt;init&gt;&quot;:()V 11: dup 12: invokevirtual #19; //Method java/lang/Object.getClass:()Ljava/lang/Class; 15: pop 16: invokespecial #23; //Method AnotherOuterClass$InnerClass.&quot;&lt;init&gt;&quot;:(LAnotherOuterClass;)V 19: astore_1 20: getstatic #26; //Field java/lang/System.out:Ljava/io/PrintStream; 23: new #32; //class java/lang/StringBuilder 26: dup 27: ldc #34; //String InnerClass Filed = 29: invokespecial #36; //Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 32: aload_1 33: invokestatic #39; //Method AnotherOuterClass$InnerClass.access$0:(LAnotherOuterClass$InnerClass;)I 36: invokevirtual #43; //Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; 39: invokevirtual #47; //Method java/lang/StringBuilder.toString:()Ljava/lang/String; 42: invokevirtual #51; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 45: return&#125; 其中这句调用就是外部类通过内部类的实例获取私有属性x的操作133: invokestatic #39; //Method AnotherOuterClass$InnerClass.access$0:(LAnotherOuterClass$InnerClass;)I 再来个总结其中java官方文档 有这样一句话if the member or constructor is declared private, then access is permitted if and only if it occurs within the body of the top level class (§7.6) that encloses the declaration of the member or constructor. 意思是 如果（内部类的）成员和构造方法设定成了私有修饰符，当且仅当其外部类访问时是允许的。如何让内部类私有成员不被外部访问相信看完上面两部分，你会觉得，内部类的私有成员想不被外部类访问都很困难吧，谁让编译器“爱管闲事”呢，其实也是可以做到的。那就是使用匿名内部类。由于mRunnable对象的类型为Runnable，而不是匿名内部类的类型（我们无法正常拿到），而Runanble中没有x这个属性，所以mRunnable.x是不被允许的。123456789101112131415public class PrivateToOuter &#123; Runnable mRunnable = new Runnable()&#123; private int x=10; @Override public void run() &#123; System.out.println(x); &#125; &#125;; public static void main(String[] args)&#123; PrivateToOuter p = new PrivateToOuter(); //System.out.println(&quot;anonymous class private filed= &quot;+ p.mRunnable.x); //not allowed p.mRunnable.run(); // allowed &#125;&#125; 最后总结在本文中，private表面上看上去失效了，但实际上是没有的，而是在调用时通过间接的方法来获取私有的属性。Java的内部类构造时持有对外部类的应用，C++不会，这一点和C++不一样。 深入Java细节的书籍Java编程思想Sun 公司核心技术丛书:Effective Java中文版深入理解Java虚拟机:JVM高级特性与最佳实践","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"View的scrollTo()和scrollBy()区别","date":"2016-01-02T06:04:33.000Z","path":"2016/01/02/View的scrollTo-和scrollBy-区别/","text":"首先，需要知道的是，View是可以延伸到屏幕之外的，可以想象一下ListVIew或GridView。也就是说View的尺寸可以超过屏幕的尺寸。View的大小就是onDraw()中Canvas画布的大小。Canvas可以做translate()、clipRec()t等变换，可以说Canvas是无边界的。而我们在屏幕上所见到的，只是Canvas的一部分而已。可以调用View的scrollTo()和scrollBy()将视图绘制到指定区域。那么View中的scrollTo()和scrollBy()又是怎么回事呢？要想一探究竟，就需要研究一下View的源码。在View的源码中，mScrollX和mScrollY是视图在X轴和Y轴的偏移量。源码注释说的非常清楚mScrollX和mScrollY代表的是什么。1234567891011121314151617181920212223242526272829303132333435363738/** * The offset, in pixels, by which the content of this view is scrolled * horizontally. * &#123;@hide&#125; */@ViewDebug.ExportedProperty(category = &quot;scrolling&quot;)protected int mScrollX;/** * The offset, in pixels, by which the content of this view is scrolled * vertically. * &#123;@hide&#125; */@ViewDebug.ExportedProperty(category = &quot;scrolling&quot;)protected int mScrollY; /** * Return the scrolled left position of this view. This is the left edge of * the displayed part of your view. You do not need to draw any pixels * farther left, since those are outside of the frame of your view on * screen. * * @return The left edge of the displayed part of your view, in pixels. */public final int getScrollX() &#123; return mScrollX;&#125;/** * Return the scrolled top position of this view. This is the top edge of * the displayed part of your view. You do not need to draw any pixels above * it, since those are outside of the frame of your view on screen. * * @return The top edge of the displayed part of your view, in pixels. */public final int getScrollY() &#123; return mScrollY;&#125; 知道了mScrollX和mScrollY的含义，接下来再看scrollTo()和scrollBy()的具体实现，代码如下：123456789101112131415161718192021222324252627282930/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; invalidate(); &#125; &#125;&#125;/** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; 从源码中可以看到，scrollBy()的内部其实是调用了scrollTo()。在scrollTo()中，调用了onScrollChanged()和invalidate()。onScrollChanged()的作用就是告诉系统（可以理解为Android框架），这个View的scrollTo()或scrollBy()曾经被调用过；而invalidate()是告诉系统，这个View需要被重新绘制。接下来，探究一下onScrollChanged()和invalidate()的具体实现，代码如下：12345678910111213141516171819/** * This is called in response to an internal scroll in this view (i.e., the * view scrolled its own contents). This is typically as a result of * &#123;@link #scrollBy(int, int)&#125; or &#123;@link #scrollTo(int, int)&#125; having been * called. * * @param l Current horizontal scroll origin. * @param t Current vertical scroll origin. * @param oldl Previous horizontal scroll origin. * @param oldt Previous vertical scroll origin. */protected void onScrollChanged(int l, int t, int oldl, int oldt) &#123; mBackgroundSizeChanged = true; final AttachInfo ai = mAttachInfo; if (ai != null) &#123; ai.mViewScrollChanged = true; &#125;&#125; /** * Invalidate the whole view. If the view is visible, {@link #onDraw} will * be called at some point in the future. This must be called from a * UI thread. To call from a non-UI thread, call {@link #postInvalidate()}. */ public void invalidate() { if (ViewDebug.TRACE_HIERARCHY) { ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE); } if ((mPrivateFlags &amp; (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS)) { mPrivateFlags &amp;= ~DRAWN &amp; ~DRAWING_CACHE_VALID; final ViewParent p = mParent; final AttachInfo ai = mAttachInfo; if (p != null &amp;&amp; ai != null) { final Rect r = ai.mTmpInvalRect; r.set(0, 0, mRight - mLeft, mBottom - mTop); // Don&apos;t call invalidate -- we don&apos;t want to internally scroll // our own bounds p.invalidateChild(this, r); } } } 知道了scrollTo()和scrollBy()的意义，那么举个例子，感性地认识一下。假设有一个View，它叫做SView。如果想把SView从(0, 0)移动到(100, 100)。注意，这里说的(0, 0)和(100, 100)，指的是SView左上角的坐标。那么偏移量就是原点(0, 0)到目标点(100, 100)的距离，即(0 , 0) - (100, 100) = (-100, -100)。只需要调用SView.scrollTo(-100, -100)就可以了。请再次注意，scrollTo(int x, int y)的两个参数x和y，代表的是偏移量，这时的参照物是(0, 0)点。然而，scrollBy()是有一定的区别的。scrollBy()的参照物是(0, 0)点加上偏移量之后的坐标。这么描述比较抽象，举个例子。假设SView调用了scrollTo(-100, -100)，此时SView左上角的坐标是(100, 100)，这时再调用scrollBy(-20, -20)，此时SView的左上角就被绘制到了(120, 120)这个位置。总结一下，scrollTo()是一步到位，而scrollBy()是逐步累加。 那么mScrollX和mScrollY又是在哪里被使用的呢？上面说过，scrollTo()会使视图重绘，那究竟是如何绘制的？请看draw()方法，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, do not override this method; instead, * you should implement &#123;@link #onDraw&#125;. * * @param canvas The Canvas to which the View is rendered. */public void draw(Canvas canvas) &#123; if (ViewDebug.TRACE_HIERARCHY) &#123; ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW); &#125; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&apos; layers to prepare for fading * 3. Draw view&apos;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; final Drawable background = mBGDrawable; if (background != null) &#123; final int scrollX = mScrollX; final int scrollY = mScrollY; if (mBackgroundSizeChanged) &#123; background.setBounds(0, 0, mRight - mLeft, mBottom - mTop); mBackgroundSizeChanged = false; &#125; if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125; &#125; &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); // we&apos;re done... return; &#125; /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ boolean drawTop = false; boolean drawBottom = false; boolean drawLeft = false; boolean drawRight = false; float topFadeStrength = 0.0f; float bottomFadeStrength = 0.0f; float leftFadeStrength = 0.0f; float rightFadeStrength = 0.0f; // Step 2, save the canvas&apos; layers int paddingLeft = mPaddingLeft; int paddingTop = mPaddingTop; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) &#123; paddingLeft += getLeftPaddingOffset(); paddingTop += getTopPaddingOffset(); &#125; int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + paddingTop; int bottom = top + mBottom - mTop - mPaddingBottom - paddingTop; if (offsetRequired) &#123; right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); &#125; final ScrollabilityCache scrollabilityCache = mScrollCache; int length = scrollabilityCache.fadingEdgeLength; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123; length = (bottom - top) / 2; &#125; // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123; length = (right - left) / 2; &#125; if (verticalEdges) &#123; topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength &gt;= 0.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength &gt;= 0.0f; &#125; if (horizontalEdges) &#123; leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength &gt;= 0.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength &gt;= 0.0f; &#125; saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; if (drawBottom) &#123; canvas.saveLayer(left, bottom - length, right, bottom, null, flags); &#125; if (drawLeft) &#123; canvas.saveLayer(left, top, left + length, bottom, null, flags); &#125; if (drawRight) &#123; canvas.saveLayer(right - length, top, right, bottom, null, flags); &#125; &#125; else &#123; scrollabilityCache.setFadeColor(solidColor); &#125; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; final float fadeHeight = scrollabilityCache.fadingEdgeLength; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); canvas.drawRect(left, top, right, top + length, p); &#125; if (drawBottom) &#123; matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); canvas.drawRect(left, bottom - length, right, bottom, p); &#125; if (drawLeft) &#123; matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); canvas.drawRect(left, top, left + length, bottom, p); &#125; if (drawRight) &#123; matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); canvas.drawRect(right - length, top, right, bottom, p); &#125; canvas.restoreToCount(saveCount); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas);&#125; 参考资料http://blog.csdn.net/qinjuning/article/details/7247126http://blog.csdn.net/vipzjyno1/article/details/24577023http://blog.csdn.net/xiaoguochang/article/details/8655210http://developer.android.com/reference/android/view/View.html#scrollTo%28int,%20int%29","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"Android studio关于build/outputs/apk/中apk或arr或jar无法删除的解决方法","date":"2015-12-12T15:27:49.000Z","path":"2015/12/12/Android-studio关于build-outputs-apk-中apk或arr或jar无法删除的解决方法/","text":"android studio关于build/outputs/apk/中apk或arr或jar无法删除的解决方法Error:Execution failed for task ‘:app:clean’.&gt; Unable to delete file 后面的文件地址，可能是apk，可能是arr，也可能是classes.jar 在使用Android Studio开发时，部分朋友会遇到这个问题，但是又不是每个人都会遇到。而我则是经常遇到，经过长期开机关机的方式来删除build后，终于决定解决这个问题。还是不负有心人啊，终于找到解决方案，在此分享给大家。其实解决不难，只要2步即可。1、下载工具LockHunter.exe，下载地址：http://pan.baidu.com/s/1bpFlPL12、在Android Studio中的build.gradle中配置：task clean(type: Exec) { ext.lockhunter = ‘\\”C:\\Program Files\\LockHunter\\LockHunter.exe\\“‘ def buildDir = file(new File(“build”)) commandLine ‘cmd’, “$lockhunter”, ‘/delete’, ‘/silent’, buildDir}备注：ext.lockhunter 是你安装lockhunter的地址。 写进的build.gradle是写在应用APP里面的，而不是项目的。 —————————分割线———————————————————–有部分朋友使用上述方法还是不能成功，请接着看： 在出现问题的时候，点击build，同时把手机拔掉，卸载APP，然后插回，在AS上再运行重装。 如果这个方法还不行，那么请把瞬时启动关闭。具体位置： 两个方法一起使用，必定成功。","tags":[{"name":"安卓","slug":"安卓","permalink":"http://samychen.com/tags/安卓/"}]},{"title":"ListView源码分析（二）","date":"2015-09-26T05:15:15.000Z","path":"2015/09/26/ListView源码分析（二）/","text":"ListView的setAdapter实现查看GrepCode网站ListView源码发现setAdapter主要有以下几个重要方法： layoutChildren，fillFromTop，fillDown /fillUpmakeAndAddView，obtainView，setupChild 先简单看下layoutChildren源码1234567891011121314151617181920212223242526272829303132@Override protected void layoutChildren() &#123; ......... boolean dataChanged = mDataChanged; if (dataChanged) &#123; handleDataChanged(); &#125; ......... // Clear out old views detachAllViewsFromParent(); switch (mLayoutMode) &#123; ......... case LAYOUT_FORCE_BOTTOM: sel = fillUp(mItemCount - 1, childrenBottom); adjustViewsUpOrDown(); break; case LAYOUT_FORCE_TOP: mFirstPosition = 0; sel = fillFromTop(childrenTop); adjustViewsUpOrDown(); break; ......... &#125; ......... &#125; setAdapter之后dataChanged为true，执行handleDataChanged()方法。1234567891011121314@Override protected void handleDataChanged() &#123; ......... // Nothing is selected. Give up and reset everything. mLayoutMode = mStackFromBottom ? LAYOUT_FORCE_BOTTOM : LAYOUT_FORCE_TOP; mSelectedPosition = INVALID_POSITION; mSelectedRowId = INVALID_ROW_ID; mNextSelectedPosition = INVALID_POSITION; mNextSelectedRowId = INVALID_ROW_ID; mNeedSync = false; mSelectorPosition = INVALID_POSITION; checkSelectionChanged(); &#125; 注意这个方法注意是设置mLayoutMode，通常是LAYOUT_FORCE_TOP，即从顶部开始一个一个的往下添加childview。&emsp;&emsp;布局中ListView默认没有设置android:stackfrombottom属性，因此回到layoutChildren()方法中，执行LAYOUT_FORCE_TOP条件语句，设置mFirstPosition=0后，将childrenTop(=0或padding top 后的值)，进入fillFromTop方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Fills the list from top to bottom, starting with mFirstPosition * * @param nextTop The location where the top of the first item should be * drawn * * @return The view that is currently selected */ private View fillFromTop(int nextTop) &#123; mFirstPosition = Math.min(mFirstPosition, mSelectedPosition); mFirstPosition = Math.min(mFirstPosition, mItemCount - 1); if (mFirstPosition &lt; 0) &#123; mFirstPosition = 0; &#125; return fillDown(mFirstPosition, nextTop); &#125; /** * Fills the list from pos down to the end of the list view. * * @param pos The first position to put in the list * * @param nextTop The location where the top of the item associated with pos * should be drawn * * @return The view that is currently selected, if it happens to be in the * range that we draw. */ //第一次进来pos = 0，nexttop 是 padding.top private View fillDown(int pos, int nextTop) &#123; View selectedView = null; int end = (mBottom - mTop);//可视区高度 if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; end -= mListPadding.bottom;//减去paddingbotton属性值 &#125; while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123; // is this the selected item? boolean selected = pos == mSelectedPosition; View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected); nextTop = child.getBottom() + mDividerHeight; if (selected) &#123; selectedView = child; &#125; pos++; &#125; return selectedView; &#125; 可视区域的高度(mBottom - mTop)，如果ListView条目很少，可视区高度不超过屏幕高度，最大不超过屏幕高度。&emsp;&emsp;while循环中，判断累计添加到listview中child的高度，不超过可视区域（添加最后一个child时，有可能只显示部分），且添加的child的下标不超过总的个数（否则系统会报 OutOfBounds 的异常）。在循环中，会去调用makeAndAddView，这个方法不会真正的去添加child，但会调用之后的setupChild来真正添加到listview中：123456789101112131415161718192021222324252627282930313233343536373839404142/** * Obtain the view and add it to our list of children. The view can be made * fresh, converted from an unused view, or used as is if it was in the * recycle bin. * * @param position Logical position in the list * @param y Top or bottom edge of the view to add * @param flow If flow is true, align top edge to y. If false, align bottom * edge to y. * @param childrenLeft Left edge where children should be positioned * @param selected Is this position selected? * @return View that was added */ private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; View child; //两种情况：1.数据源没有发生改变 2.数据源发生改变 if (!mDataChanged) &#123; // Try to use an existing view for this position child = mRecycler.getActiveView(position); if (child != null) &#123; if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(child, ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP, position, getChildCount()); &#125; // Found it -- we&apos;re using an existing child // This just needs to be positioned setupChild(child, position, y, flow, childrenLeft, selected, true); return child;//数据源没有发生改变，调用mRecycler.getActiveView(position); &#125; &#125; // Make a new view for this position, or convert an unused view if possible child = obtainView(position, mIsScrap);//数据源发生改变，调用obtainView() // This needs to be positioned and measured setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child; &#125; 该方法分两种情况： adapter中的数据发生了变化，初始setAdapter，或之后我们将adapter中的数据做了新增/删除后，调用Adapter.notifyDataSetChanged；变化了，就会从RecycleBin中的mScrapView中，取之前滑出屏幕的view，即convertView来复用； 若没有变化，则从RecycleBin的mActiveView中取当前显示的view（ 为啥会有这种情况？当listview稳定后，我们不滚动它，但有可能点击或长按 ），这时就会走到这里。&emsp;&emsp;obtainView就是从RecycleBin中，取移出去的View，传给Adapter.getView方法（convertView）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*** Get a view and have it show the data associated with the specified * position. This is called when we have already discovered that the view is * not available for reuse in the recycle bin. The only choices left are * converting an old view or making a new one. * * @param position The position to display * @param isScrap Array of at least 1 boolean, the first entry will become true if * the returned view was taken from the scrap heap, false if otherwise. * * @return A view displaying the data associated with the specified position */ View obtainView(int position, boolean[] isScrap) &#123; isScrap[0] = false; View scrapView; scrapView = mRecycler.getScrapView(position);//获取scrapView View child; if (scrapView != null) &#123;//如果缓存中有，将这个convertView传给Adapter.getView方法 if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(scrapView, ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP, position, -1); &#125; child = mAdapter.getView(position, scrapView, this); if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(child, ViewDebug.RecyclerTraceType.BIND_VIEW, position, getChildCount()); &#125; if (child != scrapView) &#123;//判断从getView方法中返回的view是否与scrapview一致 //如果一致，表明是复用的，反之，则程序又去创建了一个新的view（浪费了一块内存），且将得到的scrapview重新加入到RecycleBin.mScrapView中； mRecycler.addScrapView(scrapView, position); if (mCacheColorHint != 0) &#123; child.setDrawingCacheBackgroundColor(mCacheColorHint); &#125; if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(scrapView, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, position, -1); &#125; &#125; else &#123; isScrap[0] = true; child.dispatchFinishTemporaryDetach(); &#125; &#125; else &#123;//如果缓存中没有，则convertView为null，在Adapter中，需要自己去LayoutInflater一个view child = mAdapter.getView(position, null, this); if (mCacheColorHint != 0) &#123; child.setDrawingCacheBackgroundColor(mCacheColorHint); &#125; if (ViewDebug.TRACE_RECYCLER) &#123; ViewDebug.trace(child, ViewDebug.RecyclerTraceType.NEW_VIEW, position, getChildCount()); &#125; &#125; return child; &#125; 这个方法，实际上是在AbsListView类中的。RecycleBin类，它的作用就是一个View的缓存，将移出屏幕外的view回收，并给新移入到屏幕内的view来复用，这样就能节省大量内存。 回到makeAndAddView方法，将child传给setupChild，开始真正的加入到listView中去显示。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Add a view as a child and make sure it is measured (if necessary) and * positioned properly. * * @param child The view to add * @param position The position of this child * @param y The y position relative to which this view will be positioned * @param flowDown If true, align top edge to y. If false, align bottom * edge to y. * @param childrenLeft Left edge where children should be positioned * @param selected Is this position selected? * @param recycled Has this view been pulled from the recycle bin? If so it * does not need to be remeasured. */private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,boolean selected, boolean recycled) &#123; final boolean isSelected = selected &amp;&amp; shouldShowSelector(); final boolean updateChildSelected = isSelected != child.isSelected(); final int mode = mTouchMode; final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp; mMotionPosition == position; final boolean updateChildPressed = isPressed != child.isPressed(); final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested(); // Respect layout params that are already in the view. Otherwise make some up... // noinspection unchecked AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams(); if (p == null) &#123; p = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0); &#125; p.viewType = mAdapter.getItemViewType(position); if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123; attachViewToParent(child, flowDown ? -1 : 0, p); &#125; else &#123; p.forceAdd = false; if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; p.recycledHeaderFooter = true; &#125; addViewInLayout(child, flowDown ? -1 : 0, p, true); &#125; if (updateChildSelected) &#123; child.setSelected(isSelected); &#125; if (updateChildPressed) &#123; child.setPressed(isPressed); &#125; if (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mCheckStates != null) &#123; if (child instanceof Checkable) &#123; ((Checkable) child).setChecked(mCheckStates.get(position)); &#125; else if (getContext().getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123; child.setActivated(mCheckStates.get(position)); &#125; &#125; //如果需要测量,先测量子view if (needToMeasure) &#123; int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, mListPadding.left + mListPadding.right, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125; else &#123; cleanupLayoutState(child); &#125; final int w = child.getMeasuredWidth(); final int h = child.getMeasuredHeight(); final int childTop = flowDown ? y : y - h; if (needToMeasure) &#123; final int childRight = childrenLeft + w; final int childBottom = childTop + h; child.layout(childrenLeft, childTop, childRight, childBottom); &#125; else &#123; child.offsetLeftAndRight(childrenLeft - child.getLeft()); child.offsetTopAndBottom(childTop - child.getTop()); &#125; if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123; child.setDrawingCacheEnabled(true); &#125; if (recycled &amp;&amp; (((AbsListView.LayoutParams)child.getLayoutParams()).scrappedFromPosition) != position) &#123; child.jumpDrawablesToCurrentState(); &#125; &#125; &emsp;&emsp;attachViewToParent 和 addViewInLayout两者大致差不多，都是将view添加到parent view的array中，区别在于，attachView是不用去requestLayout的，而addViewInLayout的最后一个参数指明（true不用requestLayout，false则需要requestLayout），这两个方法都在ViewGroup中。&emsp;&emsp;flowDown ? -1 : 0 ， -1 和 0 的区别？我们看下attachViewToParent代码吧：12345678910111213141516171819202122232425262728293031323334/** * Attaches a view to this view group. Attaching a view assigns this group as the parent, * sets the layout parameters and puts the view in the list of children so it can be retrieved * by calling &#123;@link #getChildAt(int)&#125;. * * This method should be called only for view which were detached from their parent. * * @param child the child to attach * @param index the index at which the child should be attached * @param params the layout parameters of the child * * @see #removeDetachedView(View, boolean) * @see #detachAllViewsFromParent() * @see #detachViewFromParent(View) * @see #detachViewFromParent(int) */ protected void attachViewToParent(View child, int index, LayoutParams params) &#123; child.mLayoutParams = params; if (index &lt; 0) &#123; index = mChildrenCount; &#125; addInArray(child, index); child.mParent = this; child.mPrivateFlags = (child.mPrivateFlags &amp; ~DIRTY_MASK &amp; ~DRAWING_CACHE_VALID) | DRAWN | INVALIDATED; this.mPrivateFlags |= INVALIDATED; if (child.hasFocus()) &#123; requestChildFocus(child, child.findFocus()); &#125; &#125; 如果是-1，则将index = mChildrenCount，即从当前child view数组的尾部开始加入，如果是0， 则从当前child view的头部开始加入。&emsp;&emsp;默认情况下，添加到listview中的item，即child都会measure一次高度和宽度，然后，调用child.layout，通知新添加的child，layout一下它里面的children。&emsp;&emsp;然后，然后就没有了然后，整个流程走完，回到ListView.layoutChildren中，adjustViewsUpOrDown将所有child调整对齐，刷新一下RecycleBin的Active和Scrap缓存，调用updateScrollIndicators更新一下滚动条的值，若有注意OnScrollListener，也通知一下invokeOnItemScrollListener。","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"ListView源码分析(一)","date":"2015-09-12T05:12:23.000Z","path":"2015/09/12/ListView源码分析（一）/","text":"&emsp;&emsp;这几天把ListView源码看了下，基本整理下思路并写了这篇博客，也是对学习源码的一个记录。 首先看ListView的构造方法干了些什么12345678910111213141516171819202122232425262728293031323334353637383940414243public ListView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle);//父类AbsListview中初始化一些属性，比如焦点setFocusableInTouchMode（true），绘制setWillNotDraw(false)等 TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.ListView, defStyle, 0); CharSequence[] entries = a.getTextArray( com.android.internal.R.styleable.ListView_entries); if (entries != null) &#123; setAdapter(new ArrayAdapter&lt;CharSequence&gt;(context, com.android.internal.R.layout.simple_list_item_1, entries)); &#125; //获取item分割线 drawable 可以自定义 final Drawable d = a.getDrawable(com.android.internal.R.styleable.ListView_divider); if (d != null) &#123; // If a divider is specified use its intrinsic height for divider height setDivider(d); &#125; //头部样式 final Drawable osHeader = a.getDrawable( com.android.internal.R.styleable.ListView_overScrollHeader); if (osHeader != null) &#123; setOverscrollHeader(osHeader); &#125; //尾部样式 final Drawable osFooter = a.getDrawable( com.android.internal.R.styleable.ListView_overScrollFooter); if (osFooter != null) &#123; setOverscrollFooter(osFooter); &#125; // Use the height specified, zero being the default final int dividerHeight = a.getDimensionPixelSize( com.android.internal.R.styleable.ListView_dividerHeight, 0); if (dividerHeight != 0) &#123; setDividerHeight(dividerHeight); &#125; mHeaderDividersEnabled = a.getBoolean(R.styleable.ListView_headerDividersEnabled, true); mFooterDividersEnabled = a.getBoolean(R.styleable.ListView_footerDividersEnabled, true); a.recycle(); &#125; 上面构造方法做了一些初始化工作，并设置了默认样式 ####onMeasure()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Sets up mListPadding super.onMeasure(widthMeasureSpec, heightMeasureSpec); //格式化并取出MeasureSpec的模式和测量值大小 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childWidth = 0; int childHeight = 0; int childState = 0; mItemCount = mAdapter == null ? 0 : mAdapter.getCount(); if (mItemCount &gt; 0 &amp;&amp; (widthMode == MeasureSpec.UNSPECIFIED ||heightMode == MeasureSpec.UNSPECIFIED)) &#123; final View child = obtainView(0, mIsScrap); //测量childview measureScrapChild(child, 0, widthMeasureSpec); childWidth = child.getMeasuredWidth(); childHeight = child.getMeasuredHeight(); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (recycleOnMeasure() &amp;&amp; mRecycler.shouldRecycleViewType( ((LayoutParams) child.getLayoutParams()).viewType)) &#123; mRecycler.addScrapView(child, -1); &#125; &#125; if (widthMode == MeasureSpec.UNSPECIFIED) &#123; widthSize = mListPadding.left + mListPadding.right + childWidth + getVerticalScrollbarWidth(); &#125; else &#123; widthSize |= (childState&amp;MEASURED_STATE_MASK); &#125; if (heightMode == MeasureSpec.UNSPECIFIED) &#123; heightSize = mListPadding.top + mListPadding.bottom + childHeight + getVerticalFadingEdgeLength() * 2; &#125; if (heightMode == MeasureSpec.AT_MOST) &#123; // TODO: after first layout we should maybe start at the first visible position, not 0 heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1); &#125; setMeasuredDimension(widthSize , heightSize); mWidthMeasureSpec = widthMeasureSpec; &#125;private void measureScrapChild(View child, int position, int widthMeasureSpec) &#123; LayoutParams p = (LayoutParams) child.getLayoutParams(); if (p == null) &#123; p = (AbsListView.LayoutParams) generateDefaultLayoutParams(); child.setLayoutParams(p); &#125; p.viewType = mAdapter.getItemViewType(position); p.forceAdd = true; int childWidthSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, mListPadding.left + mListPadding.right, p.width); int lpHeight = p.height; int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); &#125; 上述操作对ListView的测量并赋值给成员变量 ，注意ListView第一次创建的时候并没有mAdapter的存在,只有在setAdapter被我们调用过后才会执行这些方法,也就是说在setAdapter中一定会调用requestLayout方法重新走一遍流程。 ####onLayout方法 &emsp;&emsp;ListView中并没有onLayout方法,那也就是说一定是在他的父类AbsListView中,我们可以看到它调用了layoutChildren(),从方法名看应该是对子view进行布局,这个layoutChildren是一个空实现方法,也就是说应该是通过AbsListView的子类ListVIew和GridView进行实现123456789101112131415161718192021222324protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mInLayout = true; //拿到view 数量 final int childCount = getChildCount(); if (changed) &#123; for (int i = 0; i &lt; childCount; i++) &#123; getChildAt(i).forceLayout(); &#125; mRecycler.markChildrenDirty(); &#125; // 由子类ListView 和 GridView实现,是核心布局方法代码,也是listview与adapter交互数据的主要入口函数 layoutChildren(); mInLayout = false; mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR; // TODO: Move somewhere sane. This doesn&apos;t belong in onLayout(). if (mFastScroll != null) &#123; mFastScroll.onItemCountChanged(getChildCount(), mItemCount); &#125; &#125; 这里注意两个对象： View[] mActiveViews:存放的是当前ListView可以使用的待激活的子item view ArrayList[] mScrapViews:存放的是在ListView滑动过程中滑出屏幕来回收以便下次利用的子item view 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Override protected void layoutChildren() &#123; ... final int firstPosition = mFirstPosition; final RecycleBin recycleBin = mRecycler; // 只有在调用adapter.notifyDatasetChanged()方法一直到layout()布局结束, //dataChanged为true,默认为false,这里如果调用notifyDatasetChanged,就会将Item添加到ReyclerBin当中,这个 //ReyclerBin封装了这两个集合用来存放对应的符合条件的item,用来实现复用机制 //1.View[] mActiveViews : 存放的是当前ListView可以使用的待激活的子item view //2.ArrayList&lt;View&gt;[] mScrapViews : 存放的是在ListView滑动过程中滑出屏幕来回收以便下次利用的子item view if (dataChanged) &#123; // dataChanged为true,说明当前listview是有数据的了,把当前所有的item view // 存放到RecycleBin对象的mScrapViews中保存 for (int i = 0; i &lt; childCount; i++) &#123; recycleBin.addScrapView(getChildAt(i), firstPosition+i); &#125; &#125; else &#123; // dataChanged默认为false,第一次执行此方法走这里 //将view添加到 activeViews[] 中 recycleBin.fillActiveViews(childCount, firstPosition); &#125; ... switch (mLayoutMode) &#123; ... default: //一般情况下走这里 if (childCount == 0) &#123; // 第一次布局的时候,因为还没有setAdapter,没有走mAdpate.getCount方法,所以childCount必然为0 if (!mStackFromBottom) &#123; final int position = lookForSelectablePosition(0, true); setSelectedPositionInt(position); // 从上到上布局listview能显示得下的子view,具体的填充view的方法,下面讲到 sel = fillFromTop(childrenTop); &#125; else &#123; final int position = lookForSelectablePosition(mItemCount - 1, false); setSelectedPositionInt(position); sel = fillUp(mItemCount - 1, childrenBottom); &#125; &#125; else &#123; // 非第一次layout,也就说执行了nitifyDatasetChanged方法之后 if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123; sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop()); &#125; else if (mFirstPosition &lt; mItemCount) &#123; // 通常情况走这里,fillSpecific()会调用fillUp()和fillDown()布局子view sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop()); &#125; else &#123; sel = fillSpecific(0, childrenTop); &#125; &#125; break; &#125; //到这里,ListView中的view就被填充完毕. ... //布局完成之后记录状态 mLayoutMode = LAYOUT_NORMAL; mDataChanged = false; &#125; Item布局的填充在layoutChidren中有几个以fill开头的方法就是具体的Item的填充方法。fillSpecific()会根据mStackFromBottom参数判断填充方向,通过fillUp,fillDown进行填充123456789101112131415161718192021222324252627282930313233343536373839404142private View fillSpecific(int position, int top) &#123; boolean tempIsSelected = position == mSelectedPosition; View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected); // Possibly changed again in fillUp if we add rows above this one. mFirstPosition = position; View above; View below; final int dividerHeight = mDividerHeight; //根据填充方向,如果mStackFromBottom为false,表示从顶部向底部填充,true反之 //mStackFromBottom 可以通过 xml文件android:stackFromBottom=&quot;false&quot;设置,默认为false if (!mStackFromBottom) &#123; //具体填充方法 above = fillUp(position - 1, temp.getTop() - dividerHeight); // This will correct for the top of the first view not touching the top of the list adjustViewsUpOrDown(); //具体填充方法 below = fillDown(position + 1, temp.getBottom() + dividerHeight); int childCount = getChildCount(); if (childCount &gt; 0) &#123; correctTooHigh(childCount); &#125; &#125; else &#123; below = fillDown(position + 1, temp.getBottom() + dividerHeight); // This will correct for the bottom of the last view not touching the bottom of the list adjustViewsUpOrDown(); above = fillUp(position - 1, temp.getTop() - dividerHeight); int childCount = getChildCount(); if (childCount &gt; 0) &#123; correctTooLow(childCount); &#125; &#125; if (tempIsSelected) &#123; return temp; &#125; else if (above != null) &#123; return above; &#125; else &#123; return below; &#125;&#125; 具体填充布局可以看我的另一篇博客ListView源码分析(二) ####setAdaptersetAdapter中通过mAdapter.registerDataSetObserver(mDataSetObserver)注册一个AdapterDataSetObserver订阅者，每当调用notifyDataSetChange的时候,就会触发AdapterDataSetObserver的onChanged的方法,这个是观察者模式，这个方法最终调用requestLayout方法，也就是说我们每次setAdapter之后就会重新布局,这时候mAdapter不为空。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Overridepublic void setAdapter(ListAdapter adapter) &#123; if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mAdapter.unregisterDataSetObserver(mDataSetObserver); //将一些成员变量还原设置为初始默认值 //mLayoutMode = LAYOUT_NORMAL resetList(); // mRecycler的mScrapViews清空并执行listview.removeDetachedView //mScrapViews 存放边界之外的view mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; // 如果listview有headerView或者FooterView则会生成包装adapter,生成一个含有HeaderView 和footerView的adapter mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; mAdapter = adapter; &#125; mOldSelectedPosition = INVALID_POSITION;//-1 mOldSelectedRowId = INVALID_ROW_ID;//Long.MIN_VALUE // AbsListView#setAdapter will update choice mode states. //给父亲 adblistView 设置 adapter super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; //调用adapter的getCount 得到条目个数 mItemCount = mAdapter.getCount(); checkFocus(); //注册观察者,这个观察者每当调用notifyDataSetChange的时候就会触发 mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); // 设置listview的数据源类型,并在mRecycler中初始化对应个数的scrapViews list mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; if (mStackFromBottom) &#123; position = lookForSelectablePosition(mItemCount - 1, false); &#125; else &#123; position = lookForSelectablePosition(0, true); &#125; setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) &#123; // Nothing selected checkSelectionChanged(); &#125; &#125; else &#123; mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); &#125; // 会调用顶层viewRootImpl.performTraversals(),导致视图重绘,listview刷新 requestLayout();&#125; ####notifyDataSetChanged这个方法在BaseAdapter中123public void notifyDataSetChanged() &#123; mDataSetObservable.notifyChanged();&#125; 这时候根据观察者模式,会调用订阅者AdapterDataSetObserver的onChanged方法,上面提到过,最终还是会调用requestLayout进行重新布局1234567891011121314151617181920@Overridepublic void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); // 同样,最终调用viewRootImpl.performTraversals(),导致视图重绘,执行listview的 // measure layout 方法等 requestLayout();&#125;","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"Java中用内存映射处理大文件","date":"2015-09-05T05:42:52.000Z","path":"2015/09/05/Java中用内存映射处理大文件/","text":"在处理大文件时，如果利用普通的FileInputStream 或者FileOutputStream 抑或RandomAccessFile 来进行频繁的读写操作，都将导致进程因频繁读写外存而降低速度.如下为一个对比实验。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class Test &#123;public static void main(String[] args) &#123;try &#123;FileInputStream fis=new FileInputStream(&quot;/home/tobacco/test/res.txt&quot;);int sum=0;int n;long t1=System.currentTimeMillis();try &#123;while((n=fis.read())&gt;=0)&#123;sum+=n;&#125;&#125; catch (IOException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;long t=System.currentTimeMillis()-t1;System.out.println(&quot;sum:&quot;+sum+&quot; time:&quot;+t);&#125; catch (FileNotFoundException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;try &#123;FileInputStream fis=new FileInputStream(&quot;/home/tobacco/test/res.txt&quot;);BufferedInputStream bis=new BufferedInputStream(fis);int sum=0;int n;long t1=System.currentTimeMillis();try &#123;while((n=bis.read())&gt;=0)&#123;sum+=n;&#125;&#125; catch (IOException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;long t=System.currentTimeMillis()-t1;System.out.println(&quot;sum:&quot;+sum+&quot; time:&quot;+t);&#125; catch (FileNotFoundException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;MappedByteBuffer buffer=null;try &#123;buffer=new RandomAccessFile(&quot;/home/tobacco/test/res.txt&quot;,&quot;rw&quot;).getChannel().map(FileChannel.MapMode.READ_WRITE, 0, 1253244);int sum=0;int n;long t1=System.currentTimeMillis();for(int i=0;i&lt;1253244;i++)&#123;n=0x000000ff&amp;buffer.get(i);sum+=n;&#125;long t=System.currentTimeMillis()-t1;System.out.println(&quot;sum:&quot;+sum+&quot; time:&quot;+t);&#125; catch (FileNotFoundException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125; catch (IOException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;&#125;&#125; 测试文件为一个大小为1253244字节的文件。测试结果： sum:220152087 time:1464 sum:220152087 time:72 sum:220152087 time:25 说明读数据无误。删去其中的数据处理部分,即注销掉sum+=n和n=0x000000ff&amp;buffer.get(i); 测试结果： sum:0 time:1458 sum:0 time:67 sum:0 time:8 由此可见，将文件部分或者全部映射到内存后进行读写，速度将提高很多。 这是因为内存映射文件首先将外存上的文件映射到内存中的一块连续区域，被当成一个字节数组进行处理，读写操作直接对内存进行操作，而后再将内存区域重新映射到外存文件，这就节省了中间频繁的对外存进行读写的时间，大大降低了读写时间。","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"Java Socket编程","date":"2015-04-02T14:34:39.000Z","path":"2015/04/02/Java-Socket编程/","text":"服务器端123456789101112131415161718192021222324[java] view plain copy print?package org.zbq; import java.net.ServerSocket; import java.net.Socket; public class Server&#123; public static void main(String[] args) throws Exception &#123; ServerSocket server = new ServerSocket(8888); Socket client = null; boolean flag = true; while(flag)&#123; System.out.println(&quot;Server alread run, waiting for client!&quot;); client = server.accept(); EchoThread echo = new EchoThread(client); new Thread(echo).start(); &#125; server.close(); &#125; &#125; 处理聊天程序的线程1234567891011121314151617181920212223242526272829303132333435363738394041424344[java] view plain copy print?package org.zbq; import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.PrintStream; import java.net.Socket; public class EchoThread implements Runnable &#123; private Socket client; public EchoThread(Socket client)&#123; this.client = client; &#125; @Override public void run() &#123; BufferedReader buf = null; PrintStream out = null; try&#123; out = new PrintStream(this.client.getOutputStream()); buf = new BufferedReader(new InputStreamReader(this.client.getInputStream())); boolean flag = true; while(flag)&#123; String str = buf.readLine(); if(null == str)&#123; flag = false; &#125;else&#123; if(&quot;bye&quot;.equals(str))&#123; flag = false; &#125;else&#123; str = &quot;Echo:&quot; + str + &quot;\\n&quot;; out.write(str.getBytes()); &#125; &#125; &#125; this.client.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 客户端12345678910111213141516171819202122232425262728293031323334353637383940414243[java] view plain copy print?package org.zbq; import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.PrintStream; import java.net.Socket; import java.net.UnknownHostException; public class Client &#123; /** * @param args * @throws Exception * @throws UnknownHostException */ public static void main(String[] args) throws Exception &#123; Socket client = new Socket(&quot;127.0.0.1&quot;, 8888); BufferedReader buf = null; PrintStream out = null; BufferedReader input = null; input = new BufferedReader(new InputStreamReader(System.in)); buf = new BufferedReader(new InputStreamReader(client.getInputStream())); out = new PrintStream(client.getOutputStream()); boolean flag = true; while(flag)&#123; System.out.print(&quot;Input:&quot;); String str = input.readLine(); out.println(str); if(&quot;bye&quot;.equals(str))&#123; flag = false; &#125;else&#123; String echo = buf.readLine(); System.out.println(echo); &#125; &#125; buf.close(); client.close(); &#125; &#125; 思考：PrintWriter 的Write()方法和println()方法有何细微的区别？在服务器端和客户端产生一个Socket 后，两边各自用getIputStream()和getOutputStream()方法,构造各自的输入输出流。其中服务器端的Socket ss123BufferedReader is=new BufferedReader(new InputStreamReader(ss.getInputStream()) );PrintWriter os=new PrintWriter (new OutputStreamWriter(ss.getOutputStream()) );os.writer(&quot;一个乱七八糟的字符串&quot;); 客户端的Socket cs123BufferedReader is=new BufferedReader(new InputStreamReader(cs.getInputStream()) );PrintWriter os=new PrintWriter (new OutputStreamWriter(cs.getOutputStream()) );System.out.println(is.readLine()); 按理说，应该是ss的 os对应着cs的 is. 为什么在服务器端写入了，在客户端这边没法读出来呢？另外，如果服务器端用os.println(“字符串”);就好使了。 print() 方法等同于 write() 方法println() 方法是在 print() 的基础上多调用了一个 newLine() 方法(私有方法)而 newLine() 方法会调用 flush() ####PrintStream类的write方法源码12345678910111213141516public void write(int b) &#123;try &#123; synchronized (this) &#123; ensureOpen(); out.write(b); if ((b == &apos;\\n&apos;) &amp;&amp; autoFlush) out.flush(); &#125;&#125;catch (InterruptedIOException x) &#123; Thread.currentThread().interrupt();&#125;catch (IOException x) &#123; trouble = true;&#125;&#125; 为什么客户端调用了write()和flush()后，服务器端依然read不到数据。因为socket.getOutputStream()取到的实现类是java.net.SocketOutputStream，这个类并没有覆写flush方法，它的父类java.io.FileOutputStream也没有覆写，于是最终就调到了最顶层java.io.OutputStream的flush()方法，这就恶心了，这个方法是空的。于是…因此，还是使用Reader.readLine()和Writer.println()来处理socket吧，或者直接使用NIO。println是会自动在字符后面加上回车换行符的，或者你在服务端os.writer(“一个乱七八糟的字符串\\r\\n”); ####PrintStream和PrintWriter的区别PrintStream PrintStream在OutputStream基础之上提供了增强的功能，即可以方便地输出各种类型的数据（而不仅限于byte型）的格式化表示形式。PrintStream的方法从不抛出IOEceptin PrintWriter PrintWriter提供了PrintStream的所有打印方法，其方法也从不抛出IOException。 与PrintStream的区别：作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream类型的字节流，还能够封装Writer类型的字符输出流并增强其功能。1234FileReader fr=new FileReader(&quot;a.txt&quot;); BufferedReader br=new BufferedReader(fr); FileWriter fw=new FileWriter(&quot;33.txt&quot;); PrintWriter pw=new PrintWriter(fw); 如果将上面的PrintWriter换成PrintStream会报错，因为PrintStream只能封装字节流，不能封装Writer类对象。","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"Http协议与TCP协议易混淆点（一）","date":"2015-03-22T05:22:46.000Z","path":"2015/03/22/Http协议与TCP协议易混淆点（一）/","text":"Http协议与TCP协议1.TCP协议对应于传输层，而HTTP协议对应于应用层，从本质上来说，二者没有可比性。2.Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。 &emsp;&emsp;所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，成为无状态连接。 那么问题来了：每次创建新连接不耗费性能吗？&emsp;&emsp;从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性。也就是说，在打开一个网页之后，客户端与服务器之间的传输数据的TCP连接不马上关闭，客户端再次访问时会使用，但是Keep-Alive保持时间不是有限的，超时之后还是会断开，所以我们还把其看做是每次连接完成后就会关闭。后来，通过Session, Cookie等相关技术，也能保持一些用户的状态。但是还是每次都使用一个连接，依然是无状态连接。 为什么HTTP是无状态的短连接，而TCP是有状态的长连接？Http不是建立在TCP的基础上吗，为什么还能是短连接？&emsp;&emsp;Http就是在每次请求完成后就把TCP连接关了，所以是短连接。而我们直接通过Socket编程使用TCP协议的时候，因为我们自己可以通过代码区控制什么时候打开连接什么时候关闭连接，只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一直存在，相关状态数据会一直保存着。","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"APP开发屏幕适配","date":"2015-02-12T05:19:39.000Z","path":"2015/02/12/APP开发屏幕适配/","text":"支持不同屏幕尺寸通过下列方法支持不同的屏幕尺寸： 确保您的布局能够根据屏幕适当地调整大小 根据屏幕配置提供合适的 UI 布局 确保对正确的屏幕应用正确的布局 提供可正常缩放的位图具体适配方案：1、使用“wrap_content”和“match_parent”&emsp;&emsp;为确保您的布局能够灵活地适应不同的屏幕尺寸，您应该为某些视图组件的宽度和高度使用 “wrap_content” 和 “match_parent”，代替硬编码。2、使用 RelativeLayout&emsp;&emsp;RelativeLayout允许您根据组件之间的空间关系指定布局。3、使用尺寸限定符&emsp;&emsp; 上述两种方案无法为每一种屏幕尺寸提供最佳用户体验。 因此，您的应用不仅应实现灵活布局，还应针对不同的屏幕配置提供多种备选布局；可以利用配置限定符来实现此目的，它允许运行组件根据当前设备配置（如针对不同屏幕尺寸的不同布局设计）自动选择合适的资源。&emsp;&emsp; 例如，许多应用都针对大屏幕实现了“双窗格”模式（应用可以在一个窗格中显示项目列表，在另一个窗格中显示项目内容）。 平板电脑和 TV 足够大，可在一个屏幕上同时容纳两个窗格，但手机屏幕只能独立显示它们。 因此，如需实现这些布局，您可以建立以下文件：res/layout/main.xml，单窗格（默认）布局：xmlns:android=\"http://schemas.android.com/apk/res/android\"123456789 android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-large/main.xml，双窗格布局：1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 注意第二个布局目录名称中的 large 限定符。在屏幕归类为大屏幕的设备（例如，7 英寸及更大尺寸的平板电脑）上，将选择此布局。 对于小型设备，将选择另一个布局（无限定符）。4、使用最小宽度限定符&emsp;&emsp;Android 在 Android 3.2 中引入了“最小宽度”限定符。允许您将目标锁定在具有特定最小宽度（单位：dp）的屏幕。&emsp;&emsp; 例如，典型的 7 英寸平板电脑最小宽度为 600dp，因此，如果您希望您的 UI 在这些屏幕上显示两个窗格（但在较小屏幕上显示单个列表），您同样可以为单窗格布局和双窗格布局使用前文中的两种布局，但不使用 large 尺寸限定符，而是使用 sw600dp 为最小宽度是 600dp 的屏幕指定双窗格布局： res/layout/main.xml，单窗格（默认）布局： 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-sw600dp/main.xml，双窗格布局：1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 这意味着，最小宽度大于或等于 600dp 的设备将选择 layout-sw600dp/main.xml（双窗格）布局，而屏幕较小的设备将选择 layout/main.xml（单窗格）布局。 不过，这种方法在低于 3.2 版本的设备上不太奏效，因为它们无法将 sw600dp 识别为尺寸限定符，所以您仍需使用 large 限定符。因此，您应该建立一个与 res/layout-sw600dp/main.xml 完全相同的、名为 res/layout-large/main.xml 的文件。下文介绍的技巧可让您避免因此而产生重复的布局文件5、使用布局别名&emsp;&emsp;最小宽度限定符仅在 Android 3.2 及更高版本上提供。因此，您仍应使用兼容早期版本的抽象尺寸容器（小、正常、大和超大）。 例如，如果您想让自己设计的 UI 在手机上显示单窗格 UI，但在 7 英寸平板电脑、TV 及其他大屏设备上显示多窗格 UI，则需要提供下列文件： res/layout/main.xml: 单窗格布局 res/layout-large: 多窗格布局 res/layout-sw600dp: 多窗格布局 后两个文件完全相同，因为其中一个将由 Android 3.2 设备匹配，另一个是为了照顾使用早期版本 Android 的平板电脑和 TV 的需要。 为避免为平板电脑和 TV 产生相同的重复文件（以及由此带来的维护难题），您可以使用别名文件。 例如，您可以定义下列布局: res/layout/main.xml，单窗格布局 res/layout/main_twopanes.xml，双窗格布局 并添加以下两个文件： res/values-large/layout.xml: 123&lt;resources&gt; &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; res/values-sw600dp/layout.xml： 123&lt;resources&gt; &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; 后两个文件内容完全相同，但它们实际上并未定义布局， 而只是将 main 设置为 main_twopanes 的别名。由于这些文件具有 large 和 sw600dp 选择器，因此它们适用于任何 Android 版本的平板电脑和电视（低于 3.2 版本的平板电脑和电视匹配 large，高于 3.2 版本者将匹配 sw600dp）6、使用屏幕方向限定符&emsp;&emsp;某些布局在横向和纵向屏幕方向下都表现不错，但其中大多数布局均可通过调整做进一步优化。 在 News Reader 示例应用中，以下是布局在各种屏幕尺寸和屏幕方向下的行为： 小屏幕，纵向：单窗格，带徽标小屏幕，横向：单窗格，带徽标7 英寸平板电脑，纵向：单窗格，带操作栏7 英寸平板电脑，横向：双窗格，宽，带操作栏10 英寸平板电脑，纵向：双窗格，窄，带操作栏10 英寸平板电脑，横向：双窗格，宽，带操作栏TV，横向：双窗格，宽，带操作栏&emsp;&emsp;因此，以上每一种布局都在 res/layout/ 目录下的某个 XML 文件中定义。如果之后需要将每一种布局分配给各种屏幕配置，应用会使用布局别名将它们与每一种配置进行匹配： res/layout/onepane.xml: 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/onepane_with_bar.xml: 1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:id=&quot;@+id/linearLayout1&quot; android:gravity=&quot;center&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:src=&quot;@drawable/logo&quot; android:paddingRight=&quot;30dp&quot; android:layout_gravity=&quot;left&quot; android:layout_weight=&quot;0&quot; /&gt; &lt;View android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/view1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;Button android:id=&quot;@+id/categorybutton&quot; android:background=&quot;@drawable/button_bg&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;0&quot; android:layout_width=&quot;120dp&quot; style=&quot;@style/CategoryButtonStyle&quot;/&gt; &lt;/LinearLayout&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes.xml： 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes_narrow.xml： 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;200dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 至此所有可能的布局均已定义，现在只需使用配置限定符将正确的布局映射到每一种配置。 现在您可以使用布局别名技巧来完成这项工作： res/values/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane_with_bar&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-land/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-port/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-large-land/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-large-port/layouts.xml： 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes_narrow&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; 7、使用九宫格位图（.9.png）","tags":[{"name":"安卓，Java","slug":"安卓，Java","permalink":"http://samychen.com/tags/安卓，Java/"}]},{"title":"生产者/消费者问题的多种Java实现方式","date":"2014-11-14T06:32:57.000Z","path":"2014/11/14/生产者-消费者问题的多种Java实现方式/","text":"实质上，很多后台服务程序并发控制的基本原理都可以归纳为生产者/消费者模式，而这是恰恰是在本科操作系统课堂上老师反复讲解，而我们却视而不见不以为然的。在博文《一种面向作业流(工作流)的轻量级可复用的异步流水开发框架的设计与实现》中将介绍一种生产者/消费者模式的具体应用。生产者消费者问题是研究多线程程序时绕不开的经典问题之一，它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。解决生产者/消费者问题的方法可分为两类：（1）采用某种机制保护生产者和消费者之间的同步；（2）在生产者和消费者之间建立一个管道。第一种方式有较高的效率，并且易于实现，代码的可控制性较好，属于常用的模式。第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。因此本文只介绍同步机制实现的生产者/消费者问题。同步问题核心在于：如何保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。Java语言在多线程编程上实现了完全对象化，提供了对同步机制的良好支持。在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。（1）wait() / notify()方法（2）await() / signal()方法（3）BlockingQueue阻塞队列方法（4）PipedInputStream / PipedOutputStream本文只介绍最常用的前三种，第四种暂不做讨论，有兴趣的读者可以自己去网上找答案。 一、wait() / notify()方法wait() / nofity()方法是基类Object的两个方法，也就意味着所有Java类都会拥有这两个方法，这样，我们就可以为任何对象实现同步机制。wait()方法：当缓冲区已满/空时，生产者/消费者线程停止自己的执行，放弃锁，使自己处于等等状态，让其他线程执行。notify()方法：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。光看文字可能不太好理解，咱来段代码就明白了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231import java.util.LinkedList;/** * 仓库类Storage实现缓冲区 * Email:530025983@qq.com * @author MONKEY.D.MENG 2011-03-15 */public class Storage&#123; // 仓库最大存储量 private final int MAX_SIZE = 100; // 仓库存储的载体 private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;(); // 生产num个产品 public void produce(int num) &#123; // 同步代码段 synchronized (list) &#123; // 如果仓库剩余容量不足 while (list.size() + num &gt; MAX_SIZE) &#123; System.out.println(&quot;【要生产的产品数量】:&quot; + num + &quot;/t【库存量】:&quot; + list.size() + &quot;/t暂时不能执行生产任务!&quot;); try &#123; // 由于条件不满足，生产阻塞 list.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 生产条件满足情况下，生产num个产品 for (int i = 1; i &lt;= num; ++i) &#123; list.add(new Object()); &#125; System.out.println(&quot;【已经生产产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + list.size()); list.notifyAll(); &#125; &#125; // 消费num个产品 public void consume(int num) &#123; // 同步代码段 synchronized (list) &#123; // 如果仓库存储量不足 while (list.size() &lt; num) &#123; System.out.println(&quot;【要消费的产品数量】:&quot; + num + &quot;/t【库存量】:&quot; + list.size() + &quot;/t暂时不能执行生产任务!&quot;); try &#123; // 由于条件不满足，消费阻塞 list.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 消费条件满足情况下，消费num个产品 for (int i = 1; i &lt;= num; ++i) &#123; list.remove(); &#125; System.out.println(&quot;【已经消费产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + list.size()); list.notifyAll(); &#125; &#125; // get/set方法 public LinkedList&lt;Object&gt; getList() &#123; return list; &#125; public void setList(LinkedList&lt;Object&gt; list) &#123; this.list = list; &#125; public int getMAX_SIZE() &#123; return MAX_SIZE; &#125;&#125;/** * 生产者类Producer继承线程类Thread * * Email:530025983@qq.com * * @author MONKEY.D.MENG 2011-03-15 * */public class Producer extends Thread&#123; // 每次生产的产品数量 private int num; // 所在放置的仓库 private Storage storage; // 构造函数，设置仓库 public Producer(Storage storage) &#123; this.storage = storage; &#125; // 线程run函数 public void run() &#123; produce(num); &#125; // 调用仓库Storage的生产函数 public void produce(int num) &#123; storage.produce(num); &#125; // get/set方法 public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public Storage getStorage() &#123; return storage; &#125; public void setStorage(Storage storage) &#123; this.storage = storage; &#125;&#125;/** * 消费者类Consumer继承线程类Thread * * Email:530025983@qq.com * * @author MONKEY.D.MENG 2011-03-15 * */public class Consumer extends Thread&#123; // 每次消费的产品数量 private int num; // 所在放置的仓库 private Storage storage; // 构造函数，设置仓库 public Consumer(Storage storage) &#123; this.storage = storage; &#125; // 线程run函数 public void run() &#123; consume(num); &#125; // 调用仓库Storage的生产函数 public void consume(int num) &#123; storage.consume(num); &#125; // get/set方法 public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public Storage getStorage() &#123; return storage; &#125; public void setStorage(Storage storage) &#123; this.storage = storage; &#125;&#125;/** * 测试类Test * * Email:530025983@qq.com * * @author MONKEY.D.MENG 2011-03-15 * */public class Test&#123; public static void main(String[] args) &#123; // 仓库对象 Storage storage = new Storage(); // 生产者对象 Producer p1 = new Producer(storage); Producer p2 = new Producer(storage); Producer p3 = new Producer(storage); Producer p4 = new Producer(storage); Producer p5 = new Producer(storage); Producer p6 = new Producer(storage); Producer p7 = new Producer(storage); // 消费者对象 Consumer c1 = new Consumer(storage); Consumer c2 = new Consumer(storage); Consumer c3 = new Consumer(storage); // 设置生产者产品生产数量 p1.setNum(10); p2.setNum(10); p3.setNum(10); p4.setNum(10); p5.setNum(10); p6.setNum(10); p7.setNum(80); // 设置消费者产品消费数量 c1.setNum(50); c2.setNum(20); c3.setNum(30); // 线程开始执行 c1.start(); c2.start(); c3.start(); p1.start(); p2.start(); p3.start(); p4.start(); p5.start(); p6.start(); p7.start(); &#125;&#125; 【要消费的产品数量】:50 【库存量】:0 暂时不能执行生产任务!【要消费的产品数量】:30 【库存量】:0 暂时不能执行生产任务!【要消费的产品数量】:20 【库存量】:0 暂时不能执行生产任务!【已经生产产品数】:10 【现仓储量为】:10【要消费的产品数量】:20 【库存量】:10 暂时不能执行生产任务!【要消费的产品数量】:30 【库存量】:10 暂时不能执行生产任务!【要消费的产品数量】:50 【库存量】:10 暂时不能执行生产任务!【已经生产产品数】:10 【现仓储量为】:20【要消费的产品数量】:50 【库存量】:20 暂时不能执行生产任务!【要消费的产品数量】:30 【库存量】:20 暂时不能执行生产任务!【已经消费产品数】:20 【现仓储量为】:0【已经生产产品数】:10 【现仓储量为】:10【已经生产产品数】:10 【现仓储量为】:20【已经生产产品数】:80 【现仓储量为】:100【要生产的产品数量】:10 【库存量】:100 暂时不能执行生产任务!【已经消费产品数】:30 【现仓储量为】:70【已经消费产品数】:50 【现仓储量为】:20【已经生产产品数】:10 【现仓储量为】:30【已经生产产品数】:10 【现仓储量为】:40看完上述代码，对wait() / notify()方法实现的同步有了了解。你可能会对Storage类中为什么要定义public void produce(int num);和public void consume(int num);方法感到不解，为什么不直接在生产者类Producer和消费者类Consumer中实现这两个方法，却要调用Storage类中的实现呢？淡定，后文会有解释。我们先往下走。 二、await() / signal()方法在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步、锁定、线程池等，它们可以实现更细粒度的线程控制。await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和wait() / nofity()相同，完全可以取代它们，但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。下面来看代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.util.LinkedList;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 仓库类Storage实现缓冲区 * * Email:530025983@qq.com * * @author MONKEY.D.MENG 2011-03-15 * */public class Storage&#123; // 仓库最大存储量 private final int MAX_SIZE = 100; // 仓库存储的载体 private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;(); // 锁 private final Lock lock = new ReentrantLock(); // 仓库满的条件变量 private final Condition full = lock.newCondition(); // 仓库空的条件变量 private final Condition empty = lock.newCondition(); // 生产num个产品 public void produce(int num) &#123; // 获得锁 lock.lock(); // 如果仓库剩余容量不足 while (list.size() + num &gt; MAX_SIZE) &#123; System.out.println(&quot;【要生产的产品数量】:&quot; + num + &quot;/t【库存量】:&quot; + list.size() + &quot;/t暂时不能执行生产任务!&quot;); try &#123; // 由于条件不满足，生产阻塞 full.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 生产条件满足情况下，生产num个产品 for (int i = 1; i &lt;= num; ++i) &#123; list.add(new Object()); &#125; System.out.println(&quot;【已经生产产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + list.size()); // 唤醒其他所有线程 full.signalAll(); empty.signalAll(); // 释放锁 lock.unlock(); &#125; // 消费num个产品 public void consume(int num) &#123; // 获得锁 lock.lock(); // 如果仓库存储量不足 while (list.size() &lt; num) &#123; System.out.println(&quot;【要消费的产品数量】:&quot; + num + &quot;/t【库存量】:&quot; + list.size() + &quot;/t暂时不能执行生产任务!&quot;); try &#123; // 由于条件不满足，消费阻塞 empty.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 消费条件满足情况下，消费num个产品 for (int i = 1; i &lt;= num; ++i) &#123; list.remove(); &#125; System.out.println(&quot;【已经消费产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + list.size()); // 唤醒其他所有线程 full.signalAll(); empty.signalAll(); // 释放锁 lock.unlock(); &#125; // set/get方法 public int getMAX_SIZE() &#123; return MAX_SIZE; &#125; public LinkedList&lt;Object&gt; getList() &#123; return list; &#125; public void setList(LinkedList&lt;Object&gt; list) &#123; this.list = list; &#125;&#125; 【要消费的产品数量】:50 【库存量】:0 暂时不能执行生产任务!【要消费的产品数量】:30 【库存量】:0 暂时不能执行生产任务!【已经生产产品数】:10 【现仓储量为】:10【已经生产产品数】:10 【现仓储量为】:20【要消费的产品数量】:50 【库存量】:20 暂时不能执行生产任务!【要消费的产品数量】:30 【库存量】:20 暂时不能执行生产任务!【已经生产产品数】:10 【现仓储量为】:30【要消费的产品数量】:50 【库存量】:30 暂时不能执行生产任务!【已经消费产品数】:20 【现仓储量为】:10【已经生产产品数】:10 【现仓储量为】:20【要消费的产品数量】:30 【库存量】:20 暂时不能执行生产任务!【已经生产产品数】:80 【现仓储量为】:100【要生产的产品数量】:10 【库存量】:100 暂时不能执行生产任务!【已经消费产品数】:50 【现仓储量为】:50【已经生产产品数】:10 【现仓储量为】:60【已经消费产品数】:30 【现仓储量为】:30【已经生产产品数】:10 【现仓储量为】:40只需要更新仓库类Storage的代码即可，生产者Producer、消费者Consumer、测试类Test的代码均不需要进行任何更改。这样我们就知道为神马我要在Storage类中定义public void produce(int num);和public void consume(int num);方法，并在生产者类Producer和消费者类Consumer中调用Storage类中的实现了吧。将可能发生的变化集中到一个类中，不影响原有的构架设计，同时无需修改其他业务层代码。无意之中，我们好像使用了某种设计模式，具体是啥我忘记了，啊哈哈，等我想起来再告诉大家~ 三、BlockingQueue阻塞队列方法BlockingQueue是JDK5.0的新增内容，它是一个已经在内部实现了同步的队列，实现方式采用的是我们第2种await() / signal()方法。它可以在生成对象时指定容量大小。它用于阻塞操作的是put()和take()方法。put()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。关于BlockingQueue的内容网上有很多，大家可以自己搜，我在这不多介绍。下面直接看代码，跟以往一样，我们只需要更改仓库类Storage的代码即可：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.concurrent.LinkedBlockingQueue;/** * 仓库类Storage实现缓冲区 * * Email:530025983@qq.com * * @author MONKEY.D.MENG 2011-03-15 * */public class Storage&#123; // 仓库最大存储量 private final int MAX_SIZE = 100; // 仓库存储的载体 private LinkedBlockingQueue&lt;Object&gt; list = new LinkedBlockingQueue&lt;Object&gt;( 100); // 生产num个产品 public void produce(int num) &#123; // 如果仓库剩余容量为0 if (list.size() == MAX_SIZE) &#123; System.out.println(&quot;【库存量】:&quot; + MAX_SIZE + &quot;/t暂时不能执行生产任务!&quot;); &#125; // 生产条件满足情况下，生产num个产品 for (int i = 1; i &lt;= num; ++i) &#123; try &#123; // 放入产品，自动阻塞 list.put(new Object()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;【现仓储量为】:&quot; + list.size()); &#125; &#125; // 消费num个产品 public void consume(int num) &#123; // 如果仓库存储量不足 if (list.size() == 0) &#123; System.out.println(&quot;【库存量】:0/t暂时不能执行生产任务!&quot;); &#125; // 消费条件满足情况下，消费num个产品 for (int i = 1; i &lt;= num; ++i) &#123; try &#123; // 消费产品，自动阻塞 list.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;【现仓储量为】:&quot; + list.size()); &#125; // set/get方法 public LinkedBlockingQueue&lt;Object&gt; getList() &#123; return list; &#125; public void setList(LinkedBlockingQueue&lt;Object&gt; list) &#123; this.list = list; &#125; public int getMAX_SIZE() &#123; return MAX_SIZE; &#125;&#125; 【库存量】:0 暂时不能执行生产任务!【库存量】:0 暂时不能执行生产任务!【现仓储量为】:1【现仓储量为】:1【现仓储量为】:3【现仓储量为】:4【现仓储量为】:5【现仓储量为】:6【现仓储量为】:7【现仓储量为】:8【现仓储量为】:9【现仓储量为】:10【现仓储量为】:11【现仓储量为】:1【现仓储量为】:2【现仓储量为】:13【现仓储量为】:14【现仓储量为】:17【现仓储量为】:19【现仓储量为】:20【现仓储量为】:21【现仓储量为】:22【现仓储量为】:23【现仓储量为】:24【现仓储量为】:25【现仓储量为】:26【现仓储量为】:12【现仓储量为】:1【现仓储量为】:1【现仓储量为】:2【现仓储量为】:3【现仓储量为】:4【现仓储量为】:5【现仓储量为】:6【现仓储量为】:7【现仓储量为】:27【现仓储量为】:8【现仓储量为】:6【现仓储量为】:18【现仓储量为】:2【现仓储量为】:3【现仓储量为】:4【现仓储量为】:5【现仓储量为】:6【现仓储量为】:7【现仓储量为】:8【现仓储量为】:9【现仓储量为】:10【现仓储量为】:16【现仓储量为】:11【现仓储量为】:12【现仓储量为】:13【现仓储量为】:14【现仓储量为】:15【现仓储量为】:1【现仓储量为】:2【现仓储量为】:3【现仓储量为】:3【现仓储量为】:15【现仓储量为】:1【现仓储量为】:0【现仓储量为】:1【现仓储量为】:1【现仓储量为】:1【现仓储量为】:2【现仓储量为】:3【现仓储量为】:4【现仓储量为】:0【现仓储量为】:1【现仓储量为】:5【现仓储量为】:6【现仓储量为】:7【现仓储量为】:8【现仓储量为】:9【现仓储量为】:10【现仓储量为】:11【现仓储量为】:12【现仓储量为】:13【现仓储量为】:14【现仓储量为】:15【现仓储量为】:16【现仓储量为】:17【现仓储量为】:1【现仓储量为】:1【现仓储量为】:2【现仓储量为】:3【现仓储量为】:4【现仓储量为】:5【现仓储量为】:6【现仓储量为】:3【现仓储量为】:3【现仓储量为】:1【现仓储量为】:2【现仓储量为】:3【现仓储量为】:4【现仓储量为】:5【现仓储量为】:6【现仓储量为】:7【现仓储量为】:8【现仓储量为】:9【现仓储量为】:10【现仓储量为】:11【现仓储量为】:12【现仓储量为】:13【现仓储量为】:14【现仓储量为】:15【现仓储量为】:16【现仓储量为】:17【现仓储量为】:18【现仓储量为】:19【现仓储量为】:6【现仓储量为】:7【现仓储量为】:8【现仓储量为】:9【现仓储量为】:10【现仓储量为】:11【现仓储量为】:12【现仓储量为】:13【现仓储量为】:14【现仓储量为】:15【现仓储量为】:16【现仓储量为】:17【现仓储量为】:18【现仓储量为】:19【现仓储量为】:20【现仓储量为】:21【现仓储量为】:22【现仓储量为】:23【现仓储量为】:24【现仓储量为】:25【现仓储量为】:26【现仓储量为】:27【现仓储量为】:28【现仓储量为】:29【现仓储量为】:30【现仓储量为】:31【现仓储量为】:32【现仓储量为】:33【现仓储量为】:34【现仓储量为】:35【现仓储量为】:36【现仓储量为】:37【现仓储量为】:38【现仓储量为】:39【现仓储量为】:40当然，你会发现这时对于public void produce(int num);和public void consume(int num);方法业务逻辑上的实现跟前面两个例子不太一样，没关系，这个例子只是为了说明BlockingQueue阻塞队列的使用。有时使用BlockingQueue可能会出现put()和System.out.println()输出不匹配的情况，这是由于它们之间没有同步造成的。当缓冲区已满，生产者在put()操作时，put()内部调用了await()方法，放弃了线程的执行，然后消费者线程执行，调用take()方法，take()内部调用了signal()方法，通知生产者线程可以执行，致使在消费者的println()还没运行的情况下生产者的println()先被执行，所以有了输出不匹配的情况。对于BlockingQueue大家可以放心使用，这可不是它的问题，只是在它和别的对象之间的同步有问题","tags":[{"name":"生产者消费者模式","slug":"生产者消费者模式","permalink":"http://samychen.com/tags/生产者消费者模式/"}]},{"title":"工厂模式","date":"2014-11-13T06:32:57.000Z","path":"2014/11/13/工厂模式/","text":"&lt;!DOCTYPE HTML&gt; 工厂模式 html, body { font-size: 15px; } body { font-family: Helvetica, ‘Hiragino Sans GB’, ‘微软雅黑’, ‘Microsoft YaHei UI’, SimSun, SimHei, arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px 15px; padding: 1.33rem 1rem; } h1, h2, h3, h4, h5, h6 { margin: 20px 0 10px; margin: 1.33rem 0 0.667rem; padding: 0; font-weight: bold; } h1 { font-size: 21px; font-size: 1.4rem; } h2 { font-size: 20px; font-size: 1.33rem; } h3 { font-size: 18px; font-size: 1.2rem; } h4 { font-size: 17px; font-size: 1.13rem; } h5 { font-size: 15px; font-size: 1rem; } h6 { font-size: 15px; font-size: 1rem; color: #777777; margin: 1rem 0; } div, p, ul, ol, dl, li { margin: 0; } blockquote, table, pre, code { margin: 8px 0; } ul, ol { padding-left: 32px; padding-left: 2.13rem; } blockquote { padding: 0 12px; padding: 0 0.8rem; } blockquote &gt; :first-child { margin-top: 0; } blockquote &gt; :last-child { margin-bottom: 0; } img { border: 0; max-width: 100%; height: auto !important; margin: 2px 0; } table { border-collapse: collapse; border: 1px solid #bbbbbb; } td, th { padding: 4px 8px; border-collapse: collapse; border: 1px solid #bbbbbb; } @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) { html, body { font-size: 17px; } body { line-height: 1.7; padding: 0.75rem 0.9375rem; color: #353c47; } h1 { font-size: 2.125rem; } h2 { font-size: 1.875rem; } h3 { font-size: 1.625rem; } h4 { font-size: 1.375rem; } h5 { font-size: 1.125rem; } h6 { color: inherit; } ul, ol { padding-left: 2.5rem; } blockquote { padding: 0 0.9375rem; } } 工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。工厂模式分为三种：简单工厂、工厂模式和抽象工厂模式工厂方法你会建立一个专门生产Sample实例的工厂:12345678public&nbsp;class&nbsp;Factory{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;ISample&nbsp;creator(int&nbsp;which){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(which==1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;SampleA();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(which==2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;SampleB();&nbsp;&nbsp;&nbsp;&nbsp;}}那么在你的程序中,如果要创建ISample的实列时候可以使用ISample sampleA=Factory.creator(1);使用工厂方法 要注意几个角色，首先你要定义产品接口，如上面的Sample类的接口,产品接口下有ISample接口的实现类,如SampleA,其次要有一个Factory类，用来生成产品ISample接口的具体实例。使用工厂方法 要注意几个角色，首先你要定义产品接口，如上面的Sample类的接口,产品接口下有ISample接口的实现类,如SampleA,其次要有一个Factory类，用来生成产品ISample接口的具体实例。抽象工厂工厂模式中有: 工厂方法(Factory Method)&nbsp;抽象工厂(Abstract Factory).这两个模式区别在于需要创建对象的复杂程度上。如果我们创建对象的方法变得复杂了,如上面工厂方法中是创建一个对象Sample,如果我们还有新的产品接口Sample2.一、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单工厂模式：实现了算法和界面的分离，也就是将业务逻辑和界面逻辑分开了，降低了耦合度。算法的封装：&nbsp;&nbsp;定义一个抽象的算法接口，提供不同算法的公共接口方法。其他具体算法继承这个抽象类，并实现具体的算法。简单工厂类：&nbsp;&nbsp;作为一个独立的类，实现了针对不同的算法进行实例化。简单工厂的UML图：&nbsp;二、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。&nbsp;&nbsp;遵循了开放—封闭原则。工厂模式的UML图：&nbsp;&nbsp;简单工厂与工厂模式的共同优点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;都集中封装了对象的创建，使得要更换对象时不需要做大的改动就可实现，降低了客户端程序与产品对象的耦合。&nbsp;工厂方法模式有四个要素：工厂接口。工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。在实际编程中，有时候也会使用一个抽象类来作为与调用者交互的接口，其本质上是一样的。工厂实现。在编程中，工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。产品接口。产品接口的主要目的是定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范。产品接口是调用者最为关心的，产品接口定义的优劣直接决定了调用者代码的稳定性。同样，产品接口也可以用抽象类来代替，但要注意最好不要违反里氏替换原则。产品实现。实现产品接口的具体类，决定了产品在客户端中的具体行为。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前文提到的简单工厂模式跟工厂方法模式极为相似，区别是：简单工厂只有三个要素，他没有工厂接口，并且得到产品的方法一般是静态的。因为没有工厂接口，所以在工厂实现的扩展性方面稍弱，可以算所工厂方法模式的简化版，关于简单工厂模式，在此一笔带过。工厂模式PK简单工厂模式：1、工厂模式的优点：工厂模式是简单工厂模式的进一步抽象和推广。它遵循了“开放—封闭”原则。2、简单工厂模式的优点：简单工厂模式最大的优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。3、工厂模式的缺点：工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来执行；每增加一产品就要增加一个产品工厂的类，增加了额外的开发量。4、简单工厂的缺点：是没有遵守开放—封闭原则。所谓的“开放-封闭”原则就是开放接口，封闭修改。如果将来需要添加一个开方的算法，那么，在简单工厂模式中，就必须在简单工厂类中添加相应的判断语句！另外，在简单工厂类中利用了Switch语句，这对程序的扩展本身就不不利。三、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。&nbsp;&nbsp;UML结构图：&nbsp;&nbsp;工厂模式和抽象工厂的区别：只有一个User类和User操作类的时候，只需要工厂方法模式；&nbsp;但数据库中有很多的表，而Sql和access又是两大不同的分类，所以就延伸到了抽象工厂模式抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。&nbsp;&nbsp;在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。抽象工厂模式代码interface&nbsp;IProduct1&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;show();&nbsp;&nbsp;}&nbsp;&nbsp;interface&nbsp;IProduct2&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;show();&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Product1&nbsp;implements&nbsp;IProduct1&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;show()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“这是1型产品”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;class&nbsp;Product2&nbsp;implements&nbsp;IProduct2&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;show()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“这是2型产品”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;IFactory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IProduct1&nbsp;createProduct1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IProduct2&nbsp;createProduct2();&nbsp;&nbsp;}&nbsp;&nbsp;class&nbsp;Factory&nbsp;implements&nbsp;IFactory{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IProduct1&nbsp;createProduct1()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Product1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IProduct2&nbsp;createProduct2()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Product2();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IFactory&nbsp;factory&nbsp;=&nbsp;new&nbsp;Factory();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factory.createProduct1().show();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factory.createProduct2().show();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;抽象工厂模式的优点抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。&nbsp;抽象工厂模式的缺点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。&nbsp;适用场景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。&nbsp;总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。","tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"http://samychen.com/tags/工厂模式/"}]},{"title":"java多线程之生产者消费者经典问题","date":"2014-11-12T06:32:57.000Z","path":"2014/11/12/java多线程之生产者消费者经典问题/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/**生产者消费者问题，涉及到几个类 * 第一，这个问题本身就是一个类，即主类 * 第二，既然是生产者、消费者，那么生产者类和消费者类就是必须的 * 第三，生产什么，消费什么，所以物品类是必须的，这里是馒头类 * 第四，既然是线程，那么就不是一对一的，也就是说不是生产一个消费一个，既然这样，多生产的往哪里放， * 现实中就是筐了，在计算机中也就是数据结构，筐在数据结构中最形象的就是栈了，因此还要一个栈类 */package thread;public class ProduceConsume &#123; public static void main(String[] args) &#123; SyncStack ss = new SyncStack();//建造一个装馒头的框 Producer p = new Producer(ss);//新建一个生产者，使之持有框 Consume c = new Consume(ss);//新建一个消费者，使之持有同一个框 Thread tp = new Thread(p);//新建一个生产者线程 Thread tc = new Thread(c);//新建一个消费者线程 tp.start();//启动生产者线程 tc.start();//启动消费者线程 &#125;&#125;//馒头类class SteamBread&#123; int id;//馒头编号 SteamBread(int id)&#123; this.id = id; &#125; public String toString()&#123; return &quot;steamBread:&quot;+id; &#125;&#125;//装馒头的框，栈结构class SyncStack&#123; int index = 0; SteamBread[] stb = new SteamBread[6];//构造馒头数组，相当于馒头筐，容量是6 //放入框中，相当于入栈 public synchronized void push(SteamBread sb)&#123; while(index==stb.length)&#123;//筐满了，即栈满， try &#123; this.wait();//让当前线程等待 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; this.notify();//唤醒在此对象监视器上等待的单个线程，即消费者线程 stb[index] = sb; this.index++; &#125; //从框中拿出，相当于出栈 public synchronized SteamBread pop()&#123; while(index==0)&#123;//筐空了，即栈空 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; this.notify(); this.index--;//push第n个之后，this.index++，使栈顶为n+1，故return之前要减一 return stb[index]; &#125;&#125;//生产者类，实现了Runnable接口，以便于构造生产者线程class Producer implements Runnable&#123; SyncStack ss = null; Producer(SyncStack ss)&#123; this.ss = ss; &#125; @Override public void run() &#123; // 开始生产馒头 for(int i=0;i&lt;20;i++)&#123; SteamBread stb = new SteamBread(i); ss.push(stb); System.out.println(&quot;生产了&quot;+stb); try &#123; Thread.sleep(10);//每生产一个馒头，睡觉10毫秒 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;//消费者类，实现了Runnable接口，以便于构造消费者线程class Consume implements Runnable&#123; SyncStack ss = null; public Consume(SyncStack ss) &#123; super(); this.ss = ss; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for(int i=0;i&lt;20;i++)&#123;//开始消费馒头 SteamBread stb = ss.pop(); System.out.println(&quot;消费了&quot;+stb); try &#123; Thread.sleep(100);//每消费一个馒头，睡觉100毫秒。即生产多个，消费一个 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 运行结果：生产者生成顺序是顺序生产，消费者消费无顺序 Java多线程-并发协作(生产者消费者模型) 对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。 实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。对于此模型，应该明确一下几点：1、生产者仅仅在仓储未满时候生产，仓满则停止生产。2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。3、当消费者发现仓储没产品可消费时候会通知生产者生产。4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package cn.thread;import java.util.concurrent.BlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingQueue;/** * java多线程模拟生产者消费者问题 * * ProducerConsumer是主类，Producer生产者，Consumer消费者，Product产品，Storage仓库 * * @author 林计钦 * @version 1.0 2013-7-24 下午04:49:02 */public class ProducerConsumer &#123; public static void main(String[] args) &#123; ProducerConsumer pc = new ProducerConsumer(); Storage s = pc.new Storage(); ExecutorService service = Executors.newCachedThreadPool(); Producer p = pc.new Producer(&quot;张三&quot;, s); Producer p2 = pc.new Producer(&quot;李四&quot;, s); Consumer c = pc.new Consumer(&quot;王五&quot;, s); Consumer c2 = pc.new Consumer(&quot;老刘&quot;, s); Consumer c3 = pc.new Consumer(&quot;老林&quot;, s); service.submit(p); //service.submit(p2); service.submit(c); service.submit(c2); service.submit(c3); &#125; /** * 消费者 * * @author 林计钦 * @version 1.0 2013-7-24 下午04:53:30 */ class Consumer implements Runnable &#123; private String name; private Storage s = null; public Consumer(String name, Storage s) &#123; this.name = name; this.s = s; &#125; public void run() &#123; try &#123; while (true) &#123; System.out.println(name + &quot;准备消费产品.&quot;); Product product = s.pop(); System.out.println(name + &quot;已消费(&quot; + product.toString() + &quot;).&quot;); System.out.println(&quot;===============&quot;); Thread.sleep(500); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 生产者 * * @author 林计钦 * @version 1.0 2013-7-24 下午04:53:44 */ class Producer implements Runnable &#123; private String name; private Storage s = null; public Producer(String name, Storage s) &#123; this.name = name; this.s = s; &#125; public void run() &#123; try &#123; while (true) &#123; Product product = new Product((int) (Math.random() * 10000)); // 产生0~9999随机整数 System.out.println(name + &quot;准备生产(&quot; + product.toString() + &quot;).&quot;); s.push(product); System.out.println(name + &quot;已生产(&quot; + product.toString() + &quot;).&quot;); System.out.println(&quot;===============&quot;); Thread.sleep(500); &#125; &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; /** * 仓库，用来存放产品 * * @author 林计钦 * @version 1.0 2013-7-24 下午04:54:16 */ public class Storage &#123; BlockingQueue&lt;Product&gt; queues = new LinkedBlockingQueue&lt;Product&gt;(10); /** * 生产 * * @param p * 产品 * @throws InterruptedException */ public void push(Product p) throws InterruptedException &#123; queues.put(p); &#125; /** * 消费 * * @return 产品 * @throws InterruptedException */ public Product pop() throws InterruptedException &#123; return queues.take(); &#125; &#125; /** * 产品 * * @author 林计钦 * @version 1.0 2013-7-24 下午04:54:04 */ public class Product &#123; private int id; public Product(int id) &#123; this.id = id; &#125; public String toString() &#123;// 重写toString方法 return &quot;产品：&quot; + this.id; &#125; &#125;&#125; 张三准备生产(产品：3359). 张三已生产(产品：3359).老刘准备消费产品. 王五已消费(产品：3359).王五准备消费产品.张三准备生产(产品：1863). 张三已生产(产品：1863).老林已消费(产品：1863).老林准备消费产品.张三准备生产(产品：5424).张三已生产(产品：5424). 老刘已消费(产品：5424).===============张三准备生产(产品：6290). 张三已生产(产品：6290).老刘准备消费产品. 王五已消费(产品：6290).张三准备生产(产品：990). 张三已生产(产品：990).老林已消费(产品：990).王五准备消费产品.张三准备生产(产品：1971).老林准备消费产品. 老刘已消费(产品：1971).张三已生产(产品：1971).张三准备生产(产品：5622).老刘准备消费产品. 张三已生产(产品：5622).王五已消费(产品：5622).王五准备消费产品.张三准备生产(产品：6570). 张三已生产(产品：6570).老林已消费(产品：6570).老林准备消费产品.张三准备生产(产品：17). 老刘已消费(产品：17).张三已生产(产品：17).老刘准备消费产品.张三准备生产(产品：7962). 张三已生产(产品：7962).王五已消费(产品：7962).王五准备消费产品.张三准备生产(产品：3200). 张三已生产(产品：3200).老林已消费(产品：3200).老林准备消费产品.张三准备生产(产品：7234). 张三已生产(产品：7234).老刘已消费(产品：7234).老刘准备消费产品.张三准备生产(产品：6486). 张三已生产(产品：6486).王五已消费(产品：6486).张三准备生产(产品：5436).王五准备消费产品. 王五已消费(产品：5436).","tags":[{"name":"生产者消费者模式","slug":"生产者消费者模式","permalink":"http://samychen.com/tags/生产者消费者模式/"}]},{"title":"java IO流设计模式之装饰模式","date":"2014-09-16T06:32:57.000Z","path":"2014/09/16/java-IO流设计模式之装饰模式/","text":"所以装饰模式是Java I/O库的基本模式。在这里我想再用&lt;&gt;中讲到装饰模式时候的一个例子，看看装饰模式是怎么达到不仅类的数目大减少了，性能的重复也可以减至到最少： 看到了上面的类图了吗，我们不禁会说这就是“类爆炸”。如果是按装饰模式的设计思路我们可以得出下面的设计类图： 再回到Java I/O库，由于装饰模式的引用，造成了灵活性和复杂都大大增加了，我们在使用Java I/O库时，必须理解Java I/O库是由一些基本的原始流处理器和围绕它们的装饰流处理器所组成的，这样可以在学习和使用Java I/O库时达到事半功倍的效果。首先是InputStream类型中的装饰模式： 上图中所有的类都叫做流处理器，这个图就叫做（InputStream类型的）流处理器图。 书中提到根据输入流的源的类型，可以将这些流类分成两种，即原始流类（Original Stream）和链接流处理器（Wrapper Stream）。 原始流处理器 原始流处理器接收一个Byte数组对象，String对象，FileDiscriptor对象或者不同类型的流源对象，根据上面的图，原始流处理器包括以下四种： ByteArrayInputStream：为多线程的通信提供缓冲区操作功能，接收一个Byte数组作为流的源。 FileInputStream:建立一个与文件有关的输入流。接收一个File对象作为流的源。 PipedInputStream：可以与PipedOutputStream配合使用，用于读入一个数据管道的数据，接收一个PipedOutputStream作为源。 StringBufferInputStream：将一个字符串缓冲区转换为一个输入流。接收一个String对象作为流的源。（ＪＤＫ帮助文档上说明：已过时。此类未能正确地将字符转换为字节。从ＪＤＫ1.1开始，从字符串创建流的首选方法是通过StringReader类进行创建。只有字符串中每个字符的低八位可以由此类使用。） 链接流处理器 所谓链接流处理器，就是可以接收另一个流对象作为源，并对之进行功能扩展的类。InputStream类型的链接处理器包括以下几种，它们都接收另一个InputStream对象作为流源。 （１）FilterInputStream称为过滤输入流，它将另一个输入流作为流源。这个类的子类包括以下几种： BufferedInputStream：用来从硬盘将数据读入到一个内存缓冲区中，并从缓冲区提供数据。 DataInputStream：提供基于多字节的读取方法，可以读取原始类型的数据。 LineNumberInputStream：提供带有行计数功能的过滤输入流。 PushbackInputStream：提供特殊的功能，可以将已经读取的字节“推回”到输入流中。 （２）ObjectInputStream可以将使用ObjectInputStream串行化的原始数据类型和对象重新并行化。 （３）SeqcueneInputStream可以将两个已有的输入流连接起来，形成一个输入流，从而将多个输入流排列构成一个输入流序列。 抽象结构图 按照上面的这种原始流处理器和链接流处理器的划分，可以用下面的结构图来描述它们之间的关系。 上面的流处理器图跟装饰模式的结构图有着显而易见的相同之处。实际上InputStream类型的流处理器结构确实符合装饰模式。 装饰模式结构图 FilterInputStream继承了InputStream,也引用了InputStream,而它有四个子类,这就是所谓的Decorator模式上面这个图向我们传达了这个信息：链接流链接流对象接收一个原始流对象或者另外一个链接流对象作为流源；另一方面他们对流源的内部工作方法做了相应的改变，这种改变是装饰模式所要达到的目的。比如： BufferedInputStream“装饰”了InputStream的内部工作方式，使得流的读入操作使用了缓冲机制。在使用了缓冲机制后，不会对每一次的流读入操作都产生一个物理的读盘动作，从而提高了程序的效率，在汲及到物理流的读入时，都应当使用这个装饰流类。 LineNumberInputStream和PushbackInputStream也同样“装饰”了InputStream的内部工作方式，前者使得程序能够按照行号读入数据；后者能够使程序读入的过程中，退后一个字符。 DataInputStream子类读入各种不同的原始数据类型以及String类型的数据，这一点可以从它提供的各种read方法看出来，如：readByte(),readInt(),readFloat()等。 Java语言的I/O库提供了四大等级结构:InputStream,OutputStream,Reader,Writer四个系列的类。InputStream和OutputStream处理8位字节流数据, Reader和Writer处理16位的字符流数据。InputStream和Reader处理输入, OutputStream和Writer处理输出，所以OutputStream,Reader,Writer这三类的装饰模式跟前面详细介绍的InputStream装饰模式大同小异，大家可以看书中其它部分对这三类的详细描述或者从网上也能找到有关资料。为了方便比较这几种类型，顺便附上Java语言的I/O层次结构图： 下面的图表示:以InputStream和OutputStream形成的层次关系 下面的图表示:以Reader和Writer形成的层次关系","tags":[{"name":"装饰者模式","slug":"装饰者模式","permalink":"http://samychen.com/tags/装饰者模式/"}]},{"title":"JAVA设计模式初探之装饰者模式","date":"2014-09-04T06:32:57.000Z","path":"2014/09/04/JAVA设计模式初探之装饰者模式/","text":"这个模式花费了挺长时间，开始有点难理解，其实就是定义：动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活。设计初衷:通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的。 要点：装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为在装饰模式中的各个角色有：（1）抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。（Human） （2）具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。（person） （3）装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口（Human）。 （4）具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。 设计原则 多用组合，少用继承。利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。 类应设计的对扩展开放，对修改关闭。 模式简化 如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。 如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。 适用性： 以下情况使用Decorator模式 需要扩展一个类的功能，或给一个类添加附加职责。 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 优点： Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 缺点： 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。 装饰模式在Java I/O库中的应用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 实际上Java 的I/O API就是使用Decorator实现的。//定义被装饰者public interface Human &#123; public void wearClothes(); public void walkToWhere();&#125;//定义装饰者public abstract class Decorator implements Human &#123; private Human human; public Decorator(Human human) &#123; this.human = human; &#125; public void wearClothes() &#123; human.wearClothes(); &#125; public void walkToWhere() &#123; human.walkToWhere(); &#125;&#125;//下面定义三种装饰，这是第一个，第二个第三个功能依次细化，即装饰者的功能越来越多public class Decorator_zero extends Decorator &#123; public Decorator_zero(Human human) &#123; super(human); &#125; public void goHome() &#123; System.out.println(&quot;进房子。。&quot;); &#125; public void findMap() &#123; System.out.println(&quot;书房找找Map。。&quot;); &#125; @Override public void wearClothes() &#123; // TODO Auto-generated method stub super.wearClothes(); goHome(); &#125; @Override public void walkToWhere() &#123; // TODO Auto-generated method stub super.walkToWhere(); findMap(); &#125;&#125;public class Decorator_first extends Decorator &#123; public Decorator_first(Human human) &#123; super(human); &#125; public void goClothespress() &#123; System.out.println(&quot;去衣柜找找看。。&quot;); &#125; public void findPlaceOnMap() &#123; System.out.println(&quot;在Map上找找。。&quot;); &#125; @Override public void wearClothes() &#123; // TODO Auto-generated method stub super.wearClothes(); goClothespress(); &#125; @Override public void walkToWhere() &#123; // TODO Auto-generated method stub super.walkToWhere(); findPlaceOnMap(); &#125;&#125;public class Decorator_two extends Decorator &#123; public Decorator_two(Human human) &#123; super(human); &#125; public void findClothes() &#123; System.out.println(&quot;找到一件D&amp;G。。&quot;); &#125; public void findTheTarget() &#123; System.out.println(&quot;在Map上找到神秘花园和城堡。。&quot;); &#125; @Override public void wearClothes() &#123; // TODO Auto-generated method stub super.wearClothes(); findClothes(); &#125; @Override public void walkToWhere() &#123; // TODO Auto-generated method stub super.walkToWhere(); findTheTarget(); &#125;&#125;//定义被装饰者，被装饰者初始状态有些自己的装饰public class Person implements Human &#123; @Override public void wearClothes() &#123; // TODO Auto-generated method stub System.out.println(&quot;穿什么呢。。&quot;); &#125; @Override public void walkToWhere() &#123; // TODO Auto-generated method stub System.out.println(&quot;去哪里呢。。&quot;); &#125;&#125;//测试类，看一下你就会发现，跟java的I/O操作有多么相似public class Test &#123; public static void main(String[] args) &#123; Human person = new Person(); Decorator decorator = new Decorator_two(new Decorator_first( new Decorator_zero(person))); decorator.wearClothes(); decorator.walkToWhere(); &#125;&#125; 其实就是进房子找衣服，然后找地图这样一个过程，通过装饰者的三层装饰，把细节变得丰富。关键点：1、Decorator抽象类中，持有Human接口，方法全部委托给该接口调用，目的是交给该接口的实现类即子类进行调用。2、Decorator抽象类的子类（具体装饰者），里面都有一个构造方法调用super(human),这一句就体现了抽象类依赖于子类实现即抽象依赖于实现的原则。因为构造里面参数都是Human接口，只要是该Human的实现类都可以传递进去，即表现出Decorator dt = new Decorator_second(new Decorator_first(new Decorator_zero(human)));这种结构的样子。所以当调用dt.wearClothes();dt.walkToWhere()的时候，又因为每个具体装饰者类中，都先调用super.wearClothes和super.walkToWhere()方法，而该super已经由构造传递并指向了具体的某一个装饰者类（这个可以根据需要调换顺序），那么调用的即为装饰类的方法，然后才调用自身的装饰方法，即表现出一种装饰、链式的类似于过滤的行为。3、具体被装饰者类，可以定义初始的状态或者初始的自己的装饰，后面的装饰行为都在此基础上一步一步进行点缀、装饰。4、装饰者模式的设计原则为：对扩展开放、对修改关闭，这句话体现在我如果想扩展被装饰者类的行为，无须修改装饰者抽象类，只需继承装饰者抽象类，实现额外的一些装饰或者叫行为即可对被装饰者进行包装。所以：扩展体现在继承、修改体现在子类中，而不是具体的抽象类，这充分体现了依赖倒置原则，这是自己理解的装饰者模式。 说的不清楚，有些只可意会不可言传的感觉，多看几遍代码，然后自己敲出来运行一下，基本上就领悟了。 下面这个例子也有助于理解 装饰的流程和作用现在需要一个汉堡，主体是鸡腿堡，可以选择添加生菜、酱、辣椒等等许多其他的配料，这种情况下就可以使用装饰者模式。 汉堡基类（被装饰者，相当于上面的Human）12345678910111213package decorator; public abstract class Humburger &#123; protected String name ; public String getName()&#123; return name; &#125; public abstract double getPrice(); &#125; 鸡腿堡类（被装饰者的初始状态，有些自己的简单装饰，相当于上面的Person）12345678910111213141516package decorator; public class ChickenBurger extends Humburger &#123; public ChickenBurger()&#123; name = &quot;鸡腿堡&quot;; &#125; @Override public double getPrice() &#123; return 10; &#125; &#125; ``` 配料的基类（装饰者，用来对汉堡进行多层装饰，每层装饰增加一些配料，相当于上面Decorator） package decorator; public abstract class Condiment extends Humburger { public abstract String getName(); }1生菜（装饰者的第一层，相当于上面的decorator_zero） package decorator; public class Lettuce extends Condiment { Humburger humburger; public Lettuce(Humburger humburger){ this.humburger = humburger; } @Override public String getName() { return humburger.getName()+&quot; 加生菜&quot;; } @Override public double getPrice() { return humburger.getPrice()+1.5; } }1辣椒（装饰者的第二层，相当于上面的decorator_first） package decorator; public class Chilli extends Condiment { Humburger humburger; public Chilli(Humburger humburger){ this.humburger = humburger; } @Override public String getName() { return humburger.getName()+&quot; 加辣椒&quot;; } @Override public double getPrice() { return humburger.getPrice(); //辣椒是免费的哦 } }1测试类 package decorator; public class Test { /** * @param args */ public static void main(String[] args) { Humburger humburger = new ChickenBurger(); System.out.println(humburger.getName()+&quot; 价钱：&quot;+humburger.getPrice()); Lettuce lettuce = new Lettuce(humburger); System.out.println(lettuce.getName()+&quot; 价钱：&quot;+lettuce.getPrice()); Chilli chilli = new Chilli(humburger); System.out.println(chilli.getName()+&quot; 价钱：&quot;+chilli.getPrice()); Chilli chilli2 = new Chilli(lettuce); System.out.println(chilli2.getName()+&quot; 价钱：&quot;+chilli2.getPrice()); } }```输出鸡腿堡 价钱：10.0鸡腿堡 加生菜 价钱：11.5鸡腿堡 加辣椒 价钱：10.0鸡腿堡 加生菜 加辣椒 价钱：11.5","tags":[{"name":"装饰者模式","slug":"装饰者模式","permalink":"http://samychen.com/tags/装饰者模式/"}]},{"title":"java之单例模式","date":"2014-08-22T06:32:57.000Z","path":"2014/08/22/java之单例模式/","text":"Java中的五种单例模式实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package singleton; /** * @author chensi * 单例模式的五种写法： * 1、懒汉 * 2、恶汉 * 3、静态内部类 * 4、枚举 * 5、双重校验锁 *//** *五、 双重校验锁，在当前的内存模型中无效 */class LockSingleton&#123; private volatile static LockSingleton singleton; private LockSingleton()&#123;&#125; //详见：http://www.ibm.com/developerworks/cn/java/j-dcl.html public static LockSingleton getInstance()&#123; if(singleton==null)&#123; synchronized(LockSingleton.class)&#123; if(singleton==null)&#123; singleton=new LockSingleton(); &#125; &#125; &#125; return singleton; &#125; &#125;/** * 四、枚举，《Effective Java》作者推荐使用的方法，优点：不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 */enum EnumSingleton&#123; INSTANCE; public void doSomeThing()&#123; &#125;&#125;/** * 三、静态内部类 优点：加载时不会初始化静态变量INSTANCE，因为没有主动使用，达到Lazy loading */class InternalSingleton&#123; private static class SingletonHolder&#123; private final static InternalSingleton INSTANCE=new InternalSingleton(); &#125; private InternalSingleton()&#123;&#125; public static InternalSingleton getInstance()&#123; return SingletonHolder.INSTANCE; &#125;&#125;/** * 二、恶汉,缺点：没有达到lazy loading的效果 */class HungrySingleton&#123; private static HungrySingleton singleton=new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance()&#123; return singleton; &#125;&#125;/** * 一、懒汉，常用的写法 */class LazySingleton&#123; private static LazySingleton singleton; private LazySingleton()&#123; &#125; public static LazySingleton getInstance()&#123; if(singleton==null)&#123; singleton=new LazySingleton(); &#125; return singleton; &#125; &#125; 1.饿汉式单例类1234567891011//饿汉式单例类.在类初始化时，已经自行实例化 public class Singleton1 &#123; //私有的默认构造子 private Singleton1() &#123;&#125; //已经自行实例化 private static final Singleton1 single = new Singleton1(); //静态工厂方法 public static Singleton1 getInstance() &#123; return single; &#125;&#125; 2.懒汉式单例类1234567891011121314//懒汉式单例类.在第一次调用的时候实例化 public class Singleton2 &#123; //私有的默认构造子 private Singleton2() &#123;&#125; //注意，这里没有final private static Singleton2 single=null; //静态工厂方法 public synchronized static Singleton2 getInstance() &#123; if (single == null) &#123; single = new Singleton2(); &#125; return single; &#125;&#125; 3.登记式单例类12345678910111213141516171819202122232425262728293031323334353637383940import java.util.HashMap;import java.util.Map;//登记式单例类.//类似Spring里面的方法，将类名注册，下次从里面直接获取。public class Singleton3 &#123; private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;(); static&#123; Singleton3 single = new Singleton3(); map.put(single.getClass().getName(), single); &#125; //保护的默认构造子 protected Singleton3()&#123;&#125; //静态工厂方法,返还此类惟一的实例 public static Singleton3 getInstance(String name) &#123; if(name == null) &#123; name = Singleton3.class.getName(); System.out.println(&quot;name == null&quot;+&quot;---&gt;name=&quot;+name); &#125; if(map.get(name) == null) &#123; try &#123; map.put(name, (Singleton3) Class.forName(name).newInstance()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; return map.get(name); &#125; //一个示意性的商业方法 public String about() &#123; return &quot;Hello, I am RegSingleton.&quot;; &#125; public static void main(String[] args) &#123; Singleton3 single3 = Singleton3.getInstance(null); System.out.println(single3.about()); &#125;&#125;","tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://samychen.com/tags/单例模式/"}]},{"title":"Java中的常用集合类","date":"2014-05-23T05:24:37.000Z","path":"2014/05/23/Java中的常用集合类/","text":"java中的常用集合类 1、ArrayList：ArrayList 里面的数据都是有序的，并且可以重复ArayList 缺点：删除慢，随机插入慢举例：如何将数组中的元素变为集合 12String name[] = &#123;&quot;Tom&quot;,&quot;jack&quot;&#125;;List&lt;String &gt;list = Arrays.asList(name); 2、LinkedList共性：有序 可以重复（里面的元素）区别：数据的存储方式不同 ArrayList本质：数组 LinkedList本质：链表优点：随机插入快，随机删除快缺点：随机获取元素慢，逐个遍历每个元素，而ArrayList是通过下标获取元素 3、HashSet共性：持有对象，全部放到[ ]中区别：1.存入的对象是无序的（相对无序） HashSet 的排序规则是根据hashCode产生的 2.存入HashSet容器的对象不能重复 HashSet先判断两个对象的hashCode是否相同，再判断 两个对象的Equals是否相同 注意：放入HashSe中的对象类型，必须覆盖hashCode()方法和Equals方法 放入Se中的对象类型，必须覆盖hashCode()方法和Equals方法，严格的还需要覆盖toString方法，Set无序，没有get方法 4、HashMap特点：Map以键值对（key：value）的形式存储数据，Map中的键可以是int，也可以是其他任意数据类型键必须唯一，值可以相同放入Map中的键必须要覆盖Object类hashCode和Equals，toString方法HashMap常用方法： containsKey(Object key)containsValue(Object value) map.values()返回Map中的所有值map.keySet()返回Map中所有的键 Map的迭代方法entrySet使用：如何打印系统的所有环境变量 123456Map&lt;String,String&gt;envMap = System.getenv(); for(Map.Entry&lt;String,String&gt;entry:envMap.entrySet())&#123; String key = entry.getKey(); String value = entry.getValue(); System.out.println(&quot;key = &quot;+key,&quot;value = &quot;+vaule);&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"比较器comparable和comparator的区别","date":"2014-05-12T05:24:37.000Z","path":"2014/05/12/比较器comparable和comparator的区别/","text":"比较器comparable和comparator的区别 Java提供了一个集合工具类，里面有排序方法，Collections使用它提供的方法来完成排序注意：Collection不是Collections，Collections是在Collection上进行操作的集合的一个工具类，就如Arrays是数组的工具类 1234567891011public class ComparableTest &#123; public static void main(String[] args) &#123; String names[] = &#123; &quot;Jack&quot;, &quot;Adam&quot;, &quot;Bob&quot; &#125;; List&lt;String&gt; list = Arrays.asList(names); System.out.println(list); //排序的方式String已经替我们完成了 //String会调用compareTo（）方法实现排序的功能 Collections.sort(list); System.out.println(list); &#125;&#125; String类实现Comparable接口，当调用sort规则时，String会调用compareTo方法实现排序功能 123456789101112131415161718public class StudentComparable &#123; public static void main(String[] args) &#123; Student stu[] = &#123; new Student(&quot;005&quot;, &quot;Jackson&quot;, 3, 3, &quot;football&quot;), new Student(&quot;001&quot;, &quot;Jerry&quot;, 1, 3, &quot;football&quot;), new Student(&quot;002&quot;, &quot;Adam&quot;, 5, 2, &quot;Tennis&quot;) &#125;; //错误原因：1Student没有实现Comparable接口 // 2 没有指定排序规则（id、name、hobby） List&lt;Student&gt; list = Arrays.asList(stu); //如何比较排序？ Collections.sort方法进行排序，它会回调 容器中Student对象的 compareTo方法 Collections.sort(list); for(Student student : list)&#123; System.out.println(student); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class Student implements Comparable&lt;Student&gt;&#123; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getGrade() &#123; return grade; &#125; public void setGrade(int grade) &#123; this.grade = grade; &#125; public int getClassNo() &#123; return classNo; &#125; public void setClassNo(int classNo) &#123; this.classNo = classNo; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125; @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;, grade=&quot; + grade + &quot;, classNo=&quot; + classNo + &quot;, hobby=&quot; + hobby + &quot;]&quot;; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + classNo; result = prime * result + grade; result = prime * result + ((hobby == null) ? 0 : hobby.hashCode()); result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (classNo != other.classNo) return false; if (grade != other.grade) return false; if (hobby == null) &#123; if (other.hobby != null) return false; &#125; else if (!hobby.equals(other.hobby)) return false; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; public Student(String id,String name,int grade,int classNo,String hobby) &#123; this.id =id; this.name = name; this.grade = grade; this.classNo = classNo; this.hobby = hobby; &#125; private String id; private String name; private int grade; private int classNo; private String hobby; /** * Comparable 的compareTo方法为我们提供了比较的功能， * 如何比较 * 怎么做需要在Student类中实现 * 我的规则：按照学生的ID进行排序 */ @Override public int compareTo(Student o) &#123; //两个对象需要做比较 //this的id 如果大于 o 的id 返回的是正数 //this的id 如果等于 o 的id 返回的是0 //this的id 如果小于 o 的id 返回的是负数// int result = -(this.getId().compareTo(o.getId()));// return result; // if(this.getId().compareTo(o.getId()) &gt;0)&#123;// return 1;// &#125;else if(this.getId().compareTo(o.getId())&lt;0)&#123;// return -1;// &#125;// return 0; //按照年级进行排序 if(this.getGrade() &gt; o.getGrade())&#123; return 1; &#125;else if(this.getGrade() &lt; o.getGrade())&#123; return -1; &#125; return 0; &#125; //制定一个策略：输入1 id 输入2 name 输入3 爱好排序&#125; 如果只比较一次 ，可以使用匿名内部类节约资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CheLueCompator &#123; public static void main(String[] args) &#123; Student stu[] = &#123; new Student(&quot;005&quot;, &quot;Jackson&quot;, 3, 6, &quot;football&quot;), new Student(&quot;001&quot;, &quot;Zero&quot;, 1, 3, &quot;basketball&quot;), new Student(&quot;002&quot;, &quot;Adam&quot;, 5, 2, &quot;tennis&quot;) &#125;; List&lt;Student&gt; list = Arrays.asList(stu); sortList(list); &#125; public static void sortList(List&lt;Student&gt; list) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入排序编号 1按照学生名称 2按照爱好 3按照班级编号&quot;); int num = input.nextInt(); switch (num) &#123; case 1: //两个参数 1需要排序的列表 2排序的策略 （按照名称排序） //匿名内部类：接口回调（由谁回调谁？）sort方法回调匿名内部类 //好莱坞原则：sort理解为好莱坞 ，匿名内部类理解为演员 //你不要找我，如果有需要我来找你，前提（匿名内部类需要向好莱坞进行注册） //如何注册（匿名内部类作为参数传入sort方法），sort方法需要的时候会回调匿名内部类的方法 Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //调用String的compareTo()方法 return o1.getName().compareTo(o2.getName()); &#125; &#125;); break; case 2: Collections.sort(list,new StuHobbyCompator()); break; case 3: Collections.sort(list,new StuClassNoCompator()); break; default: System.out.println(&quot;Error&quot;); break; &#125; input.close(); iteratorStu(list); &#125; public static void iteratorStu(List&lt;Student&gt; list) &#123; for(Student student : list)&#123; System.out.println(student); &#125; &#125;&#125; Comparable和Comparator的区别 1、Comparable:在java.lang包，通常由实体类(Student)来实现，用来定义默认的排序规则StudentComparable.java回调容器中Student对象的 compareTo方法Comparator:在java.util包，排序的工具类，是一种策略，通常一个实体类(Student)有一种默认的排序法，还有多种排序策略Comparable 定义在 Person类的内部: public class Persion implements Comparable {..比较Person的大小..},因为已经实现了比较器,那么我们的Person现在是一个可以比较大小的对象了,它的比较功能和String完全一样 2、ComparatorComparator 是定义在Person的外部的, 此时我们的Person类的结构不需要有任何变化,如 public class Person{ String name; int age }, 然后我们另外定义一个比较器: public PersonComparator implements Comparator() {..比较Person的大小..},用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。在PersonComparator里面实现了怎么比较两个Person的大小. 所以,用这种方法,当我们要对一个 personList进行排序的时候, 我们除了了要传递personList过去, 还需要把PersonComparator传递过去,因为怎么比较Person的大小是在PersonComparator里面实现的, 如: Collections.sort( personList , new PersonComparator() ).一个是自已完成比较，一个是外部程序实现比较的差别而已。3、Comparator 和 Comparable 的实例实现Comparable接口要覆盖compareTo方法, 在compareTo方法里面实现比较 12345678910111213public class Person implements Comparable &#123; String name; int age public int compareTo(Person another) &#123; int i = 0; i = name.compareTo(another.name); // 使用字符串的比较 if(i == 0) &#123; // 如果名字一样,比较年龄, 返回比较年龄结果 return age - another.age; &#125; else &#123; return i; // 名字不一样, 返回比较名字的结果. &#125; &#125;&#125; 这时我们可以直接用 Collections.sort( personList ) 对其排序了. 实现Comparator需要覆盖 compare 方法： 12345678910111213141516public class Person&#123; String name; int age&#125;class PersonComparator implements Comparator &#123; public int compare(Person one, Person another) &#123; int i = 0; i = one.name.compareTo(another.name); // 使用字符串的比较，即调用String的比较丰富 if(i == 0) &#123; // 如果名字一样,比较年龄,返回比较年龄结果 return one.age - another.age; &#125; else &#123; return i; // 名字不一样, 返回比较名字的结果. &#125; &#125;&#125; Collections.sort( personList , new PersonComparator()) 可以对其排序 4、总结 两种方法各有优劣, 用Comparable 简单, 只要实现Comparable 接口的对象直接就成为一个可以比较的对象,但是需要修改源代码, 用Comparator 的好处是不需要修改源代码, 而是另外实现一个比较器, 当某个自定义的对象需要作比较的时候,把比较器和对象一起传递过去就可以比大小了, 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]},{"title":"Java中为什么要单继承，多实现","date":"2014-03-12T05:32:22.000Z","path":"2014/03/12/Java中为什么要单继承，多实现/","text":"为什么是多实现呢？ 若为多继承，那么当多个父类中有重复的属性或者方法时，子类的调用结果会含糊不清，因此用了单继承。为什么是多实现呢？ 通过实现接口拓展了类的功能，若实现的多个接口中有重复的方法也没关系，因为实现类中必须重写接口中的方法，所以调用时还是调用的实现类中重写的方法。那么各个接口中重复的变量又是怎么回事呢？ 接口中，所有属性都是 static final修饰的，即常量，这个什么意思呢，由于JVM的底层机制，所有static final修饰的变量都在编译时期确定了其值，若在使用时，两个相同的常量值不同，在编译时期就不能通过。","tags":[{"name":"Java","slug":"Java","permalink":"http://samychen.com/tags/Java/"}]}]