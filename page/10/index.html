<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 10 页 | SamyChen</title>
  <meta name="author" content="SamyChen">
  
  <meta name="description" content="学习总结 思考感悟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="SamyChen"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link rel="alternate" href="/atom.xml" title="SamyChen" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <!-- wumiiVerification -->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!-- Font-Awesome -->
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">

</head>

<body>
  <header id="header"><div class= "header-content inner">
	<div class = "alignleft col-one">
		
			<div class='avatar'>
				<img src = "/img/default/head.jpg">
              </div>
		
		<div class="header-div">
		    <h1><a href="/">SamyChen</a></h1>
		    <h2><a href="/">SamyChen的博客</a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
            <div class="ad">
			<img src = "/img/default/head.jpg">
            </div>
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div class='header-nav-content inner'>
		<div id="main-nav" class="alignleft">
		    		
		    		  <a href="/"><i class="fa fa-home"></i>首页</a>
		    		
		    		  <a href="/archives"><i class="fa fa-archive"></i>归档</a>
		    		
		    		  <a href="/hexo"><i class="fa fa-book"></i>电子书</a>
		    		
		    		  <a href="/about"><i class="fa fa-user"></i>关于我</a>
		    		
		</div>
		<div id="sub-nav" class="alignright">
		    
		      <a href="https://github.com/samychen"><i class="fa fa-"></i>github</a>
		    
		      <a href="#"><i class="fa fa-"></i>weibo</a>
		    
		</div>
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
    <div id="content" class="inner">
      <div id="main-col" class="alignleft"><div id="wrapper">
    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2014-11-12T06:32:57.000Z"><a href="/2014/11/12/java多线程之生产者消费者经典问题/">2014-11-12</a></time>
        
  
    <h1 class="title"><a href="/2014/11/12/java多线程之生产者消费者经典问题/">java多线程之生产者消费者经典问题</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java多线程-并发协作-生产者消费者模型"><span class="toc-text">Java多线程-并发协作(生产者消费者模型)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：3359"><span class="toc-text">张三已生产(产品：3359).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#王五已消费-产品：3359"><span class="toc-text">王五已消费(产品：3359).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：1863"><span class="toc-text">张三已生产(产品：1863).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#老林已消费-产品：1863"><span class="toc-text">老林已消费(产品：1863).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#老刘已消费-产品：5424"><span class="toc-text">老刘已消费(产品：5424).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：6290"><span class="toc-text">张三已生产(产品：6290).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#王五已消费-产品：6290"><span class="toc-text">王五已消费(产品：6290).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：990"><span class="toc-text">张三已生产(产品：990).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#老林已消费-产品：990"><span class="toc-text">老林已消费(产品：990).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#老刘已消费-产品：1971"><span class="toc-text">老刘已消费(产品：1971).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：1971"><span class="toc-text">张三已生产(产品：1971).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：5622"><span class="toc-text">张三已生产(产品：5622).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#王五已消费-产品：5622"><span class="toc-text">王五已消费(产品：5622).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：6570"><span class="toc-text">张三已生产(产品：6570).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#老林已消费-产品：6570"><span class="toc-text">老林已消费(产品：6570).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#老刘已消费-产品：17"><span class="toc-text">老刘已消费(产品：17).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：17"><span class="toc-text">张三已生产(产品：17).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：7962"><span class="toc-text">张三已生产(产品：7962).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#王五已消费-产品：7962"><span class="toc-text">王五已消费(产品：7962).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：3200"><span class="toc-text">张三已生产(产品：3200).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#老林已消费-产品：3200"><span class="toc-text">老林已消费(产品：3200).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：7234"><span class="toc-text">张三已生产(产品：7234).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#老刘已消费-产品：7234"><span class="toc-text">老刘已消费(产品：7234).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#张三已生产-产品：6486"><span class="toc-text">张三已生产(产品：6486).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#王五已消费-产品：6486"><span class="toc-text">王五已消费(产品：6486).</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#王五已消费-产品：5436"><span class="toc-text">王五已消费(产品：5436).</span></a>
    </div>

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">/**生产者消费者问题，涉及到几个类</div><div class="line"> * 第一，这个问题本身就是一个类，即主类</div><div class="line"> * 第二，既然是生产者、消费者，那么生产者类和消费者类就是必须的</div><div class="line"> * 第三，生产什么，消费什么，所以物品类是必须的，这里是馒头类</div><div class="line"> * 第四，既然是线程，那么就不是一对一的，也就是说不是生产一个消费一个，既然这样，多生产的往哪里放，</div><div class="line"> *      现实中就是筐了，在计算机中也就是数据结构，筐在数据结构中最形象的就是栈了，因此还要一个栈类</div><div class="line"> */</div><div class="line">package thread;</div><div class="line">public class ProduceConsume &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SyncStack ss = new SyncStack();//建造一个装馒头的框</div><div class="line">		Producer p = new Producer(ss);//新建一个生产者，使之持有框</div><div class="line">		Consume c = new Consume(ss);//新建一个消费者，使之持有同一个框</div><div class="line">		Thread tp = new Thread(p);//新建一个生产者线程</div><div class="line">		Thread tc = new Thread(c);//新建一个消费者线程</div><div class="line">		tp.start();//启动生产者线程</div><div class="line">		tc.start();//启动消费者线程</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//馒头类</div><div class="line">class SteamBread&#123;</div><div class="line">	int id;//馒头编号</div><div class="line">	SteamBread(int id)&#123;</div><div class="line">		this.id = id;</div><div class="line">	&#125;</div><div class="line">	public String toString()&#123;</div><div class="line">		return &quot;steamBread:&quot;+id;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//装馒头的框，栈结构</div><div class="line">class SyncStack&#123;</div><div class="line">	int index = 0;</div><div class="line">	SteamBread[] stb = new SteamBread[6];//构造馒头数组，相当于馒头筐，容量是6</div><div class="line">	</div><div class="line">	//放入框中，相当于入栈</div><div class="line">	public synchronized void push(SteamBread sb)&#123;</div><div class="line">		while(index==stb.length)&#123;//筐满了，即栈满，</div><div class="line">			try &#123;</div><div class="line">				this.wait();//让当前线程等待</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();//唤醒在此对象监视器上等待的单个线程，即消费者线程</div><div class="line">		stb[index] = sb;</div><div class="line">		this.index++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//从框中拿出，相当于出栈</div><div class="line">	public synchronized SteamBread pop()&#123;</div><div class="line">		while(index==0)&#123;//筐空了，即栈空</div><div class="line">			try &#123;</div><div class="line">				this.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		this.notify();</div><div class="line">		this.index--;//push第n个之后，this.index++，使栈顶为n+1，故return之前要减一</div><div class="line">		return stb[index];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//生产者类，实现了Runnable接口，以便于构造生产者线程</div><div class="line">class Producer implements Runnable&#123;</div><div class="line">	SyncStack ss = null;</div><div class="line">	Producer(SyncStack ss)&#123;</div><div class="line">		this.ss = ss;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		// 开始生产馒头</div><div class="line">		for(int i=0;i&lt;20;i++)&#123;</div><div class="line">			SteamBread stb = new SteamBread(i);</div><div class="line">			ss.push(stb);</div><div class="line">			System.out.println(&quot;生产了&quot;+stb);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(10);//每生产一个馒头，睡觉10毫秒</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//消费者类，实现了Runnable接口，以便于构造消费者线程</div><div class="line">class Consume implements Runnable&#123;</div><div class="line">	SyncStack ss = null;</div><div class="line">	public Consume(SyncStack ss) &#123;</div><div class="line">		super();</div><div class="line">		this.ss = ss;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		for(int i=0;i&lt;20;i++)&#123;//开始消费馒头</div><div class="line">			SteamBread stb = ss.pop();</div><div class="line">			System.out.println(&quot;消费了&quot;+stb);</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(100);//每消费一个馒头，睡觉100毫秒。即生产多个，消费一个</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://note.wiz.cn/api/document/files/unzip/eb3eff32-254c-4783-ad5b-3204cdd5bf82/201ead72-5d1d-4b39-a02d-c86ee3a8d3d6.356/index_files/547ef884-64ba-4ad5-a755-88b972dd2b2a.png" alt=""></p>
<h4 id="Java多线程-并发协作-生产者消费者模型"><a href="#Java多线程-并发协作-生产者消费者模型" class="headerlink" title="Java多线程-并发协作(生产者消费者模型)"></a>Java多线程-并发协作(生产者消费者模型)</h4><p>&emsp;&emsp;对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。</p>
<p>&emsp;&emsp;实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。<br>&emsp;&emsp;对于此模型，应该明确一下几点：</p>
<ol>
<li>生产者仅仅在仓储未满时候生产，仓满则停止生产。</li>
<li>消费者仅仅在仓储有产品时候才能消费，仓空则等待。</li>
<li>当消费者发现仓储没产品可消费时候会通知生产者生产。</li>
<li>生产者在生产出可消费产品时候，应该通知等待的消费者去消费。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">package cn.thread;</div><div class="line">import java.util.concurrent.BlockingQueue;</div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line">import java.util.concurrent.LinkedBlockingQueue;</div><div class="line">/**</div><div class="line"> * java多线程模拟生产者消费者问题</div><div class="line"> * </div><div class="line"> * ProducerConsumer是主类，Producer生产者，Consumer消费者，Product产品，Storage仓库</div><div class="line"> * </div><div class="line"> * @author 林计钦</div><div class="line"> * @version 1.0 2013-7-24 下午04:49:02</div><div class="line"> */</div><div class="line">public class ProducerConsumer &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ProducerConsumer pc = new ProducerConsumer();</div><div class="line">        Storage s = pc.new Storage();</div><div class="line">        ExecutorService service = Executors.newCachedThreadPool();</div><div class="line">        Producer p = pc.new Producer(&quot;张三&quot;, s);</div><div class="line">        Producer p2 = pc.new Producer(&quot;李四&quot;, s);</div><div class="line">        Consumer c = pc.new Consumer(&quot;王五&quot;, s);</div><div class="line">        Consumer c2 = pc.new Consumer(&quot;老刘&quot;, s);</div><div class="line">        Consumer c3 = pc.new Consumer(&quot;老林&quot;, s);</div><div class="line">        service.submit(p);</div><div class="line">        //service.submit(p2);</div><div class="line">        service.submit(c);</div><div class="line">        service.submit(c2);</div><div class="line">        service.submit(c3);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 消费者</div><div class="line">     * </div><div class="line">     * @author 林计钦</div><div class="line">     * @version 1.0 2013-7-24 下午04:53:30</div><div class="line">     */</div><div class="line">    class Consumer implements Runnable &#123;</div><div class="line">        private String name;</div><div class="line">        private Storage s = null;</div><div class="line">        public Consumer(String name, Storage s) &#123;</div><div class="line">            this.name = name;</div><div class="line">            this.s = s;</div><div class="line">        &#125;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                while (true) &#123;</div><div class="line">                    System.out.println(name + &quot;准备消费产品.&quot;);</div><div class="line">                    Product product = s.pop();</div><div class="line">                    System.out.println(name + &quot;已消费(&quot; + product.toString() + &quot;).&quot;);</div><div class="line">                    System.out.println(&quot;===============&quot;);</div><div class="line">                    Thread.sleep(500);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 生产者</div><div class="line">     * </div><div class="line">     * @author 林计钦</div><div class="line">     * @version 1.0 2013-7-24 下午04:53:44</div><div class="line">     */</div><div class="line">    class Producer implements Runnable &#123;</div><div class="line">        private String name;</div><div class="line">        private Storage s = null;</div><div class="line">        public Producer(String name, Storage s) &#123;</div><div class="line">            this.name = name;</div><div class="line">            this.s = s;</div><div class="line">        &#125;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                while (true) &#123;</div><div class="line">                    Product product = new Product((int) (Math.random() * 10000)); // 产生0~9999随机整数</div><div class="line">                    System.out.println(name + &quot;准备生产(&quot; + product.toString() + &quot;).&quot;);</div><div class="line">                    s.push(product);</div><div class="line">                    System.out.println(name + &quot;已生产(&quot; + product.toString() + &quot;).&quot;);</div><div class="line">                    System.out.println(&quot;===============&quot;);</div><div class="line">                    Thread.sleep(500);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (InterruptedException e1) &#123;</div><div class="line">                e1.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 仓库，用来存放产品</div><div class="line">     * </div><div class="line">     * @author 林计钦</div><div class="line">     * @version 1.0 2013-7-24 下午04:54:16</div><div class="line">     */</div><div class="line">    public class Storage &#123;</div><div class="line">        BlockingQueue&lt;Product&gt; queues = new LinkedBlockingQueue&lt;Product&gt;(10);</div><div class="line">        /**</div><div class="line">         * 生产</div><div class="line">         * </div><div class="line">         * @param p</div><div class="line">         *            产品</div><div class="line">         * @throws InterruptedException</div><div class="line">         */</div><div class="line">        public void push(Product p) throws InterruptedException &#123;</div><div class="line">            queues.put(p);</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * 消费</div><div class="line">         * </div><div class="line">         * @return 产品</div><div class="line">         * @throws InterruptedException</div><div class="line">         */</div><div class="line">        public Product pop() throws InterruptedException &#123;</div><div class="line">            return queues.take();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 产品</div><div class="line">     * </div><div class="line">     * @author 林计钦</div><div class="line">     * @version 1.0 2013-7-24 下午04:54:04</div><div class="line">     */</div><div class="line">    public class Product &#123;</div><div class="line">        private int id;</div><div class="line">        public Product(int id) &#123;</div><div class="line">            this.id = id;</div><div class="line">        &#125;</div><div class="line">        public String toString() &#123;// 重写toString方法</div><div class="line">            return &quot;产品：&quot; + this.id;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>张三准备生产(产品：3359).</p>
<h1 id="张三已生产-产品：3359"><a href="#张三已生产-产品：3359" class="headerlink" title="张三已生产(产品：3359)."></a>张三已生产(产品：3359).</h1><p>老刘准备消费产品.</p>
<h1 id="王五已消费-产品：3359"><a href="#王五已消费-产品：3359" class="headerlink" title="王五已消费(产品：3359)."></a>王五已消费(产品：3359).</h1><p>王五准备消费产品.<br>张三准备生产(产品：1863).</p>
<h1 id="张三已生产-产品：1863"><a href="#张三已生产-产品：1863" class="headerlink" title="张三已生产(产品：1863)."></a>张三已生产(产品：1863).</h1><h1 id="老林已消费-产品：1863"><a href="#老林已消费-产品：1863" class="headerlink" title="老林已消费(产品：1863)."></a>老林已消费(产品：1863).</h1><p>老林准备消费产品.<br>张三准备生产(产品：5424).<br>张三已生产(产品：5424).</p>
<h1 id="老刘已消费-产品：5424"><a href="#老刘已消费-产品：5424" class="headerlink" title="老刘已消费(产品：5424)."></a>老刘已消费(产品：5424).</h1><p>===============<br>张三准备生产(产品：6290).</p>
<h1 id="张三已生产-产品：6290"><a href="#张三已生产-产品：6290" class="headerlink" title="张三已生产(产品：6290)."></a>张三已生产(产品：6290).</h1><p>老刘准备消费产品.</p>
<h1 id="王五已消费-产品：6290"><a href="#王五已消费-产品：6290" class="headerlink" title="王五已消费(产品：6290)."></a>王五已消费(产品：6290).</h1><p>张三准备生产(产品：990).</p>
<h1 id="张三已生产-产品：990"><a href="#张三已生产-产品：990" class="headerlink" title="张三已生产(产品：990)."></a>张三已生产(产品：990).</h1><h1 id="老林已消费-产品：990"><a href="#老林已消费-产品：990" class="headerlink" title="老林已消费(产品：990)."></a>老林已消费(产品：990).</h1><p>王五准备消费产品.<br>张三准备生产(产品：1971).<br>老林准备消费产品.</p>
<h1 id="老刘已消费-产品：1971"><a href="#老刘已消费-产品：1971" class="headerlink" title="老刘已消费(产品：1971)."></a>老刘已消费(产品：1971).</h1><h1 id="张三已生产-产品：1971"><a href="#张三已生产-产品：1971" class="headerlink" title="张三已生产(产品：1971)."></a>张三已生产(产品：1971).</h1><p>张三准备生产(产品：5622).<br>老刘准备消费产品.</p>
<h1 id="张三已生产-产品：5622"><a href="#张三已生产-产品：5622" class="headerlink" title="张三已生产(产品：5622)."></a>张三已生产(产品：5622).</h1><h1 id="王五已消费-产品：5622"><a href="#王五已消费-产品：5622" class="headerlink" title="王五已消费(产品：5622)."></a>王五已消费(产品：5622).</h1><p>王五准备消费产品.<br>张三准备生产(产品：6570).</p>
<h1 id="张三已生产-产品：6570"><a href="#张三已生产-产品：6570" class="headerlink" title="张三已生产(产品：6570)."></a>张三已生产(产品：6570).</h1><h1 id="老林已消费-产品：6570"><a href="#老林已消费-产品：6570" class="headerlink" title="老林已消费(产品：6570)."></a>老林已消费(产品：6570).</h1><p>老林准备消费产品.<br>张三准备生产(产品：17).</p>
<h1 id="老刘已消费-产品：17"><a href="#老刘已消费-产品：17" class="headerlink" title="老刘已消费(产品：17)."></a>老刘已消费(产品：17).</h1><h1 id="张三已生产-产品：17"><a href="#张三已生产-产品：17" class="headerlink" title="张三已生产(产品：17)."></a>张三已生产(产品：17).</h1><p>老刘准备消费产品.<br>张三准备生产(产品：7962).</p>
<h1 id="张三已生产-产品：7962"><a href="#张三已生产-产品：7962" class="headerlink" title="张三已生产(产品：7962)."></a>张三已生产(产品：7962).</h1><h1 id="王五已消费-产品：7962"><a href="#王五已消费-产品：7962" class="headerlink" title="王五已消费(产品：7962)."></a>王五已消费(产品：7962).</h1><p>王五准备消费产品.<br>张三准备生产(产品：3200).</p>
<h1 id="张三已生产-产品：3200"><a href="#张三已生产-产品：3200" class="headerlink" title="张三已生产(产品：3200)."></a>张三已生产(产品：3200).</h1><h1 id="老林已消费-产品：3200"><a href="#老林已消费-产品：3200" class="headerlink" title="老林已消费(产品：3200)."></a>老林已消费(产品：3200).</h1><p>老林准备消费产品.<br>张三准备生产(产品：7234).</p>
<h1 id="张三已生产-产品：7234"><a href="#张三已生产-产品：7234" class="headerlink" title="张三已生产(产品：7234)."></a>张三已生产(产品：7234).</h1><h1 id="老刘已消费-产品：7234"><a href="#老刘已消费-产品：7234" class="headerlink" title="老刘已消费(产品：7234)."></a>老刘已消费(产品：7234).</h1><p>老刘准备消费产品.<br>张三准备生产(产品：6486).</p>
<h1 id="张三已生产-产品：6486"><a href="#张三已生产-产品：6486" class="headerlink" title="张三已生产(产品：6486)."></a>张三已生产(产品：6486).</h1><h1 id="王五已消费-产品：6486"><a href="#王五已消费-产品：6486" class="headerlink" title="王五已消费(产品：6486)."></a>王五已消费(产品：6486).</h1><p>张三准备生产(产品：5436).<br>王五准备消费产品.</p>
<h1 id="王五已消费-产品：5436"><a href="#王五已消费-产品：5436" class="headerlink" title="王五已消费(产品：5436)."></a>王五已消费(产品：5436).</h1>
      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2014/11/12/java多线程之生产者消费者经典问题/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2014-10-02T06:32:57.000Z"><a href="/2014/10/02/单例模式（线程安全）/">2014-10-02</a></time>
        
  
    <h1 class="title"><a href="/2014/10/02/单例模式（线程安全）/">单例模式（线程安全）</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-饿汉式单例"><span class="toc-text">1. 饿汉式单例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-懒汉式单例"><span class="toc-text">2. 懒汉式单例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-线程安全的懒汉式单例"><span class="toc-text">3. 线程安全的懒汉式单例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-使用静态内置类实现单例模式"><span class="toc-text">4.使用静态内置类实现单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-使用static代码块实现单例"><span class="toc-text">5.使用static代码块实现单例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-使用枚举数据类型实现单例模式"><span class="toc-text">7.使用枚举数据类型实现单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-完善使用enum枚举实现单例模式"><span class="toc-text">8.完善使用enum枚举实现单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-多线程安全单例模式实例一-不使用同步锁"><span class="toc-text">1.多线程安全单例模式实例一(不使用同步锁)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-多线程安全单例模式实例二-使用同步方法"><span class="toc-text">2.多线程安全单例模式实例二(使用同步方法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-多线程安全单例模式实例三-使用双重同步锁"><span class="toc-text">3.多线程安全单例模式实例三(使用双重同步锁)</span></a></li></ol>
    </div>

        <p>&emsp;&emsp;单例模式就是说系统中对于某类的只能有一个对象，不可能出来第二个。<br>&emsp;&emsp;单例模式是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种模式方法<br>（1）、在任何情况下，单例类永远只有一个实例存在<br>（2）、单例需要有能力为整个系统提供这一唯一实例<br><strong>各式各样的单例实现</strong><br><strong>温馨提示：</strong>本文叙述中涉及到的相关源码可以在这里进行下载源码，读者可免积分下载。</p>
<h4 id="1-饿汉式单例"><a href="#1-饿汉式单例" class="headerlink" title="1. 饿汉式单例"></a>1. 饿汉式单例</h4><p>&emsp;&emsp;饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s01;  </div><div class="line">  </div><div class="line">public class MySingleton &#123;  </div><div class="line">      </div><div class="line">    private static MySingleton instance = new MySingleton();  </div><div class="line">      </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">      </div><div class="line">    public static MySingleton getInstance() &#123;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上是单例的饿汉式实现，我们来看看饿汉式在多线程下的执行情况，给出一段多线程的执行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s01;  </div><div class="line">  </div><div class="line">public class MyThread extends Thread&#123;  </div><div class="line">      </div><div class="line">    @Override  </div><div class="line">    public void run() &#123;   </div><div class="line">        System.out.println(MySingleton.getInstance().hashCode());  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public static void main(String[] args) &#123;   </div><div class="line">          </div><div class="line">        MyThread[] mts = new MyThread[10];  </div><div class="line">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;  </div><div class="line">            mts[i] = new MyThread();  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        for (int j = 0; j &lt; mts.length; j++) &#123;  </div><div class="line">            mts[j].start();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码运行结果：<br>1718900954<br>1718900954<br>1718900954<br>1718900954<br>1718900954<br>1718900954<br>1718900954<br>1718900954<br>1718900954<br>1718900954<br>从运行结果可以看出实例变量额hashCode值一致，这说明对象是同一个，饿汉式单例实现了。</p>
<h4 id="2-懒汉式单例"><a href="#2-懒汉式单例" class="headerlink" title="2. 懒汉式单例"></a>2. 懒汉式单例</h4><p>懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。下面是实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s02;  </div><div class="line">  </div><div class="line">public class MySingleton &#123;  </div><div class="line">      </div><div class="line">    private static MySingleton instance = null;  </div><div class="line">      </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">      </div><div class="line">    public static MySingleton getInstance() &#123;  </div><div class="line">        if(instance == null)&#123;//懒汉式  </div><div class="line">            instance = new MySingleton();  </div><div class="line">        &#125;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里实现了懒汉式的单例，但是熟悉多线程并发编程的朋友应该可以看出，在多线程并发下这样的实现是无法保证实例实例唯一的，甚至可以说这样的失效是完全错误的，下面我们就来看一下多线程并发下的执行情况，这里为了看到效果，我们对上面的代码做一小点修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s02;  </div><div class="line">  </div><div class="line">public class MySingleton &#123;  </div><div class="line">      </div><div class="line">    private static MySingleton instance = null;  </div><div class="line">      </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">      </div><div class="line">    public static MySingleton getInstance() &#123;  </div><div class="line">        try &#123;   </div><div class="line">            if(instance != null)&#123;//懒汉式   </div><div class="line">                  </div><div class="line">            &#125;else&#123;  </div><div class="line">                //创建实例之前可能会有一些准备性的耗时工作   </div><div class="line">                Thread.sleep(300);  </div><div class="line">                instance = new MySingleton();  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (InterruptedException e) &#123;   </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里假设在创建实例前有一些准备性的耗时工作要处理，多线程调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MyThread extends Thread&#123;  </div><div class="line">      </div><div class="line">    @Override  </div><div class="line">    public void run() &#123;   </div><div class="line">        System.out.println(MySingleton.getInstance().hashCode());  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public static void main(String[] args) &#123;   </div><div class="line">          </div><div class="line">        MyThread[] mts = new MyThread[10];  </div><div class="line">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;  </div><div class="line">            mts[i] = new MyThread();  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        for (int j = 0; j &lt; mts.length; j++) &#123;  </div><div class="line">            mts[j].start();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果如下：<br>[plain] view plain copy print?在CODE上查看代码片派生到我的代码片<br>1210420568<br>1210420568<br>1935123450<br>1718900954<br>1481297610<br>1863264879<br>369539795<br>1210420568<br>1210420568<br>602269801<br>从这里执行结果可以看出，单例的线程安全性并没有得到保证，那要怎么解决呢？</p>
<h4 id="3-线程安全的懒汉式单例"><a href="#3-线程安全的懒汉式单例" class="headerlink" title="3. 线程安全的懒汉式单例"></a>3. 线程安全的懒汉式单例</h4><p>&emsp;&emsp;要保证线程安全，我们就得需要使用同步锁机制，下面就来看看我们如何一步步的解决 存在线程安全问题的懒汉式单例（错误的单例）。<br>（1）、 方法中声明synchronized关键字<br>出现非线程安全问题，是由于多个线程可以同时进入getInstance()方法，那么只需要对该方法进行synchronized的锁同步即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s03;  </div><div class="line">  </div><div class="line">public class MySingleton &#123;  </div><div class="line">      </div><div class="line">    private static MySingleton instance = null;  </div><div class="line">      </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">      </div><div class="line">    public synchronized static MySingleton getInstance() &#123;  </div><div class="line">        try &#123;   </div><div class="line">            if(instance != null)&#123;//懒汉式   </div><div class="line">                  </div><div class="line">            &#125;else&#123;  </div><div class="line">                //创建实例之前可能会有一些准备性的耗时工作   </div><div class="line">                Thread.sleep(300);  </div><div class="line">                instance = new MySingleton();  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (InterruptedException e) &#123;   </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时任然使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入到org.mlinge.s03包下运行，执行结果如下：<br>1689058373<br>1689058373<br>1689058373<br>1689058373<br>1689058373<br>1689058373<br>1689058373<br>1689058373<br>1689058373<br>1689058373  </p>
<p>从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低。同步方法效率低，那我们考虑使用同步代码块来实现：<br>（2）、 同步代码块实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class MySingleton &#123;  </div><div class="line">      </div><div class="line">    private static MySingleton instance = null;  </div><div class="line">      </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">      </div><div class="line">    //public synchronized static MySingleton getInstance() &#123;  </div><div class="line">    public static MySingleton getInstance() &#123;  </div><div class="line">        try &#123;   </div><div class="line">            synchronized (MySingleton.class) &#123;  </div><div class="line">                if(instance != null)&#123;//懒汉式   </div><div class="line">                      </div><div class="line">                &#125;else&#123;  </div><div class="line">                    //创建实例之前可能会有一些准备性的耗时工作   </div><div class="line">                    Thread.sleep(300);  </div><div class="line">                    instance = new MySingleton();  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (InterruptedException e) &#123;   </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。<br>3）、 针对某些重要的代码来进行单独的同步（可能非线程安全）<br>针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率，我们来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s04;  </div><div class="line">  </div><div class="line">public class MySingleton &#123;  </div><div class="line">      </div><div class="line">    private static MySingleton instance = null;  </div><div class="line">      </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">       </div><div class="line">    public static MySingleton getInstance() &#123;  </div><div class="line">        try &#123;    </div><div class="line">            if(instance != null)&#123;//懒汉式   </div><div class="line">                  </div><div class="line">            &#125;else&#123;  </div><div class="line">                //创建实例之前可能会有一些准备性的耗时工作   </div><div class="line">                Thread.sleep(300);  </div><div class="line">                synchronized (MySingleton.class) &#123;  </div><div class="line">                    instance = new MySingleton();  </div><div class="line">                &#125;  </div><div class="line">            &#125;   </div><div class="line">        &#125; catch (InterruptedException e) &#123;   </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入到org.mlinge.s04包下运行，执行结果如下：</p>
<p>1481297610<br>397630378<br>1863264879<br>1210420568<br>1935123450<br>369539795<br>590202901<br>1718900954<br>1689058373<br>602269801  </p>
<p>从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题<br>（4）、 Double Check Locking 双检查锁机制（推荐）<br>为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s05;  </div><div class="line">  </div><div class="line">public class MySingleton &#123;  </div><div class="line">      </div><div class="line">    //使用volatile关键字保其可见性  </div><div class="line">    volatile private static MySingleton instance = null;  </div><div class="line">      </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">       </div><div class="line">    public static MySingleton getInstance() &#123;  </div><div class="line">        try &#123;    </div><div class="line">            if(instance != null)&#123;//懒汉式   </div><div class="line">                  </div><div class="line">            &#125;else&#123;  </div><div class="line">                //创建实例之前可能会有一些准备性的耗时工作   </div><div class="line">                Thread.sleep(300);  </div><div class="line">                synchronized (MySingleton.class) &#123;  </div><div class="line">                    if(instance == null)&#123;//二次检查  </div><div class="line">                        instance = new MySingleton();  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;   </div><div class="line">        &#125; catch (InterruptedException e) &#123;   </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将前面验证多线程下执行情况的MyThread类放入到org.mlinge.s05包下运行，执行结果如下：</p>
<p>369539795<br>369539795<br>369539795<br>369539795<br>369539795<br>369539795<br>369539795<br>369539795<br>369539795<br>369539795<br>从运行结果来看，该中方法保证了多线程并发下的线程安全性。<br>这里在声明变量时使用了volatile关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。</p>
<h4 id="4-使用静态内置类实现单例模式"><a href="#4-使用静态内置类实现单例模式" class="headerlink" title="4.使用静态内置类实现单例模式"></a>4.使用静态内置类实现单例模式</h4><p>DCL解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果，代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s06;  </div><div class="line">  </div><div class="line">public class MySingleton &#123;  </div><div class="line">      </div><div class="line">    //内部类  </div><div class="line">    private static class MySingletonHandler&#123;  </div><div class="line">        private static MySingleton instance = new MySingleton();  </div><div class="line">    &#125;   </div><div class="line">      </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">       </div><div class="line">    public static MySingleton getInstance() &#123;   </div><div class="line">        return MySingletonHandler.instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码就是使用静态内置类实现了单例模式，静态内部类实现的单例在多线程并发下单个实例得到了保证。</p>
<h4 id="5-使用static代码块实现单例"><a href="#5-使用static代码块实现单例" class="headerlink" title="5.使用static代码块实现单例"></a>5.使用static代码块实现单例</h4><p>静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s08;  </div><div class="line">  </div><div class="line">public class MySingleton&#123;  </div><div class="line">       </div><div class="line">    private static MySingleton instance = null;  </div><div class="line">       </div><div class="line">    private MySingleton()&#123;&#125;  </div><div class="line">  </div><div class="line">    static&#123;  </div><div class="line">        instance = new MySingleton();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public static MySingleton getInstance() &#123;   </div><div class="line">        return instance;  </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s08;  </div><div class="line">  </div><div class="line">public class MyThread extends Thread&#123;  </div><div class="line">      </div><div class="line">    @Override  </div><div class="line">    public void run() &#123;   </div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;  </div><div class="line">            System.out.println(MySingleton.getInstance().hashCode());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public static void main(String[] args) &#123;   </div><div class="line">          </div><div class="line">        MyThread[] mts = new MyThread[3];  </div><div class="line">        for(int i = 0 ; i &lt; mts.length ; i++)&#123;  </div><div class="line">            mts[i] = new MyThread();  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        for (int j = 0; j &lt; mts.length; j++) &#123;  </div><div class="line">            mts[j].start();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-使用枚举数据类型实现单例模式"><a href="#7-使用枚举数据类型实现单例模式" class="headerlink" title="7.使用枚举数据类型实现单例模式"></a>7.使用枚举数据类型实现单例模式</h4><p>枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s09;  </div><div class="line">  </div><div class="line">public enum EnumFactory&#123;   </div><div class="line">      </div><div class="line">    singletonFactory;  </div><div class="line">      </div><div class="line">    private MySingleton instance;  </div><div class="line">      </div><div class="line">    private EnumFactory()&#123;//枚举类的构造方法在类加载是被实例化  </div><div class="line">        instance = new MySingleton();  </div><div class="line">    &#125;  </div><div class="line">          </div><div class="line">    public MySingleton getInstance()&#123;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">class MySingleton&#123;//需要获实现单例的类，比如数据库连接Connection  </div><div class="line">    public MySingleton()&#123;&#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这样写枚举类被完全暴露了，据说违反了“职责单一原则”，那我们来看看怎么进行改造呢。</p>
<h4 id="8-完善使用enum枚举实现单例模式"><a href="#8-完善使用enum枚举实现单例模式" class="headerlink" title="8.完善使用enum枚举实现单例模式"></a>8.完善使用enum枚举实现单例模式</h4><p>不暴露枚举类实现细节的封装代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package org.mlinge.s10;  </div><div class="line">  </div><div class="line">public class ClassFactory&#123;   </div><div class="line">      </div><div class="line">    private enum MyEnumSingleton&#123;  </div><div class="line">        singletonFactory;  </div><div class="line">          </div><div class="line">        private MySingleton instance;  </div><div class="line">          </div><div class="line">        private MyEnumSingleton()&#123;//枚举类的构造方法在类加载是被实例化  </div><div class="line">            instance = new MySingleton();  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        public MySingleton getInstance()&#123;  </div><div class="line">            return instance;  </div><div class="line">        &#125;  </div><div class="line">    &#125;   </div><div class="line">   </div><div class="line">    public static MySingleton getInstance()&#123;  </div><div class="line">        return MyEnumSingleton.singletonFactory.getInstance();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">class MySingleton&#123;//需要获实现单例的类，比如数据库连接Connection  </div><div class="line">    public MySingleton()&#123;&#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="1-多线程安全单例模式实例一-不使用同步锁"><a href="#1-多线程安全单例模式实例一-不使用同步锁" class="headerlink" title="1.多线程安全单例模式实例一(不使用同步锁)"></a>1.多线程安全单例模式实例一(不使用同步锁)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton sin=new Singleton();    ///直接初始化一个实例对象</div><div class="line">    private Singleton()&#123;    ///private类型的构造函数，保证其他类对象不能直接new一个该对象的实例</div><div class="line">	&#125;</div><div class="line">    public static Singleton getSin()&#123;    ///该类唯一的一个public方法   </div><div class="line">	return sin;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中的一个缺点是该类加载的时候就会直接new 一个静态对象出来，当系统中这样的类较多时，会使得启动速度变慢 。现在流行的设计都是讲“延迟加载”，我们可以在第一次使用的时候才初始化第一个该类对象。所以这种适合在小系统。 </p>
<h4 id="2-多线程安全单例模式实例二-使用同步方法"><a href="#2-多线程安全单例模式实例二-使用同步方法" class="headerlink" title="2.多线程安全单例模式实例二(使用同步方法)"></a>2.多线程安全单例模式实例二(使用同步方法)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">      private static Singleton instance;  </div><div class="line">      private Singleton ()&#123;</div><div class="line">       &#125;   </div><div class="line">     public static synchronized Singleton getInstance()&#123;    //对获取实例的方法进行同步</div><div class="line">	 if (instance == null)     </div><div class="line">        instance = new Singleton(); </div><div class="line">        return instance;</div><div class="line">		&#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>上述代码中的一次锁住了一个方法， 这个粒度有点大 ，改进就是只锁住其中的new语句就OK。就是所谓的“双重锁”机制。</p>
<h4 id="3-多线程安全单例模式实例三-使用双重同步锁"><a href="#3-多线程安全单例模式实例三-使用双重同步锁" class="headerlink" title="3.多线程安全单例模式实例三(使用双重同步锁)"></a>3.多线程安全单例模式实例三(使用双重同步锁)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">      private static Singleton instance;  </div><div class="line">      private Singleton ()&#123;</div><div class="line">      &#125;   </div><div class="line">      public static Singleton getInstance()&#123;    //对获取实例的方法进行同步 </div><div class="line">      if (instance == null)&#123;</div><div class="line">            synchronized(Singleton.class)&#123;</div><div class="line">                if (instance == null)</div><div class="line">                   instance = new Singleton(); </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2014/10/02/单例模式（线程安全）/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2014-09-16T06:32:57.000Z"><a href="/2014/09/16/java-IO流设计模式之装饰模式/">2014-09-16</a></time>
        
  
    <h1 class="title"><a href="/2014/09/16/java-IO流设计模式之装饰模式/">java IO流设计模式之装饰模式</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>&emsp;&emsp;装饰模式是Java I/O库的基本模式。在这里我想再用&lt;<head first="" design="" pattern="">&gt;中讲到装饰模式时候的一个例子，看看装饰模式是怎么达到不仅类的数目大减少了，性能的重复也可以减至到最少：<br><img src="https://note.wiz.cn/api/document/files/unzip/eb3eff32-254c-4783-ad5b-3204cdd5bf82/4d607112-bdb0-47ca-99ef-704d6d3dbd2e.348/index_files/3e004875-427a-409f-9780-b890f627b52f.png" alt=""> </head></p>
<p>&emsp;&emsp;看到了上面的类图了吗，我们不禁会说这就是“类爆炸”。如果是按装饰模式的设计思路我们可以得出下面的设计类图：<br><img src="https://note.wiz.cn/api/document/files/unzip/eb3eff32-254c-4783-ad5b-3204cdd5bf82/4d607112-bdb0-47ca-99ef-704d6d3dbd2e.348/index_files/6ee0971c-e805-465f-8d60-515389840b10.png" alt=""></p>
<p>&emsp;&emsp;再回到Java I/O库，由于装饰模式的引用，造成了灵活性和复杂都大大增加了，我们在使用Java I/O库时，必须理解Java &emsp;&emsp;I/O库是由一些基本的原始流处理器和围绕它们的装饰流处理器所组成的，这样可以在学习和使用Java I/O库时达到事半功倍的效果。<br>&emsp;&emsp;首先是InputStream类型中的装饰模式：<br><img src="https://note.wiz.cn/api/document/files/unzip/eb3eff32-254c-4783-ad5b-3204cdd5bf82/4d607112-bdb0-47ca-99ef-704d6d3dbd2e.348/index_files/b5870751-3c90-4c03-a299-c3e76f52a7f2.png" alt=""><br>&emsp;&emsp;上图中所有的类都叫做流处理器，这个图就叫做（InputStream类型的）流处理器图。<br>　　&emsp;&emsp;书中提到根据输入流的源的类型，可以将这些流类分成两种，即原始流类（Original Stream）和链接流处理器（Wrapper Stream）。<br>　　<strong>原始流处理器</strong><br>　　&emsp;&emsp;原始流处理器接收一个Byte数组对象，String对象，FileDiscriptor对象或者不同类型的流源对象，根据上面的图，原始流处理器包括以下四种：<br>　　ByteArrayInputStream：为多线程的通信提供缓冲区操作功能，接收一个Byte数组作为流的源。<br>　　FileInputStream:建立一个与文件有关的输入流。接收一个File对象作为流的源。<br>　　PipedInputStream：可以与PipedOutputStream配合使用，用于读入一个数据管道的数据，接收一个PipedOutputStream作为源。<br>　　StringBufferInputStream：将一个字符串缓冲区转换为一个输入流。接收一个String对象作为流的源。（ＪＤＫ帮助文档上说明：已过时。此类未能正确地将字符转换为字节。从&emsp;&emsp;ＪＤＫ1.1开始，从字符串创建流的首选方法是通过StringReader类进行创建。只有字符串中每个字符的低八位可以由此类使用。）<br>       <strong>链接流处理器</strong><br>　　&emsp;&emsp;所谓链接流处理器，就是可以接收另一个流对象作为源，并对之进行功能扩展的类。InputStream类型的链接处理器包括以下几种，它们都接收另一个InputStream对象作为流源。<br>　　（１）FilterInputStream称为过滤输入流，它将另一个输入流作为流源。这个类的子类包括以下几种：<br>　　BufferedInputStream：用来从硬盘将数据读入到一个内存缓冲区中，并从缓冲区提供数据。<br>　　DataInputStream：提供基于多字节的读取方法，可以读取原始类型的数据。<br>　　LineNumberInputStream：提供带有行计数功能的过滤输入流。<br>　　PushbackInputStream：提供特殊的功能，可以将已经读取的字节“推回”到输入流中。<br>　　（２）ObjectInputStream可以将使用ObjectInputStream串行化的原始数据类型和对象重新并行化。<br>　　（３）SeqcueneInputStream可以将两个已有的输入流连接起来，形成一个输入流，从而将多个输入流排列构成一个输入流序列。<br>　<strong>抽象结构图</strong><br>　　&emsp;&emsp;按照上面的这种原始流处理器和链接流处理器的划分，可以用下面的结构图来描述它们之间的关系。<br><img src="https://note.wiz.cn/api/document/files/unzip/eb3eff32-254c-4783-ad5b-3204cdd5bf82/4d607112-bdb0-47ca-99ef-704d6d3dbd2e.348/index_files/5b66d0fa-7430-47d1-ada8-d8f4e0659521.png" alt=""></p>
<p>&emsp;&emsp;上面的流处理器图跟装饰模式的结构图有着显而易见的相同之处。实际上InputStream类型的流处理器结构确实符合装饰模式。　<br>　<strong>装饰模式结构图</strong><br><img src="https://note.wiz.cn/api/document/files/unzip/eb3eff32-254c-4783-ad5b-3204cdd5bf82/4d607112-bdb0-47ca-99ef-704d6d3dbd2e.348/index_files/3d7c2914-4e65-4d3b-b1bb-c9b2fab57ca6.png" alt=""></p>
<p>&emsp;&emsp;FilterInputStream继承了InputStream,也引用了InputStream,而它有四个子类,这就是所谓的Decorator模式<br>&emsp;&emsp;上面这个图向我们传达了这个信息：链接流链接流对象接收一个原始流对象或者另外一个链接流对象作为流源；另一方面他们对流源的内部工作方法做了相应的改变，这种改变是装饰模式所要达到的目的。比如：<br>　　&emsp;&emsp;BufferedInputStream“装饰”了InputStream的内部工作方式，使得流的读入操作使用了缓冲机制。在使用了缓冲机制后，不会对每一次的流读入操作都产生一个物理的读盘动作，从而提高了程序的效率，在汲及到物理流的读入时，都应当使用这个装饰流类。<br>　　&emsp;&emsp;LineNumberInputStream和PushbackInputStream也同样“装饰”了InputStream的内部工作方式，前者使得程序能够按照行号读入数据；后者能够使程序读入的过程中，退后一个字符。<br>　　&emsp;&emsp;DataInputStream子类读入各种不同的原始数据类型以及String类型的数据，这一点可以从它提供的各种read方法看出来，如：readByte(),readInt(),readFloat()等。</p>
<p> &emsp;&emsp;Java语言的I/O库提供了四大等级结构:InputStream,OutputStream,Reader,Writer四个系列的类。InputStream和OutputStream处理8位字节流数据, Reader和Writer处理16位的字符流数据。InputStream和Reader处理输入, OutputStream和Writer处理输出，所以OutputStream,Reader,Writer这三类的装饰模式跟前面详细介绍的InputStream装饰模式大同小异，大家可以看书中其它部分对这三类的详细描述或者从网上也能找到有关资料。为了方便比较这几种类型，顺便附上Java语言的I/O层次结构图：<br>　下面的图表示:以InputStream和OutputStream形成的层次关系<br><img src="https://note.wiz.cn/api/document/files/unzip/eb3eff32-254c-4783-ad5b-3204cdd5bf82/4d607112-bdb0-47ca-99ef-704d6d3dbd2e.348/index_files/ea0eab15-b242-4bd4-97ce-34d542ab2395.png" alt=""></p>
<p>&emsp;&emsp;下面的图表示:以Reader和Writer形成的层次关系 </p>
<p><img src="https://note.wiz.cn/api/document/files/unzip/eb3eff32-254c-4783-ad5b-3204cdd5bf82/4d607112-bdb0-47ca-99ef-704d6d3dbd2e.348/index_files/5080179c-4f17-41ef-a22e-165bf786f816.png" alt=""></p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2014/09/16/java-IO流设计模式之装饰模式/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2014-09-04T06:32:57.000Z"><a href="/2014/09/04/JAVA设计模式初探之装饰者模式/">2014-09-04</a></time>
        
  
    <h1 class="title"><a href="/2014/09/04/JAVA设计模式初探之装饰者模式/">JAVA设计模式初探之装饰者模式</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>&emsp;&emsp;这个模式花费了挺长时间，开始有点难理解，其实就是<br>定义：动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活。<br>&emsp;&emsp;设计初衷:通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的。</p>
<p><strong>要点</strong>：装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为<br>在装饰模式中的各个角色有：<br>（1）抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。（Human）</p>
<p>（2）具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。（person）</p>
<p>（3）装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口（Human）。</p>
<p>（4）具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</p>
<p><strong>设计原则</strong></p>
<ol>
<li><p>多用组合，少用继承。<br>利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。</p>
</li>
<li><p>类应设计的对扩展开放，对修改关闭。</p>
</li>
</ol>
<p><strong>模式简化</strong></p>
<ol>
<li><p>如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。</p>
</li>
<li><p>如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。</p>
</li>
</ol>
<p><strong>适用性：</strong></p>
<p>以下情况使用Decorator模式</p>
<ol>
<li><p>需要扩展一个类的功能，或给一个类添加附加职责。</p>
</li>
<li><p>需要动态的给一个对象添加功能，这些功能可以再动态的撤销。</p>
</li>
<li><p>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</p>
</li>
<li><p>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li><p>Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</p>
</li>
<li><p>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</p>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</p>
</li>
<li><p>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</p>
</li>
<li><p>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</p>
</li>
</ol>
<p>装饰模式在Java I/O库中的应用： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">   实际上Java 的I/O API就是使用Decorator实现的。</div><div class="line">//定义被装饰者</div><div class="line">public interface Human &#123;</div><div class="line">	public void wearClothes();</div><div class="line">	public void walkToWhere();</div><div class="line">&#125;</div><div class="line">//定义装饰者</div><div class="line">public abstract class Decorator implements Human &#123;</div><div class="line">	private Human human;</div><div class="line">	public Decorator(Human human) &#123;</div><div class="line">		this.human = human;</div><div class="line">	&#125;</div><div class="line">	public void wearClothes() &#123;</div><div class="line">		human.wearClothes();</div><div class="line">	&#125;</div><div class="line">	public void walkToWhere() &#123;</div><div class="line">		human.walkToWhere();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//下面定义三种装饰，这是第一个，第二个第三个功能依次细化，即装饰者的功能越来越多</div><div class="line">public class Decorator_zero extends Decorator &#123;</div><div class="line">	public Decorator_zero(Human human) &#123;</div><div class="line">		super(human);</div><div class="line">	&#125;</div><div class="line">	public void goHome() &#123;</div><div class="line">		System.out.println(&quot;进房子。。&quot;);</div><div class="line">	&#125;</div><div class="line">	public void findMap() &#123;</div><div class="line">		System.out.println(&quot;书房找找Map。。&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void wearClothes() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		super.wearClothes();</div><div class="line">		goHome();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void walkToWhere() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		super.walkToWhere();</div><div class="line">		findMap();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Decorator_first extends Decorator &#123;</div><div class="line">	public Decorator_first(Human human) &#123;</div><div class="line">		super(human);</div><div class="line">	&#125;</div><div class="line">	public void goClothespress() &#123;</div><div class="line">		System.out.println(&quot;去衣柜找找看。。&quot;);</div><div class="line">	&#125;</div><div class="line">	public void findPlaceOnMap() &#123;</div><div class="line">		System.out.println(&quot;在Map上找找。。&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void wearClothes() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		super.wearClothes();</div><div class="line">		goClothespress();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void walkToWhere() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		super.walkToWhere();</div><div class="line">		findPlaceOnMap();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Decorator_two extends Decorator &#123;</div><div class="line">	public Decorator_two(Human human) &#123;</div><div class="line">		super(human);</div><div class="line">	&#125;</div><div class="line">	public void findClothes() &#123;</div><div class="line">		System.out.println(&quot;找到一件D&amp;G。。&quot;);</div><div class="line">	&#125;</div><div class="line">	public void findTheTarget() &#123;</div><div class="line">		System.out.println(&quot;在Map上找到神秘花园和城堡。。&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void wearClothes() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		super.wearClothes();</div><div class="line">		findClothes();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void walkToWhere() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		super.walkToWhere();</div><div class="line">		findTheTarget();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//定义被装饰者，被装饰者初始状态有些自己的装饰</div><div class="line">public class Person implements Human &#123;</div><div class="line">	@Override</div><div class="line">	public void wearClothes() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(&quot;穿什么呢。。&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void walkToWhere() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(&quot;去哪里呢。。&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//测试类，看一下你就会发现，跟java的I/O操作有多么相似</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Human person = new Person();</div><div class="line">		Decorator decorator = new Decorator_two(new Decorator_first(</div><div class="line">				new Decorator_zero(person)));</div><div class="line">		decorator.wearClothes();</div><div class="line">		decorator.walkToWhere();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是进房子找衣服，然后找地图这样一个过程，通过装饰者的三层装饰，把细节变得丰富。<br><strong>关键点：</strong><br>1、Decorator抽象类中，持有Human接口，方法全部委托给该接口调用，目的是交给该接口的实现类即子类进行调用。<br>2、Decorator抽象类的子类（具体装饰者），里面都有一个构造方法调用super(human),这一句就体现了抽象类依赖于子类实现即抽象依赖于实现的原则。因为构造里面参数都是Human接口，只要是该Human的实现类都可以传递进去，即表现出Decorator dt = new Decorator_second(new Decorator_first(new Decorator_zero(human)));这种结构的样子。所以当调用dt.wearClothes();dt.walkToWhere()的时候，又因为每个具体装饰者类中，都先调用super.wearClothes和super.walkToWhere()方法，而该super已经由构造传递并指向了具体的某一个装饰者类（这个可以根据需要调换顺序），那么调用的即为装饰类的方法，然后才调用自身的装饰方法，即表现出一种装饰、链式的类似于过滤的行为。<br>3、具体被装饰者类，可以定义初始的状态或者初始的自己的装饰，后面的装饰行为都在此基础上一步一步进行点缀、装饰。<br>4、装饰者模式的设计原则为：对扩展开放、对修改关闭，这句话体现在我如果想扩展被装饰者类的行为，无须修改装饰者抽象类，只需继承装饰者抽象类，实现额外的一些装饰或者叫行为即可对被装饰者进行包装。所以：扩展体现在继承、修改体现在子类中，而不是具体的抽象类，这充分体现了依赖倒置原则，这是自己理解的装饰者模式。</p>
<p>&emsp;&emsp;说的不清楚，有些只可意会不可言传的感觉，多看几遍代码，然后自己敲出来运行一下，基本上就领悟了。</p>
<p>&emsp;&emsp;下面这个例子也有助于理解 装饰的流程和作用<br>现在需要一个汉堡，主体是鸡腿堡，可以选择添加生菜、酱、辣椒等等许多其他的配料，这种情况下就可以使用装饰者模式。</p>
<p>汉堡基类（被装饰者，相当于上面的Human）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package decorator;  </div><div class="line">  </div><div class="line">public abstract class Humburger &#123;  </div><div class="line">      </div><div class="line">    protected  String name ;  </div><div class="line">      </div><div class="line">    public String getName()&#123;  </div><div class="line">        return name;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public abstract double getPrice();  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>鸡腿堡类（被装饰者的初始状态，有些自己的简单装饰，相当于上面的Person）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package decorator;  </div><div class="line">  </div><div class="line">public class ChickenBurger extends Humburger &#123;  </div><div class="line">      </div><div class="line">    public ChickenBurger()&#123;  </div><div class="line">        name = &quot;鸡腿堡&quot;;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public double getPrice() &#123;  </div><div class="line">        return 10;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125; </div><div class="line">``` </div><div class="line">配料的基类（装饰者，用来对汉堡进行多层装饰，每层装饰增加一些配料，相当于上面Decorator）</div></pre></td></tr></table></figure></p>
<p>package decorator;  </p>
<p>public abstract class Condiment extends Humburger {  </p>
<pre><code>public abstract String getName();  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">生菜（装饰者的第一层，相当于上面的decorator_zero）</div></pre></td></tr></table></figure></p>
<p>package decorator;  </p>
<p>public class Lettuce extends Condiment {  </p>
<pre><code>Humburger humburger;  

public Lettuce(Humburger humburger){  
    this.humburger = humburger;  
}  

@Override  
public String getName() {  
    return humburger.getName()+&quot; 加生菜&quot;;  
}  

@Override  
public double getPrice() {  
    return humburger.getPrice()+1.5;  
}  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">辣椒（装饰者的第二层，相当于上面的decorator_first）</div></pre></td></tr></table></figure></p>
<p>package decorator;  </p>
<p>public class Chilli extends Condiment {  </p>
<pre><code>Humburger humburger;  

public Chilli(Humburger humburger){  
    this.humburger = humburger;  

}  

@Override  
public String getName() {  
    return humburger.getName()+&quot; 加辣椒&quot;;  
}  

@Override  
public double getPrice() {  
    return humburger.getPrice();  //辣椒是免费的哦  
}  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">测试类</div></pre></td></tr></table></figure></p>
<p>package decorator;  </p>
<p>public class Test {  </p>
<pre><code>/** 
 * @param args 
 */  
public static void main(String[] args) {  
    Humburger humburger = new ChickenBurger();  
    System.out.println(humburger.getName()+&quot;  价钱：&quot;+humburger.getPrice());  
    Lettuce lettuce = new Lettuce(humburger);  
    System.out.println(lettuce.getName()+&quot;  价钱：&quot;+lettuce.getPrice());  
    Chilli chilli = new Chilli(humburger);  
    System.out.println(chilli.getName()+&quot;  价钱：&quot;+chilli.getPrice());  
    Chilli chilli2 = new Chilli(lettuce);  
    System.out.println(chilli2.getName()+&quot;  价钱：&quot;+chilli2.getPrice());  
}  
</code></pre><p>}<br>```<br>输出<br>鸡腿堡  价钱：10.0<br>鸡腿堡 加生菜  价钱：11.5<br>鸡腿堡 加辣椒  价钱：10.0<br>鸡腿堡 加生菜 加辣椒  价钱：11.5  </p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2014/09/04/JAVA设计模式初探之装饰者模式/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2014-08-22T06:32:57.000Z"><a href="/2014/08/22/java之单例模式/">2014-08-22</a></time>
        
  
    <h1 class="title"><a href="/2014/08/22/java之单例模式/">java之单例模式</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>Java中的五种单例模式实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">package singleton;</div><div class="line"> </div><div class="line">/**</div><div class="line"> * @author chensi</div><div class="line"> * 单例模式的五种写法：</div><div class="line"> * 1、懒汉</div><div class="line"> * 2、恶汉</div><div class="line"> * 3、静态内部类</div><div class="line"> * 4、枚举</div><div class="line"> * 5、双重校验锁</div><div class="line"> */</div><div class="line">/**</div><div class="line"> *五、 双重校验锁，在当前的内存模型中无效</div><div class="line"> */</div><div class="line">class LockSingleton&#123;</div><div class="line">    private volatile static LockSingleton singleton;</div><div class="line">    private LockSingleton()&#123;&#125;</div><div class="line">     </div><div class="line">    //详见：http://www.ibm.com/developerworks/cn/java/j-dcl.html</div><div class="line">    public static LockSingleton getInstance()&#123;</div><div class="line">        if(singleton==null)&#123;</div><div class="line">            synchronized(LockSingleton.class)&#123;</div><div class="line">                if(singleton==null)&#123;</div><div class="line">                    singleton=new LockSingleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 四、枚举，《Effective Java》作者推荐使用的方法，优点：不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</div><div class="line"> */</div><div class="line">enum EnumSingleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">    public void doSomeThing()&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 三、静态内部类 优点：加载时不会初始化静态变量INSTANCE，因为没有主动使用，达到Lazy loading</div><div class="line"> */</div><div class="line">class InternalSingleton&#123;</div><div class="line">    private static class SingletonHolder&#123;</div><div class="line">        private final static  InternalSingleton INSTANCE=new InternalSingleton();</div><div class="line">    &#125;   </div><div class="line">    private InternalSingleton()&#123;&#125;</div><div class="line">    public static InternalSingleton getInstance()&#123;</div><div class="line">        return SingletonHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 二、恶汉,缺点：没有达到lazy loading的效果</div><div class="line"> */</div><div class="line">class HungrySingleton&#123;</div><div class="line">    private static HungrySingleton singleton=new HungrySingleton();</div><div class="line">    private HungrySingleton()&#123;&#125;</div><div class="line">    public static HungrySingleton getInstance()&#123;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 一、懒汉，常用的写法</div><div class="line"> */</div><div class="line">class LazySingleton&#123;</div><div class="line">    private static LazySingleton singleton;</div><div class="line">    private LazySingleton()&#123;</div><div class="line">    &#125;</div><div class="line">    public static LazySingleton getInstance()&#123;</div><div class="line">        if(singleton==null)&#123;</div><div class="line">            singleton=new LazySingleton();</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1.饿汉式单例类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//饿汉式单例类.在类初始化时，已经自行实例化 </div><div class="line">public class Singleton1 &#123;</div><div class="line">    //私有的默认构造子</div><div class="line">    private Singleton1() &#123;&#125;</div><div class="line">    //已经自行实例化 </div><div class="line">    private static final Singleton1 single = new Singleton1();</div><div class="line">    //静态工厂方法 </div><div class="line">    public static Singleton1 getInstance() &#123;</div><div class="line">        return single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.懒汉式单例类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//懒汉式单例类.在第一次调用的时候实例化 </div><div class="line">public class Singleton2 &#123;</div><div class="line">    //私有的默认构造子</div><div class="line">    private Singleton2() &#123;&#125;</div><div class="line">    //注意，这里没有final    </div><div class="line">    private static Singleton2 single=null;</div><div class="line">    //静态工厂方法 </div><div class="line">    public synchronized  static Singleton2 getInstance() &#123;</div><div class="line">         if (single == null) &#123;  </div><div class="line">             single = new Singleton2();</div><div class="line">         &#125;  </div><div class="line">        return single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.登记式单例类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">//登记式单例类.</div><div class="line">//类似Spring里面的方法，将类名注册，下次从里面直接获取。</div><div class="line">public class Singleton3 &#123;</div><div class="line">    private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;();</div><div class="line">    static&#123;</div><div class="line">        Singleton3 single = new Singleton3();</div><div class="line">        map.put(single.getClass().getName(), single);</div><div class="line">    &#125;</div><div class="line">    //保护的默认构造子</div><div class="line">    protected Singleton3()&#123;&#125;</div><div class="line">    //静态工厂方法,返还此类惟一的实例</div><div class="line">    public static Singleton3 getInstance(String name) &#123;</div><div class="line">        if(name == null) &#123;</div><div class="line">            name = Singleton3.class.getName();</div><div class="line">            System.out.println(&quot;name == null&quot;+&quot;---&gt;name=&quot;+name);</div><div class="line">        &#125;</div><div class="line">        if(map.get(name) == null) &#123;</div><div class="line">            try &#123;</div><div class="line">                map.put(name, (Singleton3) Class.forName(name).newInstance());</div><div class="line">            &#125; catch (InstantiationException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (IllegalAccessException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return map.get(name);</div><div class="line">    &#125;</div><div class="line">    //一个示意性的商业方法</div><div class="line">    public String about() &#123;    </div><div class="line">        return &quot;Hello, I am RegSingleton.&quot;;    </div><div class="line">    &#125;    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Singleton3 single3 = Singleton3.getInstance(null);</div><div class="line">        System.out.println(single3.about());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2014/08/22/java之单例模式/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



 
<nav id="pagination">
  
    <a href="/page/9/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/11/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
      <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title" id="categories">分类</h3>
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cordova/">Cordova</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQTT/">MQTT</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSL/">SSL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安卓直播开发/">安卓直播开发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">7</span></li></ul> 
</div>
 


  <div class="widget tag">
  <h3 class="title">微信公众账号</h3>
    <ul class="entry">
      <img src="/img/default/wx.png" alt="欢迎关注，该账号供个人学习使用，主要分享安卓开发技术以及前沿技术。" style= "width: 100%">
    </ul>
</div>

  <div class="widget tag">
  <h3 class="title">日历云</h3>
  <div id="calendar"></div>
</div>


  
<div class="widget">
  <h3 class="title">最新评论</h3>
  	<!-- 多说最新评论 start -->
	<div class="ds-recent-comments ds-recent-user" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div>
	<!-- 多说最新评论 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"samychen"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
	<!-- 多说公共JS代码 end -->
</div>



  


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Cordova/" style="font-size: 15px;">Cordova</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MQTT/" style="font-size: 11.67px;">MQTT</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/SSL，Https/" style="font-size: 13.33px;">SSL，Https</a> <a href="/tags/SSL，Https，安卓/" style="font-size: 10px;">SSL，Https，安卓</a> <a href="/tags/单例模式/" style="font-size: 11.67px;">单例模式</a> <a href="/tags/安卓/" style="font-size: 16.67px;">安卓</a> <a href="/tags/安卓，Java/" style="font-size: 18.33px;">安卓，Java</a> <a href="/tags/工厂模式/" style="font-size: 10px;">工厂模式</a> <a href="/tags/生产者消费者模式/" style="font-size: 11.67px;">生产者消费者模式</a> <a href="/tags/网络协议/" style="font-size: 10px;">网络协议</a> <a href="/tags/装饰者模式/" style="font-size: 11.67px;">装饰者模式</a>
  </div>
</div>


  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">公元 2017 年</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">公元 2016 年</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">公元 2015 年</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/">公元 2014 年</a><span class="archive-list-count">10</span></li></ul>
  </div>

</aside>
      <div class="clearfix"></div>
    </div>
  
  <footer id="footer"><div class="footer-content inner">
  <div class="alignleft">
  
    &copy; 2018 SamyChen
    
  </div>
  <div class="alignright">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
    <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
  </div>
  
  <div class="visit">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </div>
  
  <div class="clearfix"></div>
</div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'calendar'});
    
    });
  </script>


<!-- 『不蒜子』计数服务 -->
<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- wumii关联推荐 -->
<script type="text/javascript" src="http://widget.wumii.cn/ext/relatedItemsWidget"></script>

<!-- 百度推荐 -->

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?9acf0cedd48dc53be256ede5a98c2aaa";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

<!-- 站内搜索-Swiftype -->
<!-- <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','sC-iNFrvTTNtiXEVNwo1','2.0.0');
</script> -->

<!-- fancybox -->

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
