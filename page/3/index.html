<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | SamyChen</title>
  <meta name="author" content="SamyChen">
  
  <meta name="description" content="学习总结 思考感悟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="SamyChen"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link rel="alternate" href="/atom.xml" title="SamyChen" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <!-- wumiiVerification -->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!-- Font-Awesome -->
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">

</head>

<body>
  <header id="header"><div class= "header-content inner">
	<div class = "alignleft col-one">
		
			<div class='avatar'>
				<img src = "/img/default/head.jpg">
              </div>
		
		<div class="header-div">
		    <h1><a href="/">SamyChen</a></h1>
		    <h2><a href="/">SamyChen的博客</a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
            <div class="ad">
			<img src = "/img/default/head.jpg">
            </div>
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div class='header-nav-content inner'>
		<div id="main-nav" class="alignleft">
		    		
		    		  <a href="/"><i class="fa fa-home"></i>首页</a>
		    		
		    		  <a href="/archives"><i class="fa fa-archive"></i>归档</a>
		    		
		    		  <a href="/hexo"><i class="fa fa-book"></i>电子书</a>
		    		
		    		  <a href="/about"><i class="fa fa-user"></i>关于我</a>
		    		
		</div>
		<div id="sub-nav" class="alignright">
		    
		      <a href="/atom.xml"><i class="fa fa-rss"></i>订阅</a>
		    
		      <a href="/customization"><i class="fa fa-question-circle"></i>留言</a>
		    
		</div>
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
    <div id="content" class="inner">
      <div id="main-col" class="alignleft"><div id="wrapper">
    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-06-07T08:09:54.000Z"><a href="/2016/06/07/App启动优化/">2016-06-07</a></time>
        
  
    <h1 class="title"><a href="/2016/06/07/App启动优化/">App启动优化</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、工具：adb-或Python"><span class="toc-text">一、工具：adb 或Python</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、热启动"><span class="toc-text">二、热启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、冷启动"><span class="toc-text">三、冷启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么会出现白屏"><span class="toc-text">为什么会出现白屏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何缩短初始化时间"><span class="toc-text">如何缩短初始化时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>

        <p>&emsp;&emsp;对于Android平台上的线程优先级设置来说可以处理很多并发线程的阻塞问题，比如很多无关紧要的线程会占用大量的CPU时间，虽然通过了MultiThread来解决慢速I/O但是合理分配优先级对于并发编程来说十分重要。Android在线程方面主要使用的是Java本身的Thread类，我们可以在Thread或Runnable接口中的run方法首句加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //设置线程优先级为后台，这样当多个线程并发后很多无关紧要的线程分配的CPU时间将会减少，有利于主线程的处理</div></pre></td></tr></table></figure></p>
<p>现场优先级：</p>
<p>int THREAD_PRIORITY_AUDIO //标准音乐播放使用的线程优先级</p>
<p>int THREAD_PRIORITY_BACKGROUND //标准后台程序</p>
<p>int THREAD_PRIORITY_DEFAULT // 默认应用的优先级</p>
<p>int THREAD_PRIORITY_DISPLAY //标准显示系统优先级，主要是改善UI的刷新</p>
<p>int THREAD_PRIORITY_FOREGROUND //标准前台线程优先级</p>
<p>int THREAD_PRIORITY_LESS_FAVORABLE //低于favorable</p>
<p>int THREAD_PRIORITY_LOWEST //有效的线程最低的优先级</p>
<p>int THREAD_PRIORITY_MORE_FAVORABLE //高于favorable</p>
<p>int THREAD_PRIORITY_URGENT_AUDIO //标准较重要音频播放优先级</p>
<p>int THREAD_PRIORITY_URGENT_DISPLAY //标准较重要显示优先级，对于输入事件同样适用。</p>
<h4 id="一、工具：adb-或Python"><a href="#一、工具：adb-或Python" class="headerlink" title="一、工具：adb 或Python"></a>一、工具：adb 或Python</h4><p>adb计算app启动时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am start -w packagename/activity</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;三个返回结果ThisTime，TotalTime，WaitTime</p>
<p>&emsp;&emsp;WaitTime就是app启动时间：WaitTime=startTime-endTime</p>
<p>&emsp;&emsp;startTime：记录的刚准备调用startActivityAndWait()的时间点</p>
<p>&emsp;&emsp;endTime：记录的是startActivityAndWait()函数调用返回的时间点</p>
<p>&emsp;&emsp;ThisTime,TotalTime的计算在frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java文件的reportLaunchTimeLocked()函数中。</p>
<ul>
<li><p>curTime表示该函数调用的时间点.</p>
</li>
<li><p>displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点.</p>
</li>
<li><p>mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点.</p>
</li>
</ul>
<p>&emsp;&emsp;displayStartTime和mLaunchStartTime的区别：分两种情况:</p>
<p>&emsp;&emsp;正常情况下点击桌面图标只启动一个有界面的 Activity，此时 displayStartTime 与mLaunchStartTime 便指向同一时间点，此时 ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的 Activity 做逻辑处理(如占位界面)，接着又启动一个有界面的Activity，在这种启动一连串 Activity 的情况下（知乎的启动就是属于这种情况），displayStartTime 便指向最后一个 Activity 的开始启动时间点，mLaunchStartTime 指向第一个无界面Activity的开始启动时间点，此时 ThisTime！=TotalTime。这两种情况如下图：</p>
<p>&emsp;&emsp;如果只关心某个应用自身启动耗时，参考TotalTime；如果关心系统启动应用耗时，参考WaitTime；如果关心应用有界面Activity启动耗时，参考ThisTime。</p>
<h4 id="二、热启动"><a href="#二、热启动" class="headerlink" title="二、热启动"></a>二、热启动</h4><p>&emsp;&emsp;如果是你按Back键，并没有将应用进程杀掉的话，那么执行上述命令就会快一些，因为不用创建进程了，只需要启动一个Activity即可。这也就是我们说的应用热启动。</p>
<p>&emsp;&emsp;游戏启动的话，就不适用用命令行的方法来启动了，因为从用户点击桌面图标到登录界面，既有系统的部分也有游戏自己的部分。</p>
<p>&emsp;&emsp;系统部分：游戏也有一个 Activity，所以启动的时候还是会去启动这个 Activity，所以系统启动部分也就是用户点击桌面桌面响应到这个Activity启动。</p>
<p>&emsp;&emsp;游戏部分：一般游戏的主 Activity 启动后，还会做一些比较耗时的事情，这时候你看到的界面是不能操作的，比如：加载游戏数据、联网更新数据、读取和更新配置文件、游戏引擎初始化等操作。从游戏开发的角度来看，到了真正用户能操作的界面才算是一个游戏真正加载完成的时间。</p>
<p>&emsp;&emsp;那么这个时间，就得使用 Log 来记录了，因为加载游戏数据、联网更新数据、读取和更新配置文件、游戏引擎初始化这些操作，都是游戏自己的逻辑，与系统无关，所以得由游戏自己定义加载完成的点。</p>
<p>&emsp;&emsp;对于游戏的启动时间，我们更倾向于计算从点击桌面图标到用户可以与游戏进行交互这个时间段作为一个游戏的启动时间</p>
<h4 id="三、冷启动"><a href="#三、冷启动" class="headerlink" title="三、冷启动"></a>三、冷启动</h4><p>&emsp;&emsp;应用不在后台时第一次启动，系统和App本身都有更多的工作要从头开始！、</p>
<p>&emsp;&emsp;应用在冷启动之前，要执行三个任务：</p>
<ol>
<li><p>加载启动App；</p>
</li>
<li><p>App启动之后立即展示出一个空白的Window；</p>
</li>
<li><p>创建App的进程；</p>
</li>
</ol>
<p>&emsp;&emsp;而这三个任务执行完毕之后会马上执行以下任务：</p>
<ol>
<li>创建App对象；</li>
</ol>
<p>5.启动Main Thread；</p>
<p>6.创建启动的Activity对象；</p>
<ol>
<li><p>加载View；</p>
</li>
<li><p>布置屏幕；</p>
</li>
<li><p>进行第一次绘制；</p>
</li>
</ol>
<p>&emsp;&emsp;而一旦App进程完成了第一次绘制，系统进程就会用Main Activity替换已经展示的Background Window，此时用户就可以使用App了。</p>
<p>&emsp;&emsp;作为普通应用，App进程的创建等环节我们是无法主动控制的，可以优化的也就是Application、Activity创建以及回调等过程。</p>
<p>&emsp;&emsp;同样，Google也给出了启动加速的方向：</p>
<p>&emsp;&emsp;利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；</p>
<p>&emsp;&emsp;避免在启动时做密集沉重的初始化（Heavy app initialization）；</p>
<p>&emsp;&emsp;定位问题：避免I/O操作、反序列化、网络操作、布局嵌套等。</p>
<p>&emsp;&emsp;备注：方向1属于治标不治本，只是表面上快；方向2、3可以真实的加快启动速度。</p>
<h4 id="为什么会出现白屏"><a href="#为什么会出现白屏" class="headerlink" title="为什么会出现白屏"></a>为什么会出现白屏</h4><p>通过清单文件可以看见默认配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span>    </span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">".StartPageActivity"</span>    </div><div class="line">    <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span>&gt;    </div><div class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>        </div><div class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;启动界面在完全绘制完页面布局前默认会有白屏或黑屏现象，这是我们可以设置默认主题布局为透明<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppBlackTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="xml">    </span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>添加到activity标签中<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span>    </span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">".StartPageActivity"</span>    </div><div class="line">    <span class="attr">android:theme</span>=<span class="string">"@style/AppBlackTheme"</span></div><div class="line">    <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span>&gt;    </div><div class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>        </div><div class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>而官方给出的做法是采用Activity的windowBackground主题属性来为启动的Activity提供一个简单的drawable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 防止欢迎页白屏或者黑屏，设置图片 --&gt;</div><div class="line">    &lt;style name=&quot;SplashTheme&quot; parent=&quot;AppTheme&quot;&gt;</div><div class="line">        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/welcome1&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;</div><div class="line">        &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;</div><div class="line">        &lt;!--&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;false&lt;/item&gt;--&gt;</div><div class="line">        &lt;!--&lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;--&gt;</div><div class="line">    &lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>welcome.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;layer-list&gt; xmlns: android=&quot;&quot; android:opacity=&quot;opaque&quot;&gt;</div><div class="line">	&lt;item android:drawable=&quot;@android:color/white&quot;/&gt;</div><div class="line">	&lt;item&gt;</div><div class="line">		&lt;bitmap android:src=&quot;@drawable/spalash&quot; android:gravity=&quot;center&quot;/&gt;</div><div class="line">	&lt;/item&gt;</div><div class="line">	&lt;/layer-list&gt;</div></pre></td></tr></table></figure></p>
<p>当然welcome也可以是一张图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">            android:name=&quot;.activity.WelcomeActivity&quot;</div><div class="line">            android:theme=&quot;@style/SplashTheme&quot;</div><div class="line">            android:screenOrientation=&quot;portrait&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</div><div class="line"></div><div class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure></p>
<p>也可以在代码中修改，不用再清单文件中修改，只需在super.onCreate()方法前调用setThreme(R.style.SplashTheme)即可</p>
<ol>
<li><p>初始化时间过长<br>APP如果引入第三方服务过多，那么初始化第三方服务(初始化application)需要的时间也越长<br><img src="https://user-gold-cdn.xitu.io/2017/1/10/095de64d7062e30472d9b24273c8bbbc?_=6288399" alt="enter image description here"></p>
<p>Tinker以及MultiDex的初始化最先执行</p>
</li>
</ol>
<h4 id="如何缩短初始化时间"><a href="#如何缩短初始化时间" class="headerlink" title="如何缩短初始化时间"></a>如何缩短初始化时间</h4><p>方法一 ：IntentService</p>
<p>&emsp;&emsp;IntentService是继承于Service并处理异步请求的一个类，在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要我们去手动控制。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。而且，所有请求都在一个单线程中，不会阻塞应用程序的主线程（UI Thread），同一时间只处理一个请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class InitializeService extends IntentService &#123;    </div><div class="line">    private static final String ACTION_INIT_WHEN_APP_CREATE = &quot;com.example.appstart.service.action.INIT&quot;;    </div><div class="line">    public InitializeService() &#123;        </div><div class="line">        super(&quot;InitializeService&quot;);    </div><div class="line">    &#125;    </div><div class="line">    public static void start(Context context) &#123;        </div><div class="line">        Intent intent = new Intent(context, InitializeService.class);</div><div class="line">        intent.setAction(ACTION_INIT_WHEN_APP_CREATE);        </div><div class="line">        context.startService(intent);    </div><div class="line">    &#125;    </div><div class="line">    @Override    </div><div class="line">    protected void onHandleIntent(Intent intent) &#123;        </div><div class="line">        if (intent != null) &#123;            </div><div class="line">            final String action = intent.getAction();            </div><div class="line">            if (ACTION_INIT_WHEN_APP_CREATE.equals(action)) &#123;               </div><div class="line">                //初始化操作（耗时操作）</div></pre></td></tr></table></figure></p>
<pre><code>        }        
    }    
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&amp;emsp;&amp;emsp;在application的onCreate方法中执行就行了，但是如果进入到主界面执行第三方功能的时候还没有初始化完，就会出现第三方库异常</div><div class="line"></div><div class="line">方法二：使用EventBus</div><div class="line"></div><div class="line">&amp;emsp;&amp;emsp;考虑异步初始化，不阻塞现场，延迟部分第三方服务的初始化，Tinker和MultiDex还是在Application主线程初始化</div><div class="line">![enter image description here](http://upload-images.jianshu.io/upload_images/1316299-4e98e3db89f91fe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">项目修改：</div><div class="line">1. 将友盟、Bugly、听云、GrowingIO、BlockCanary等组件放在WorkThread中初始化；</div><div class="line">2. 延迟地图定位、ImageLoader、自有统计等组件的初始化：地图及自有统计(GrowingIO)延迟4秒，此时应用已经打开；而ImageLoader</div><div class="line">因为调用关系不能异步以及过久延迟，初始化从Application延迟到SplashActivity；而EventBus因为再Activity中使用所以必须在Application中初始化。</div><div class="line"> ![enter image description here](https://user-gold-cdn.xitu.io/2017/1/10/868beba5d61f7b4947caf1f0d1ba9f7f?_=6288399)</div><div class="line">&amp;emsp;&amp;emsp; 上面初始化即把初始化代码定义在application中，但是不立即调用，而使用eventbus发送消息再进行调用</div><div class="line">通过adb命令查看启动时间</div></pre></td></tr></table></figure></p>
<p>adb shell am start -W [packageName]/[packageName.MainActivity]<br>```<br>项目中除听云之外其余所有三方组件都抢占先机，在Application主线程初始化<br>卡顿主要发生在：</p>
<ul>
<li>部分数据库及IO的操作发生在首屏Activity主线程；</li>
<li>Application中创建了线程池，Thread、ThreadPoolExecutor、AsyncTask、HandlerThread、IntentService等都各有利弊；例如通常情况下ThreadPoolExecutor比Thread更加高效、优势明显，但是特定场景下单个时间点的表现Thread会比ThreadPoolExecutor好：同样的创建对象，ThreadPoolExecutor的开销明显比Thread大；</li>
<li>首屏Activity网络请求密集；</li>
<li>工作线程使用未设置优先级；</li>
<li>信息未缓存，重复获取同样信息；</li>
</ul>
<p>项目修改：</p>
<ol>
<li><p>数据库及IO操作都移到工作线程，并且设置线程优先级为THREAD_PRIORITY_BACKGROUND，这样工作线程最多能获取到10%的时间片，优先保证主线程执行。</p>
</li>
<li><p>流程梳理，延后执行；</p>
</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2017/1/10/032202be364c3f36a630017421b0db1a?_=6288399" alt="enter image description here"><br>&emsp;&emsp;通过以上三步及三方组件的优化：Application以及首屏Activity回调期间主线程就没有耗时、争抢资源等情况了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;并不是每一个组件的初始化以及操作都可以异步或延迟。是否可以取决组件的调用关系以及自己项目具体业务的需要。保证一个准则：<strong>可以异步的都异步，不可以异步的尽量延迟。让应用先启动，再操作。</strong></p>
<p>通用优化包含以下几点：</p>
<ul>
<li>利用主题快速显示界面；</li>
<li>异步初始化组件；</li>
<li>梳理业务逻辑，延迟初始化组件、操作；</li>
<li>正确使用线程；</li>
<li>去掉无用代码、重复逻辑等。</li>
</ul>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/06/07/App启动优化/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-05-21T15:49:00.000Z"><a href="/2016/05/21/Android缓存机制/">2016-05-21</a></time>
        
  
    <h1 class="title"><a href="/2016/05/21/Android缓存机制/">Android缓存机制</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现原理"><span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图片的缓存"><span class="toc-text">图片的缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存缓存"><span class="toc-text">内存缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘缓存"><span class="toc-text">磁盘缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设备配置参数改变时加载问题"><span class="toc-text">设备配置参数改变时加载问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用SQLite进行缓存"><span class="toc-text">使用SQLite进行缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件缓存"><span class="toc-text">文件缓存</span></a></li></ol>
    </div>

        <p>Android应用与网络打交道是常有的事情，如果网络数据没有变化而每次都重新请求网络，就会浪费流量，Android系统有自己的缓存机制避免频繁的请求网络。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>  把不需要实时更新的数据缓存下来，通过时间或者其他因素　来判别是读缓存还是网络请求，这样可以缓解服务器压力，一定程度上提高应用响应速度，并且支持离线阅读。<br>  访问网络的数据常见返回格式有图片，文件和数据库，因此从这几个方向考虑缓存的实现。</p>
<h4 id="图片的缓存"><a href="#图片的缓存" class="headerlink" title="图片的缓存"></a>图片的缓存</h4><p>  在许多的情况下(像 ListView, GridView 或 ViewPager 之类的组件 )我们需要一次性加载大量的图片，在屏幕上显示的图片和所有待显示的图片有可能需要马上就在屏幕上无限制的进行滚动、切换。<br>  常见的优化就是子项不可见时，所占用的内存会被回收以供正在前台显示子项使用。如果想让UI运行流畅的话，就不应该每次显示时都去重新加载图片。保持一些内存和文件缓存就变得很有必要了。</p>
<h4 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h4><p>  通过预先消耗应用的一点内存来存储数据，便可快速的为应用中的组件提供数据，是一种典型的以空间换时间的策略。<br>  LruCache 类（Android v4 Support Library 类库中开始提供）非常适合来做图片缓存任务 ，它可以使用一个LinkedHashMap 的强引用来保存最近使用的对象，并且当它保存的对象占用的内存总和超出了为它设计的最大内存时会把不经常使用的对象成员踢出以供垃圾回收器回收。<br>  给LruCache 设置一个合适的内存大小，需考虑如下因素：</p>
<ul>
<li>还剩余多少内存给你的activity或应用使用</li>
<li>屏幕上需要一次性显示多少张图片和多少图片在等待显示</li>
<li>手机的大小和密度是多少（密度越高的设备需要越大的 缓存）</li>
<li>图片的尺寸（决定了所占用的内存大小）</li>
<li>图片的访问频率（频率高的在内存中一直保存）</li>
<li>保存图片的质量（不同像素的在不同情况下显示）</li>
</ul>
<p>举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private LruCache&lt;String, Bitmap&gt; mMemoryCache;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    ...</div><div class="line">    // 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常</div><div class="line">    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line"></div><div class="line">    // 用１／８的内存大小作为内存缓存</div><div class="line">    final int cacheSize = maxMemory / 8;</div><div class="line"></div><div class="line">    mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">        @Override</div><div class="line">        protected int sizeOf(String key, Bitmap bitmap) &#123;</div><div class="line">            // 这里返回的不是item的个数，是cache的size（单位1024个字节）</div><div class="line">            return bitmap.getByteCount() / 1024;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void addBitmapToMemoryCache(String key, Bitmap bitmap) &#123;</div><div class="line">    if (getBitmapFromMemCache(key) == null) &#123;</div><div class="line">        mMemoryCache.put(key, bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Bitmap getBitmapFromMemCache(String key) &#123;</div><div class="line">    return mMemoryCache.get(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void loadBitmap(int resId, ImageView imageView) &#123;</div><div class="line">    final String imageKey = String.valueOf(resId);</div><div class="line"></div><div class="line">    // 查看下内存缓存中是否缓存了这张图片</div><div class="line">    final Bitmap bitmap = getBitmapFromMemCache(imageKey);</div><div class="line">    if (bitmap != null) &#123;</div><div class="line">        mImageView.setImageBitmap(bitmap);</div><div class="line">    &#125; else &#123;</div><div class="line">        mImageView.setImageResource(R.drawable.image_placeholder);</div><div class="line">BitmapWorkerTask task = new BitmapWorkerTask(mImageView);</div><div class="line">        task.execute(resId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在图片加载的Task中，需要把加载好的图片加入到内存缓存中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123;</div><div class="line">    ...</div><div class="line">    // 在后台完成</div><div class="line">    @Override</div><div class="line">    protected Bitmap doInBackground(Integer... params) &#123;</div><div class="line">        final Bitmap bitmap = decodeSampledBitmapFromResource(</div><div class="line">                getResources(), params[0], 100, 100));</div><div class="line">    addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h4><p>  内存缓存能够快速的获取到最近显示的图片，但不一定就能够获取到。当数据集过大时很容易把内存缓存填满（如GridView ）。你的应用也有可能被其它的任务（比如来电）中断进入到后台，后台应用有可能会被杀死，那么相应的内存缓存对象也会被销毁。 当你的应用重新回到前台显示时，你的应用又需要一张一张的去加载图片了。</p>
<p>  磁盘文件缓存能够用来处理这些情况，保存处理好的图片，当内存缓存不可用的时候，直接读取在硬盘中保存好的图片，这样可以有效的减少图片加载的次数。读取磁盘文件要比直接从内存缓存中读取要慢一些，而且需要在一个UI主线程外的线程中进行，因为磁盘的读取速度是不能够保证的，磁盘文件缓存显然也是一种以空间换时间的策略。</p>
<p>  如果图片使用非常频繁的话，一个 ContentProvider 可能更适合代替去存储缓存图片，比如图片gallery 应用。</p>
<p>  下面是一个DiskLruCache的部分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">private DiskLruCache mDiskLruCache;</div><div class="line">private final Object mDiskCacheLock = new Object();</div><div class="line">private boolean mDiskCacheStarting = true;</div><div class="line">private static final int DISK_CACHE_SIZE = 1024 * 1024 * 10; // 10MB</div><div class="line">private static final String DISK_CACHE_SUBDIR = &quot;thumbnails&quot;;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    ...</div><div class="line">    // 初始化内存缓存</div><div class="line">    ...</div><div class="line">    // 在后台线程中初始化磁盘缓存</div><div class="line">    File cacheDir = getDiskCacheDir(this, DISK_CACHE_SUBDIR);</div><div class="line">    new InitDiskCacheTask().execute(cacheDir);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">class InitDiskCacheTask extends AsyncTask&lt;File, Void, Void&gt; &#123;</div><div class="line">    @Override</div><div class="line">    protected Void doInBackground(File... params) &#123;</div><div class="line">        synchronized (mDiskCacheLock) &#123;</div><div class="line">            File cacheDir = params[0];</div><div class="line">  mDiskLruCache = DiskLruCache.open(cacheDir, DISK_CACHE_SIZE);</div><div class="line">　 mDiskCacheStarting = false; // 结束初始化</div><div class="line">　 mDiskCacheLock.notifyAll(); // 唤醒等待线程</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123;</div><div class="line">    ...</div><div class="line">    // 在后台解析图片</div><div class="line">    @Override</div><div class="line">    protected Bitmap doInBackground(Integer... params) &#123;</div><div class="line">        final String imageKey = String.valueOf(params[0]);</div><div class="line"></div><div class="line">        // 在后台线程中检测磁盘缓存</div><div class="line">        Bitmap bitmap = getBitmapFromDiskCache(imageKey);</div><div class="line"></div><div class="line">        if (bitmap == null) &#123; // 没有在磁盘缓存中找到图片</div><div class="line"> final Bitmap bitmap = decodeSampledBitmapFromResource(</div><div class="line">                    getResources(), params[0], 100, 100));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 把这个final类型的bitmap加到缓存中</div><div class="line">        addBitmapToCache(imageKey, bitmap);</div><div class="line"></div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void addBitmapToCache(String key, Bitmap bitmap) &#123;</div><div class="line">    // 先加到内存缓存</div><div class="line">    if (getBitmapFromMemCache(key) == null) &#123;</div><div class="line">        mMemoryCache.put(key, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //再加到磁盘缓存</div><div class="line">    synchronized (mDiskCacheLock) &#123;</div><div class="line">        if (mDiskLruCache != null &amp;&amp; mDiskLruCache.get(key) == null) &#123;</div><div class="line">            mDiskLruCache.put(key, bitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Bitmap getBitmapFromDiskCache(String key) &#123;</div><div class="line">    synchronized (mDiskCacheLock) &#123;</div><div class="line">        // 等待磁盘缓存从后台线程打开</div><div class="line">        //磁盘缓存没有初始化完成之前不能够对磁盘缓存进行访问</div><div class="line">        while (mDiskCacheStarting) &#123;</div><div class="line">            try &#123;</div><div class="line">                mDiskCacheLock.wait();</div><div class="line">            &#125; catch (InterruptedException e) &#123;&#125;</div><div class="line">        &#125;</div><div class="line">        if (mDiskLruCache != null) &#123;</div><div class="line">            return mDiskLruCache.get(key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static File getDiskCacheDir(Context context, String uniqueName) &#123;</div><div class="line">    // 优先使用外缓存路径，如果没有挂载外存储，就使用内缓存路径</div><div class="line">final String cachePath =</div><div class="line">            Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||</div><div class="line">!isExternalStorageRemovable() ?getExternalCacheDir(context).getPath():context.getCacheDir().getPath();</div><div class="line"></div><div class="line">    return new File(cachePath + File.separator + uniqueName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不能在UI主线程中进行这项操作，因为初始化磁盘缓存也需要对磁盘进行操作。上面的程序片段中，一个锁对象确保了磁盘缓存没有初始化完成之前不能够对磁盘缓存进行访问。</p>
<p>  内存缓存在UI线程中进行检测，磁盘缓存在UI主线程外的线程中进行检测，当图片处理完成之后，分别存储到内存缓存和磁盘缓存中。</p>
<h4 id="设备配置参数改变时加载问题"><a href="#设备配置参数改变时加载问题" class="headerlink" title="设备配置参数改变时加载问题"></a>设备配置参数改变时加载问题</h4><p>  由于应用在运行的时候设备配置参数可能会发生改变，比如设备朝向改变，会导致Android销毁你的Activity然后按照新的配置重启，这种情况下，我们要避免重新去加载处理所有的图片，让用户能有一个流畅的体验。</p>
<p>  使用Fragment 能够把内存缓存对象传递到新的activity实例中，调用setRetainInstance(true)) 方法来保留Fragment实例。当activity重新创建好后， 被保留的Fragment依附于activity而存在，通过Fragment就可以获取到已经存在的内存缓存对象了，这样就可以快速的获取到图片，并设置到ImageView上，给用户一个流畅的体验。</p>
<p>下面是一个示例程序片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private LruCache&lt;String, Bitmap&gt; mMemoryCache;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    ...</div><div class="line">RetainFragment mRetainFragment =            RetainFragment.findOrCreateRetainFragment(getFragmentManager());</div><div class="line">    mMemoryCache = RetainFragment.mRetainedCache;</div><div class="line">    if (mMemoryCache == null) &#123;</div><div class="line">        mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">            ... //像上面例子中那样初始化缓存</div><div class="line">        &#125;</div><div class="line">        mRetainFragment.mRetainedCache = mMemoryCache;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">class RetainFragment extends Fragment &#123;</div><div class="line">    private static final String TAG = &quot;RetainFragment&quot;;</div><div class="line">    public LruCache&lt;String, Bitmap&gt; mRetainedCache;</div><div class="line"></div><div class="line">    public RetainFragment() &#123;&#125;</div><div class="line"></div><div class="line">    public static RetainFragment findOrCreateRetainFragment(FragmentManager fm) &#123;</div><div class="line">        RetainFragment fragment = (RetainFragment) fm.findFragmentByTag(TAG);</div><div class="line">        if (fragment == null) &#123;</div><div class="line">            fragment = new RetainFragment();</div><div class="line">            FragmentTransaction fragmentTransaction = fragmentManager  </div><div class="line">                .beginTransaction(); </div><div class="line">            fragmentTransaction.add(fragment, TAG).commit(); </div><div class="line">        &#125;</div><div class="line">        return fragment;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        // 使得Fragment在Activity销毁后还能够保留下来</div><div class="line">        setRetainInstance(true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="使用SQLite进行缓存"><a href="#使用SQLite进行缓存" class="headerlink" title="使用SQLite进行缓存"></a>使用SQLite进行缓存</h4><p>  网络请求数据完成后，把文件的相关信息（如url（一般作为唯一标示），下载时间，过期时间）等存放到数据库。下次加载的时候根据url先从数据库中查询，如果查询到并且时间未过期，就根据路径读取本地文件，从而实现缓存的效果。</p>
<p>  注意：缓存的数据库是存放在/data/data//databases/目录下，是占用内存空间的，如果缓存累计，容易浪费内存，需要及时清理缓存。</p>
<h4 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h4><p>  思路和一般缓存一样，把需要的数据存储在文件中，下次加载时判断文件是否存在和过期（使用File.lastModified()方法得到文件的最后修改时间，与当前时间判断），存在并未过期就加载文件中的数据，否则请求服务器重新下载。<br>  注意，无网络环境下就默认读取文件缓存中的。</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/05/21/Android缓存机制/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-05-21T10:43:00.000Z"><a href="/2016/05/21/通过ViewTreeObserver测量View的高度/">2016-05-21</a></time>
        
  
    <h1 class="title"><a href="/2016/05/21/通过ViewTreeObserver测量View的高度/">通过ViewTreeObserver测量View的高度</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>&emsp;&emsp;ViewTreeObserver用于注册可以通知视图树中的全局变化的监听器。这样的全局事件包括但不限于整个树的布局，绘制路径的开始，触摸模式改变等。ViewTreeObserver不应该由应用程序实例化，因为它是由视图层次结构提供的。</p>
<p>&emsp;&emsp;在oncreate中View.getWidth和View.getHeight无法获得一个view的高度和宽度，这是因为View组件布局要在onResume回调后完成，只会得到0。所以现在需要使用getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度。这是获得一个view的宽度和高度的方法之一。</p>
<p>&emsp;&emsp;ViewTreeObserver有很多内部类，每个触发条件都不同<br>&emsp;&emsp;interface ViewTreeObserver.OnGlobalLayoutListener：当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类</p>
<p>&emsp;&emsp;interface ViewTreeObserver.OnPreDrawListener：当一个视图树将要绘制时，所要调用的回调函数的接口类</p>
<p>&emsp;&emsp;interface ViewTreeObserver.OnScrollChangedListener：当一个视图树中的一些组件发生滚动时，所要调用的回调函数的接口类</p>
<p>&emsp;&emsp;interface ViewTreeObserver.OnTouchModeChangeListener：当一个视图树的触摸模式发生改变时，所要调用的回调函数的接口类</p>
<p>我们利用OnGlobalLayoutListener可以获取View的高度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Java代码  final LinearLayout imageViewContainer = (LinearLayout)findViewById(R.id.crop_photo_image_view_container);  </div><div class="line">        imageViewContainer.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() &#123;  </div><div class="line">            boolean isFirst = true;//默认调用两次，这里只让它执行一次回调  </div><div class="line">            @Override  </div><div class="line">            public void onGlobalLayout() &#123;  </div><div class="line">                if (isFirst) &#123;  </div><div class="line">                    isFirst = false;  </div><div class="line">                    //现在布局全部完成，可以获取到任何View组件的宽度、高度、左边、右边等信息  </div><div class="line">                    Log.i(&quot;CDH&quot;, &quot;Global W:&quot;+imageViewContainer.getMeasuredWidth()+&quot;  H:&quot;+imageViewContainer.getMeasuredHeight());  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>OnGlobalLayoutListener可能会被多次触发，因此在得到了高度之后，要将OnGlobalLayoutListener注销掉<br>因此代码改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">final LinearLayout imageViewContainer = (LinearLayout)findViewById(R.id.crop_photo_image_view_container);  </div><div class="line">        imageViewContainer.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() &#123;    </div><div class="line">            @Override  </div><div class="line">            public void onGlobalLayout() &#123;</div><div class="line">                   //直接移除</div><div class="line">                    imageViewContainer.getViewTreeObserver().removeGlobalOnLayoutListener(this);</div><div class="line">                    //现在布局全部完成，可以获取到任何View组件的宽度、高度、左边、右边等信息  </div><div class="line">                    Log.i(&quot;CDH&quot;, &quot;Global W:&quot;+imageViewContainer.getMeasuredWidth()+&quot;  H:&quot;+imageViewContainer.getMeasuredHeight());</div><div class="line">            &#125;  </div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>类似的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mGridView.getViewTreeObserver().addOnGlobalLayoutListener( </div><div class="line">         //view 布局完成时调用，每次view改变时都会调用  </div><div class="line">        new ViewTreeObserver.OnGlobalLayoutListener() &#123;  </div><div class="line">            @Override  </div><div class="line">            public void onGlobalLayout() &#123;  </div><div class="line">                if (mAdapter.getNumColumns() == 0) &#123;  </div><div class="line">                        final int numColumns = (int) Math.floor(  </div><div class="line">                                 mGridView.getWidth() / (mImageThumbSize + mImageThumbSpacing));  </div><div class="line">                    if (numColumns &gt; 0) &#123;  </div><div class="line">                        final int columnWidth =  </div><div class="line">                            (mGridView.getWidth() / numColumns) - mImageThumbSpacing;  </div><div class="line">                        mAdapter.setNumColumns(numColumns);   //设置 列数  </div><div class="line">                            mAdapter.setItemHeight(columnWidth);  //设置 高度  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>在gridview布局完成后，根据girdview的宽和高设置adapter列数和每个item高度</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/05/21/通过ViewTreeObserver测量View的高度/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-05-12T06:08:57.000Z"><a href="/2016/05/12/一个可以进页面自动显示刷新效果的SwipeRefreshLayout/">2016-05-12</a></time>
        
  
    <h1 class="title"><a href="/2016/05/12/一个可以进页面自动显示刷新效果的SwipeRefreshLayout/">一个可以进页面自动显示刷新效果的SwipeRefreshLayout</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>SwipeRefreshLayout出来已经有一段时间了，先后换过两种刷新效果，都在V4包下面，新的刷新效果还是很赞的，很多app都采用了这种刷新效果，我最近也在往这边靠，在研究的时候发现，原始的SwipeRefreshLayout只支持手势下拉才能出现刷新效果，看到《简书》安卓客户端每次都有那种切换页面就自动出来刷新效果，自己也试了下，直接设置setRefreshing(true)这个方法是不能看到效果的，于是对<a href="http://www.2cto.com/ym" target="_blank" rel="external">源码</a>进行了改造，不说多了，直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class AutoSwipeRefreshLayout extends SwipeRefreshLayout &#123;</div><div class="line"> </div><div class="line">    public AutoSwipeRefreshLayout(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public AutoSwipeRefreshLayout(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 自动刷新</div><div class="line">     */</div><div class="line">    public void autoRefresh() &#123;</div><div class="line">        try &#123;</div><div class="line">            Field mCircleView = SwipeRefreshLayout.class.getDeclaredField(mCircleView);</div><div class="line">            mCircleView.setAccessible(true);</div><div class="line">            View progress = (View) mCircleView.get(this);</div><div class="line">            progress.setVisibility(VISIBLE);</div><div class="line"> </div><div class="line">            Method setRefreshing = SwipeRefreshLayout.class.getDeclaredMethod(setRefreshing, boolean.class, boolean.class);</div><div class="line">            setRefreshing.setAccessible(true);</div><div class="line">            setRefreshing.invoke(this, true, true);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码看起来比较简单，确实花了不少功夫去<a href="http://book.2cto.com/" target="_blank" rel="external">阅读</a>源码，除了添加了一个可以自动刷新的方法，没有修改其他的，用法也是和普通SwipeRefreshLayout一样，只不过可以在第一次加载数据的时候调用autoRefresh（）就可以看到刷新效果了，看效果图：<img src="http://upload-images.jianshu.io/upload_images/4398977-2e0a409c5f5f970d.gif?imageMogr2/auto-orient/strip" alt="alt=这里写图片描述"></p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/05/12/一个可以进页面自动显示刷新效果的SwipeRefreshLayout/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-05-11T06:06:15.000Z"><a href="/2016/05/11/android之View坐标系（view获取自身坐标的方法和点击事件中坐标的获取）/">2016-05-11</a></time>
        
  
    <h1 class="title"><a href="/2016/05/11/android之View坐标系（view获取自身坐标的方法和点击事件中坐标的获取）/">android之View坐标系（view获取自身坐标的方法和点击事件中坐标的获取）</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>在做一个view背景特效的时候被坐标的各个获取方法搞晕了，几篇抄来抄去的博客也没弄很清楚。</p>
<p>现在把整个总结一下。</p>
<p>其实只要把下面这张图看明白就没问题了。<br><img src="http://upload-images.jianshu.io/upload_images/4398977-3251e6068bb1e1f5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>涉及到的方法一共有下面几个：<br>view获取自身坐标：getLeft(),getTop(),getRight(),getBottom()<br>view获取自身宽高：getHeight(),getWidth()<br>motionEvent获取坐标：getX(),getY(),getRawX(),getRawY()<br>首先是view的几个方法，<br>获取自身的宽高的这两个方法很清楚，不用多说，获取坐标的这几个就有点混乱了。<br>根据上面的图应该会比较容易明白，图中屏幕上放了一个ViewGroup布局，里面有个View控件<br>getTop：获取到的，是view自身的顶边到其父布局顶边的距离<br>getLeft：获取到的，是view自身的左边到其父布局左边的距离<br>getRight：获取到的，是view自身的右边到其父布局左边的距离<br>getBottom：获取到的，是view自身的底边到其父布局顶边的距离</p>
<p>这些方法获取到的数据可以用在什么地方呢？比如要实现一个自定义的特殊布局，像<a href="http://blog.csdn.net/singwhatiwanna/article/details/42614953这里要实现的是一个水波纹特效布局，该布局内的任何控件点击后都会出现波纹效果" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/42614953这里要实现的是一个水波纹特效布局，该布局内的任何控件点击后都会出现波纹效果</a><br>那么在点击了布局内的一个控件之后，就要通过不断刷新布局，去更新这个控件上面的波纹半径，为了节省资源，每次刷新布局都时候不会整个布局都刷新，而只是通过<br><code>postInvalidateDelayed(INVALIDATE_DURATION, left, top, right, bottom);</code></p>
<p>在布局的画布上每次只去更新点击事件所点击的对应的控件的位置，那么这里就可以用view的那四个方法，分别获取自身的四条边对应的坐标<br>从而让布局去刷新重绘。</p>
<p>当然博客中是使用绝对坐标去计算的，因为这里实现的是一个布局，可能里面还会嵌套另外的布局，经过多次嵌套之后所获取到的值，是相对于控件直接对应的父布局（这个布局有可能已经是我们重写的布局的子布局了）的距离，这样去刷新的区域肯定是不准确的，所以博客里面使用相对屏幕的绝对坐标计算需要刷新的控件区域。</p>
<p>如果这里自定义的不是布局，而只是一个控件的话，就可以通过以上方法获取到坐标，然后要求自己所在的布局去重绘这一区域就可以了。当然这只是一种思路，其实没必要去要求布局重绘，完全可以直接view自身重绘就可以了。</p>
<p>然后是motionEvent的方法：</p>
<p>getX()：获取点击事件相对控件左边的x轴坐标，即点击事件距离控件左边的距离</p>
<p>getY()：获取点击事件相对控件顶边的y轴坐标，即点击事件距离控件顶边的距离</p>
<p>getRawX()：获取点击事件相对整个屏幕左边的x轴坐标，即点击事件距离整个屏幕左边的距离</p>
<p>getRawY()：获取点击事件相对整个屏幕顶边的y轴坐标，即点击事件距离整个屏幕顶边的距离</p>
<p>这些方法可以用在什么地方呢？</p>
<p>getRawX和getRawY在之前那篇博客里广泛使用了，可以去那里看用法，getX()和getY()这两个方法在对view进行自定义的时候可能用的会比较多。</p>
<p>###<a href="http://www.cnblogs.com/virtual-young/p/4578424.html" target="_blank" rel="external">MotionEvent中getRawX、getRawY与getX、getY以及View中的getScrollX、getScrollY</a></p>
<p>1.getRawX、getRawY与getX、getY的区别<br>在编写android的自定义控件，或者判断用户手势操作时，往往需要使用MotionEvent中的getRawX()、getRawY()与getX()、getY()取得触摸点在X轴与Y轴上的距离，这四个方法都返回一个float类型的参数，单位为像素（Pixel）。getRawX()、getRawY()返回的是触摸点相对于屏幕的位置，而getX()、getY()返回的则是触摸点相对于View的位置。<br>以下两张图直观的表现了这几个方法的区别，在屏幕中央放置了一个Button，并为它注册了OnTouchListener，图中绿圆点为触摸点位置。<br><img src="http://upload-images.jianshu.io/upload_images/4398977-436d27429779abc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">    <img src="http://upload-images.jianshu.io/upload_images/4398977-ea980ca264ad742c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>2.View中的getScrollX、getScrollY<br>getScrollX()与getScrollY()的值由调用View的scrollTo(int x, int y)或者scrollBy(int x, int y)产生，其中scrollTo是将View中的内容移动到指定的坐标x、y处，此x、y是相对于<br>View的左上角，而不是屏幕的左上角。scrollBy(int x, int y)则是改变View中的相对位置，参数x、y为距离上一次的相对位置。<br>文字解释总是不好理解的，那么我们就直接上图吧，直观一些。<br><img src="http://upload-images.jianshu.io/upload_images/4398977-66127203a89fb7c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="http://upload-images.jianshu.io/upload_images/4398977-205675aec563fdea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="http://upload-images.jianshu.io/upload_images/4398977-d6333d61fc2421dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>               （图1）                                                         （图2）                                                                （图3）<br>1.图1中，屏幕中心放置了一个button，而button的内容被放置在了它的左上角。<br>2.调用button的scrollTo(-100, -100)方法，结果如图2所示，button内的内容被移至相对button左上角(-100，-100)的位置<br>3.对图2的button调用scrollBy(-100,-100)方法，结果如图3所示，button内的内容被移至相对于图2的(-100,-100)位置<br>这时的getScrollX()与getScrollY()的值为：</p>
<p>06-15 15:44:56.072 20471-20471/com.test.yangy.studiotest V/ScrollActivity﹕ btn scroll X=-20006-15 15:44:56.072 20471-20471/com.test.yangy.studiotest V/ScrollActivity﹕ btn scroll Y=-200</p>
<p>值得注意的是，当View中的内容向右移动时，getScrollX()的值为负数，同理，向scrollTo与scrollBy的x中传入负数，view中的内容向右移动，反之向左。<br>当View中的内容向下移动时，getScrollY()的值为负数，同理，向scrollTo与scrollBy的y中传入负数，view中的内容向下移动，反之向上。</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/05/11/android之View坐标系（view获取自身坐标的方法和点击事件中坐标的获取）/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-05-02T05:41:42.000Z"><a href="/2016/05/02/Java8新特性之lambda表达式入门/">2016-05-02</a></time>
        
  
    <h1 class="title"><a href="/2016/05/02/Java8新特性之lambda表达式入门/">Java8新特性之lambda表达式入门</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>功能接口</p>
<p>只包含一个方法的接口被称为功能接口，Lambda 表达式用用于任何功能接口适用的地方，java.awt.event.ActionListener 就是一个功能接口，因为它只有一个方法：</p>
<p>void actionPerformed(ActionEvent)</p>
<p>一、lambda引入原因</p>
<p>1、更加紧凑的代码</p>
<p>比如Java中现有的匿名内部类以及监听器(listeners)和事件处理器(handlers）都显得很冗长</p>
<p>2、修改方法的能力</p>
<p>比如Collection接口的contains方法，当且仅当传入的元素真正包含在集合中，才返回true。而假如我们想对一个字符串集合，传入一个字符串，只要这个字符串出现在集合中（忽略大小写）就返回true。</p>
<p>简单地说，我们想要的是传入“一些我们自己的代码”到已有的方法中，已有的方法将会执行我们传入的代码。Lambda表达式能很好地支持这点</p>
<p>3、更好地支持多核处理</p>
<p>例如，通过Java 8新增的Lambda表达式，我们可以很方便地并行操作大集合，充分发挥多核CPU的潜能。</p>
<p>并行处理函数如filter、map和reduce。</p>
<p>实例1 FileFilter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">File dir =newFile(&quot;/an/dir/&quot;);</div><div class="line"></div><div class="line">FileFilter directoryFilter=newFileFilter() &#123;public boolean accept(File file) &#123;</div><div class="line"></div><div class="line">returnfile.isDirectory();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过Lambda表达式这段代码可以简化为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">File dir =newFile(&quot;/an/dir/&quot;);</div><div class="line"></div><div class="line">FileFilter directoryFilter= (File f) -&gt;f.isDirectory();</div><div class="line"></div><div class="line">File[] dirs= dir.listFiles(directoryFilter);</div></pre></td></tr></table></figure></p>
<p>进一步简化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">File dir =newFile(&quot;/an/dir/&quot;)；</div><div class="line"></div><div class="line">File[] dirs= dir.listFiles((File f) -&gt; f.isDirectory());</div></pre></td></tr></table></figure></p>
<p>Lambda表达式利用了类型推断（type inference）技术：</p>
<p>编译器知道FileFilter只有一个方法accept()，所以accept()方法肯定对应(File f) -&gt; f.isDirectory()，就是利用了类型推断，而且accept()方法只有一个File类型的参数，所以(File f) -&gt;f.isDirectory()中的File f就是这个参数了，.NET把类型推断做得更绝，如果上面用.NET Lambda表达式写法的话是这样的：File[] dirs= dir.ListFiles(f =&gt;f.isDirectory());即压根就不需要出现File类型指示。</p>
<p>实例2 Event Handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Button bt =newButton();</div><div class="line"></div><div class="line">bt.addActionListener(newActionListener() &#123;public void actionPerformed(ActionEvent e) &#123;</div><div class="line"></div><div class="line">ui.showSomething();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>使用Lambda表达式后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Button bt =newButton();</div><div class="line"></div><div class="line">ActionListener listener= event -&gt;&#123; ui.showSomething(); &#125;;</div><div class="line"></div><div class="line">bt.addActionListener(listener);</div></pre></td></tr></table></figure></p>
<p>进一步简化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Button bt =newButton();</div><div class="line"></div><div class="line">bt.addActionListener(event-&gt; &#123; ui.showSomething(); &#125;);</div></pre></td></tr></table></figure></p>
<p>newActionListener的内部类只有actionPerformed方法，event就是参数</p>
<p>actionPerformed()方法的返回类型是void，所以需要特殊处理，即在ui.showSomething();左右加上花括号。（想象下不加会怎么样？如果不加的话，若showSomething()方法返回值是整数类型，那么就意味着actionPerformed()返回整数类型，显然不是，所以必须加花括号用来标记）。</p>
<p>如果Lambda表达式主体部分包含多条语句，也必须用花括号，并且return语句不能省。</p>
<p>比如下面这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">File dir =newFile(&quot;/an/dir/&quot;);</div><div class="line"></div><div class="line">File[] dirs= dir.listFiles((File f) -&gt;&#123;</div><div class="line"></div><div class="line">System.out.println(&quot;Log:...&quot;);</div><div class="line"></div><div class="line">return f.isDirectory();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>函数集合</p>
<p>Java 8 的类库包含一个新的包 java.util.functions ，这个包中有很多新的功能接口，这些接口可与集合 API 一起使用。</p>
<p>外循环、内循环和Map、Reduce、Filter</p>
<p>一直到现在，处理Java集合的标准做法是采用外循环。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">List list =newArrayList();</div><div class="line"></div><div class="line">list.add(&quot;hello&quot;);</div><div class="line"></div><div class="line">list.add(&quot;world&quot;);for(intitem: list) &#123;//处理item&#125;</div></pre></td></tr></table></figure></p>
<p>还有迭代器循环，它们都是外循环，并且都是顺序处理（sequential handling）。顺序特性也常常引发ConcurrentModificationException，只要我们尝试着并发修改集合。</p>
<p>Lambda表达式提供了内循环机制。</p>
<p>我们工作中可能经常面临下面的需求：</p>
<blockquote>
<p>过滤掉一个集合中不符合条件的元素得到一个新集合</p>
<p>对集合中的每个元素进行某种转换，并且对转换后的集合进行处理</p>
<p>统计整个集合的某个属性，比如统计集合元素值的总和或平均值</p>
</blockquote>
<p>这些任务即filter、map和reduce，他们的共同特点是：</p>
<p>需要对集合中的每个元素运行一小段相同的代码。</p>
<p>传统的实现这些任务的代码让人感到很乏味，幸运的是Java 8提供了完成这些任务的更简洁的方案，当然还是利用Lambda表达式，但也引入了一个新的类库java.util.functions，包含Predicate、Mapper和Block。</p>
<p>Java 8中，一个Predicate（谓词）是这样一个方法：它根据变量的值进行评估(evaluate），返回true或false。java.util.functions.Predicate</p>
<p>比如下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">List list =getMyStrings();</div><div class="line"></div><div class="line">for(String myString: list) &#123;if(myString.contains(possible)) &#123;</div><div class="line"></div><div class="line">System.out.println(myString+ &quot; contains &quot; +possible);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用Predicate和Filter后得到下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">List list =getMyStrings();</div><div class="line"></div><div class="line">Predicate matched = s -&gt;s.equalsIgnoreCase(possible);</div><div class="line"></div><div class="line">list.filter(matched);</div></pre></td></tr></table></figure></p>
<p>进一步简化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">List list =getMyStrings();</div><div class="line"></div><div class="line">list.filter(s-&gt; s.equalsIgnoreCase(possible));</div></pre></td></tr></table></figure></p>
<p>使用谓词 (Predicate) 来筛选集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">List names = Arrays.asList(&quot;Alice&quot;,&quot;Bob&quot;,&quot;Charlie&quot;,&quot;Dave&quot;);</div><div class="line"></div><div class="line">List filteredNames = names.filter(e -&gt; e.length() &gt;=4).into(new ArrayList());</div><div class="line"></div><div class="line">for(String name : filteredNames) &#123;</div><div class="line"></div><div class="line">System.out.println(name);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们有两个新方法：</p>
<p>Iterable filter(Predicate) 用于获取元素满足某个谓词返回 true 的结果</p>
<p><a extends="" fillableinto<?="" super="" t="">&gt;A into(A) 将用返回的结果填充 ArrayList </a></p>
<p>java.util.functions.Block</p>
<p>我们可使用一个新的迭代器方法来替换 for 循环 void forEach(Block&lt;? super T&gt;):</p>
<p>List names = Arrays.asList(“Alice”,”Bob”,”Charlie”,”Dave”);</p>
<p>names.filter(e -&gt; e.length() &gt;=4).forEach(e -&gt; { System.out.println(e); });<br>forEach() 方法是 internal iteration 的一个实例：迭代过程在 Iterable 和 Block 内部进行，每次可访问一个元素。</p>
<p>最后的结果就是用更少的代码来处理集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">List names = Arrays.asList(&quot;Alice&quot;,&quot;Bob&quot;,&quot;Charlie&quot;,&quot;Dave&quot;);</div><div class="line"></div><div class="line">names</div><div class="line"></div><div class="line">.mapped(e -&gt; &#123;return e.length(); &#125;)</div><div class="line"></div><div class="line">.asIterable()// returns an Iterable of BiValue elements</div><div class="line"></div><div class="line">// an element&apos;s key is the person&apos;s name, its value is the string length</div><div class="line"></div><div class="line">.filter(e -&gt; e.getValue() &gt;=4)</div><div class="line"></div><div class="line">.sorted((a, b) -&gt; a.getValue() - b.getValue())</div><div class="line"></div><div class="line">.forEach(e -&gt; &#123; System.out.println(e.getKey() +&apos;\t&apos;+ e.getValue()); &#125;);</div></pre></td></tr></table></figure></p>
<p>方法引用</p>
<p>我们可通过 :: 语法来引用某个方法。方法引用被认为是跟 Lambda 表达式一样的，可用于功能接口所适用的地方。</p>
<p>我们可以引用一个静态方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">executorService.submit(MethodReference::sayHello);</div><div class="line"></div><div class="line">privatestaticvoidsayHello() &#123;</div><div class="line"></div><div class="line">System.out.println(&quot;hello&quot;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者是一个实例的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.asList(&quot;Alice&quot;,&quot;Bob&quot;,&quot;Charlie&quot;,&quot;Dave&quot;).forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>我们也可以创建工程方法并将构造器引用赋值给 java.util.functions.Factory:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Factory biscuitFactory = Biscuit::new;</div><div class="line"></div><div class="line">Biscuit biscuit = biscuitFactory.make();</div></pre></td></tr></table></figure></p>
<p>最后，我们创建一个引用到随意实例的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface Accessor&lt;BEAN, PROPERTY&gt; &#123;</div><div class="line"></div><div class="line">PROPERTY access(BEAN bean);</div><div class="line"></div><div class="line">&#125;</div><div class="line">publicstaticvoidmain(String[] args) &#123;</div><div class="line"></div><div class="line">Address address =newAddress(&quot;29 Acacia Road&quot;,&quot;Tunbridge Wells&quot;);</div><div class="line"></div><div class="line">Accessor accessor = Address::getCity;</div><div class="line"></div><div class="line">System.out.println(accessor.access(address));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们无需绑定方法引用到某个实例，我们直接将实例做为功能接口的参数进行传递。</p>
<p>默认方法</p>
<p>直到今天的 Java ，都不可能为一个接口添加方法而不会影响到已有的实现类。而 Java 8 允许你为接口自身指定一个默认的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface Queue &#123;</div><div class="line"></div><div class="line">Message read();</div><div class="line"></div><div class="line">void delete(Message message);</div><div class="line"></div><div class="line">void deleteAll()  default&#123;</div><div class="line"></div><div class="line">Message message;</div><div class="line"></div><div class="line">while((message = read()) !=null) &#123;</div><div class="line"></div><div class="line">delete(message);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子接口可以覆盖默认的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface BatchQueue extends Queue &#123;</div><div class="line"></div><div class="line">void setBatchSize(int batchSize);</div><div class="line"></div><div class="line">void deleteAll()  default&#123;</div><div class="line"></div><div class="line">setBatchSize(100);</div><div class="line"></div><div class="line">Queue.super.deleteAll();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者子接口也可以通过重新声明一个没有方法体的方法来删除默认的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface FastQueue extends Queue &#123;</div><div class="line"></div><div class="line">void deleteAll();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/05/02/Java8新特性之lambda表达式入门/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-04-23T12:48:41.000Z"><a href="/2016/04/23/RXAndroid/">2016-04-23</a></time>
        
  
    <h1 class="title"><a href="/2016/04/23/RXAndroid/">RXAndroid</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#常见API"><span class="toc-text">常见API</span></a></li></ol>
    </div>

        <p>&emsp;&emsp;RxJava是一个基于可观测序列组成的异步的、基于事件的库。通俗一点说就是RxJava它是一个异步库，这个异步库可以让我们用非常简洁的代码来处理复杂数据流或者事件。</p>
<p>&emsp;&emsp;RxJava中两个最最基础的概念，一个是Observable，还有一个是Observer，其中Observable我们称之为被观察者，Observer称之为观察者，Observable用户发送消息，而Observer用于消费消息，在实际开发中，我们更多的是选择Observer的一个子类Subscriber来消费消息。在消息发送的过程中，Observable可以发送任意数量任意类型的消息（甚至一个将一个触摸事件当作一个消息发出），当Observable所发送的消息被成功处理或者消息出错时，一个流程结束。Observable会用它的每一个Subscriber（观察者）的onNext方法进行消息处理，在消息成功处理后以onComplete()方法结束流程，如果消息在处理的过程中出现了任何异常，则以onError()方法结束流程。比如下面几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Observable.OnSubscribe&lt;String&gt;() &#123;  </div><div class="line">            @Override  </div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;  </div><div class="line">                subscriber.onNext(&quot;哈哈哈哈&quot;);  </div><div class="line">                subscriber.onNext(&quot;lalalala&quot;);  </div><div class="line">                subscriber.onCompleted();  </div><div class="line">            &#125;  </div><div class="line">        &#125;)  </div><div class="line">                .subscribe(new Observer&lt;String&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public void onCompleted() &#123;  </div><div class="line">                        Log.d(&quot;google_lenve_fb&quot;, &quot;onCompleted: onCompleted()&quot;);  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onError(Throwable e) &#123;  </div><div class="line">                        Log.d(&quot;google_lenve_fb&quot;, &quot;onError:onError() &quot;);  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onNext(String s) &#123;  </div><div class="line">                        Log.d(&quot;google_lenve_fb&quot;, &quot;onNext: &quot; + s);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通过调用Observable的create方法来创建一个消息源，在它的onCall方法调用next方法来发送两条消息，当两条消息发送完成之后，调用onComplete方法表示消息发送完毕！subscribe表示订阅一条消息，在订阅的时候我们可以传入一个Observer对象，也可以传入一个Subscriber对象，这两个对象中的方法都是一样的，在onNext方法中处理消息，当消息处理完成之后会自动的调用onComplete方法，如果消息处理过程中出错，则会调用onError方法</p>
<p>如果我在onNext方法执行一行  1/0 ，onNext方法改成下面的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void onNext(String s) &#123;  </div><div class="line">                        Log.d(&quot;google_lenve_fb&quot;, &quot;onNext: &quot; + s);  </div><div class="line">                        int i = 1 / 0;  </div><div class="line">                    &#125;</div></pre></td></tr></table></figure></p>
<p>打印结果如下：<br>onNext: 哈哈哈哈<br>onError:onError()   </p>
<p>当第一条消息打印出来之后，执行1/0时抛异常，直接调用了onError方法，第二条消息将不再处理</p>
<h4 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h4><ul>
<li>1 from函数<br>Observale中的from函数接受一个数组，这个方法返回一个按数组元素的顺序来发射这些数据的Observale</li>
<li>2  just函数<br>just函数它接受最多10个参数，返回一个按参数顺序发射这些数据的Observable</li>
<li>3 map函数<br>map函数可以对Observable创建的原始数据进行二次加工，然后再被观察者获取<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Observable.from(new String[]&#123;&quot;Observable Test stringOne&quot;,&quot;Observable Test stringTwo&quot;&#125;)  </div><div class="line">                .map(new Func1&lt;String, String&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public String call(String s) &#123;  </div><div class="line">                        return s + &quot;---end&quot;;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;)  </div><div class="line">                .subscribe(new Observer&lt;String&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public void onCompleted() &#123;  </div><div class="line">  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onError(Throwable e) &#123;  </div><div class="line">  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onNext(String s) &#123;  </div><div class="line">                        Log.d(&quot;google_lenve_fb&quot;, &quot;onNext: &quot; + s);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果如下：<br>Observable Test stringOne”—end<br>Observable Test stringTwo”—end<br>RxJava的使用都是链式编程，使用map函数时数据来源可以各种各样</p>
<ul>
<li>4 flatMap函数<br>flatMap函数接受一个Observable函数作为输入函数，然后在这个输入的基础上再创建一个新的Observable进行输出，比如下面一段代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[java] view plain copy print?Observable.just(&quot;Test stringOne&quot;, &quot;Test stringTwo&quot;)  </div><div class="line">                .flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public Observable&lt;String&gt; call(String s) &#123;  </div><div class="line">                        return Observable.from(new  String[]&#123;s + &quot;endOne&quot;, s + &quot;endTwo&quot;&#125;);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;).subscribe(new Subscriber&lt;String&gt;() &#123;  </div><div class="line">            @Override  </div><div class="line">            public void onCompleted() &#123;  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            public void onError(Throwable e) &#123;  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            public void onNext(String s) &#123;  </div><div class="line">                Log.d(&quot;google_lenve_fb&quot;, &quot;onNext: &quot; + s);  </div><div class="line">            &#125;  </div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果：<br>Test stringOneendOne<br>Test stringOneendTwo<br>Test stringTwoendOne<br>Test stringTwoendTwo</p>
<ul>
<li>5 scan函数<br>scan函数是一个累加器函数，对于Observable发射的每项数据进行累加，并将累加<br>的结果返回，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">[java] view plain copy print?Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)  </div><div class="line">                .scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public Integer call(Integer integer, Integer integer2) &#123;  </div><div class="line">                        return integer + integer2;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;)  </div><div class="line">                .subscribe(new Observer&lt;Integer&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public void onCompleted() &#123;  </div><div class="line">  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onError(Throwable e) &#123;  </div><div class="line">  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onNext(Integer integer) &#123;  </div><div class="line">                        Log.d(&quot;google_lenve_fb&quot;, &quot;onNext: &quot; + integer);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;);  </div><div class="line">        Observable.from(new String[]&#123;&quot;明&quot;, &quot;月&quot;, &quot;别&quot;, &quot;枝&quot;, &quot;惊&quot;, &quot;鹊&quot;&#125;)  </div><div class="line">                .scan(new Func2&lt;String, String, String&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public String call(String s, String s2) &#123;  </div><div class="line">                        return s + s2;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;)  </div><div class="line">                .subscribe(new Subscriber&lt;String&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public void onCompleted() &#123;  </div><div class="line">  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onError(Throwable e) &#123;  </div><div class="line">  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onNext(String s) &#123;  </div><div class="line">                        Log.d(&quot;google_lenve&quot;, &quot;onNext: &quot; + s);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果如下：<br>D/google_lenve_fb: onNext: 1<br>D/google_lenve_fb: onNext: 3<br>D/google_lenve_fb: onNext: 6<br>D/google_lenve_fb: onNext: 10<br>D/google_lenve_fb: onNext: 15<br>D/google_lenve_fb: onNext: 21<br>D/google_lenve_fb: onNext: 28<br>D/google_lenve_fb: onNext: 36<br>D/google_lenve_fb: onNext: 45<br>D/google_lenve_fb: onNext: 55<br>D/google_lenve: onNext: 明<br>D/google_lenve: onNext: 明月<br>D/google_lenve: onNext: 明月别<br>D/google_lenve: onNext: 明月别枝<br>D/google_lenve: onNext: 明月别枝惊<br>D/google_lenve: onNext: 明月别枝惊鹊  </p>
<ul>
<li><p>6 elementAt函数<br>elementAt函数表示获取数据源中的第N项数据输出</p>
</li>
<li><p>7 merge函数<br>merge函数可以用来合并多个Observable数据源，然后将合并后的数据在一起输出，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[java] view plain copy print?Observable&lt;String&gt; observable1 = Observable.just(&quot;十里楼台倚翠薇&quot;, &quot;百花深处杜鹃啼&quot;);  </div><div class="line">        Observable&lt;String&gt; observable2 = Observable.just(&quot;殷勤自与行人语&quot;,&quot;不似流莺取次飞&quot;);  </div><div class="line">        Observable.merge(observable1, observable2)  </div><div class="line">                .subscribe(new Subscriber&lt;String&gt;() &#123;  </div><div class="line">                    @Override  </div><div class="line">                    public void onCompleted() &#123;  </div><div class="line">  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onError(Throwable e) &#123;  </div><div class="line">  </div><div class="line">                    &#125;  </div><div class="line">  </div><div class="line">                    @Override  </div><div class="line">                    public void onNext(String s) &#123;  </div><div class="line">                        Log.d(&quot;google_lenve&quot;, &quot;onNext: &quot;+s);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果如下：<br>D/google_lenve: onNext: 十里楼台倚翠薇<br>D/google_lenve: onNext: 百花深处杜鹃啼<br>D/google_lenve: onNext: 殷勤自与行人语<br>D/google_lenve: onNext: 不似流莺取次飞  </p>
<ul>
<li>8 zip函数<br>zip函数用来合并多个Observable的数据源，但是与merge不同的是，zip函数中可以对数据源进行二次操作，而不是简单的合并，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[java] view plain copy print?Observable&lt;String&gt; observable1 = Observable.just(&quot;十里楼台倚翠薇&quot;, &quot;百花深处杜鹃啼&quot;);  </div><div class="line">        Observable&lt;String&gt; observable2 = Observable.just(&quot;问君能有几多愁&quot;,&quot;恰似一江春水向东流&quot;);  </div><div class="line">        Observable.zip(observable1, observable2, new Func2&lt;String, String, Object&gt;() &#123;  </div><div class="line">            @Override  </div><div class="line">            public Object call(String s, String s2) &#123;  </div><div class="line">                return s+s2;  </div><div class="line">            &#125;  </div><div class="line">        &#125;)  </div><div class="line">        .subscribe(new Subscriber&lt;Object&gt;() &#123;  </div><div class="line">            @Override  </div><div class="line">            public void onCompleted() &#123;  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            public void onError(Throwable e) &#123;  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            public void onNext(Object o) &#123;  </div><div class="line">                Log.d(&quot;google_lenve&quot;, &quot;onNext: &quot;+o.toString());  </div><div class="line">            &#125;  </div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果如下：<br>D/google_lenve: onNext: 十里楼台倚翠薇问君能有几多愁<br>D/google_lenve: onNext: 百花深处杜鹃啼恰似一江春水向东流  </p>
<ul>
<li>9 过滤函数<br>Observable函数中还有其他一些好用的过滤函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private void m7() &#123;  </div><div class="line">    Observable.just(10, 12, 13, 14, 15, 16, 16, 16, 17, 18)  </div><div class="line">        //在数据序列的开头插入一条指定的项1  </div><div class="line">            .startWith(2)  </div><div class="line">            .filter(new Func1&lt;Integer, Boolean&gt;() &#123;  </div><div class="line">                @Override  </div><div class="line">                public Boolean call(Integer integer) &#123;  </div><div class="line">                    return integer &gt; 0;  </div><div class="line">                &#125;  </div><div class="line">            &#125;)  </div><div class="line">        //只发射前N个元素  </div><div class="line">            .take(2)  </div><div class="line">        //只发射最后N个元素  </div><div class="line">            .takeLast(2)  </div><div class="line">        //只发射第一个元素  </div><div class="line">            .first()  </div><div class="line">        //只发射最后一个元素  </div><div class="line">            .last()  </div><div class="line">        //跳过前两个  </div><div class="line">            .skip(2)  </div><div class="line">            //跳过最后两个  </div><div class="line">            .skipLast(2)  </div><div class="line">            //数据过滤，过滤掉重复数据  </div><div class="line">            .distinct()  </div><div class="line">            .subscribe(new Observer&lt;Integer&gt;() &#123;  </div><div class="line">                @Override  </div><div class="line">                public void onCompleted() &#123;  </div><div class="line">  </div><div class="line">                &#125;  </div><div class="line">  </div><div class="line">                @Override  </div><div class="line">                public void onError(Throwable e) &#123;  </div><div class="line">  </div><div class="line">                &#125;  </div><div class="line"> </div><div class="line">                @Override  </div><div class="line">                public void onNext(Integer integer) &#123;  </div><div class="line">                    Log.d(&quot;google_lenve_fb&quot;, &quot;onNext: &quot; + integer);  </div><div class="line">                &#125;  </div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>推荐参考<br><a href="http://wuxiaolong.me/2016/01/18/rxjava/" target="_blank" rel="external">RXJava</a><br><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a></p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/04/23/RXAndroid/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-04-12T06:06:15.000Z"><a href="/2016/04/12/Invalid-double崩溃分析/">2016-04-12</a></time>
        
  
    <h1 class="title"><a href="/2016/04/12/Invalid-double崩溃分析/">Invalid double崩溃分析</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>第一次遇到</p>
<p>java.lang.NumberFormatException: Invalid double: “0,3”<br>这样包含逗号的浮点数异常，第一感觉就是服务器给的数据错误，但前段时间复现了这个异常，才发现是代码不规范导致了这样的异常： 崩溃的详细log如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">E/AndroidRuntime: FATAL EXCEPTION: mainProcess: com.frank.lollipopdemo, PID: </div><div class="line">10898java.lang.RuntimeException: Unable to start activity </div><div class="line">ComponentInfo&#123;com.frank.lollipopdemo/com.frank.lollipopdemo.MainActivity&#125;: </div><div class="line">java.lang.NumberFormatException: Invalid double: &quot;0,3&quot; at </div><div class="line">android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2325) at </div><div class="line">android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2387) at </div><div class="line">android.app.ActivityThread.access$800(ActivityThread.java:151) at </div><div class="line">android.app.ActivityThread$H.handleMessage(ActivityThread.java:1303) at </div><div class="line">android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:135) at </div><div class="line">android.app.ActivityThread.main(ActivityThread.java:5254) at java.lang.reflect.Method.invoke(Native </div><div class="line">Method) at java.lang.reflect.Method.invoke(Method.java:372) at </div><div class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903) at </div><div class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698) Caused by: </div><div class="line">java.lang.NumberFormatException: Invalid double: &quot;0,3&quot; at </div><div class="line">java.lang.StringToReal.invalidReal(StringToReal.java:63) at </div><div class="line">java.lang.StringToReal.initialParse(StringToReal.java:164) at </div><div class="line">java.lang.StringToReal.parseDouble(StringToReal.java:282) at </div><div class="line">java.lang.Double.parseDouble(Double.java:301) at </div><div class="line">com.frank.lollipopdemo.MainActivity.onCreate(MainActivity.java:43) at </div><div class="line">android.app.Activity.performCreate(Activity.java:5990) at </div><div class="line">android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1106) at </div><div class="line">android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2278) at </div><div class="line">android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2387) at </div><div class="line">android.app.ActivityThread.access$800(ActivityThread.java:151) at </div><div class="line">android.app.ActivityThread$H.handleMessage(ActivityThread.java:1303) at </div><div class="line">android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:135) at </div><div class="line">android.app.ActivityThread.main(ActivityThread.java:5254) at java.lang.reflect.Method.invoke(Native </div><div class="line">Method) at java.lang.reflect.Method.invoke(Method.java:372) at </div><div class="line">com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903) at</div><div class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)</div></pre></td></tr></table></figure></p>
<p>而出错的代码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        tv_title = (TextView) findViewById(R.id.tv_title);</div><div class="line">        tv_content = (TextView) findViewById(R.id.tv_content);</div><div class="line">        String jsonVal = &quot;0.31415926&quot;;</div><div class="line">        String title = remain1Places(jsonVal);// -&gt; 0.3</div><div class="line">        tv_title.setText(title);</div><div class="line">        tv_content.setText(getPercent(Double.parseDouble(title)));// -&gt; ##.##%</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String remain1Places(String string) &#123;</div><div class="line">        if (TextUtils.isEmpty(string)) &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        return String.format(&quot;%.1f&quot;, Double.parseDouble(string));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String getPercent(double value) &#123;</div><div class="line">        NumberFormat numberFormat = NumberFormat.getPercentInstance();</div><div class="line">        numberFormat.setMinimumFractionDigits(1);</div><div class="line">        numberFormat.setMaximumFractionDigits(2);</div><div class="line">        return numberFormat.format(value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>想把浮点数”0.31415926”保留一位小数，就使用了String.format()<br>方法完成，而且完全不顾编译器对我们的建议： <img src="http://upload-images.jianshu.io/upload_images/4398977-6b4a754e0cd9d8cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述">之后，我们想把保留了一位小数后的浮点数”0.3”转成百分比的形式”30.0%”，当然先转成double，然后利用NumberFormat<br>格式化成百分比。 看似没有问题，但是当我们把系统语言换成法语(France)之后，程序直接Crash，而且当我们只显示remain1Places()<br>后的title时，发现”0.31415926”变成了”0,3”，而不是”0.3”，这就直接导致了Double.parseDouble(“0,3”)抛出一个数据格式异常。 那为什么String.format()<br>会将小数点的”句点(.)“换成了”逗号(,)“呢？<br>摘自<a href="https://en.wikipedia.org/wiki/Decimal_mark" target="_blank" rel="external">维基百科</a>： A decimal mark is a symbol used to separate the integer part from the fractional part of a number written in decimal form. Different countries officially designate different symbols for the decimal mark. The choice of symbol for the decimal mark also affects the choice of symbol for the thousands separator used in digit grouping, so the latter is also treated in this article. <img src="http://upload-images.jianshu.io/upload_images/4398977-562e843356d6da5e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>可以看到，有很多地区都是用<strong>逗号(,)</strong>作为<strong>小数点</strong>的，如19,90€表示19.9欧元；但计算机程序中的浮点数必须用<strong>句点(.)</strong>作为小数点，如double price = 19.90;<br>表示浮点数19.9。所以在使用double的包装类Double<br>的parseDouble(String)<br>或valueOf(String)<br>方法将字符串表示的double值转成double时，字符串所表示的double值必须是用<strong>句点(.)</strong>分隔的浮点数，也就是计算机的浮点数表示形式。<br>Double.valueOf(String)<br>方法仅仅调用了Double.parseDouble(String)<br>并返回Double<br>对象。 Double.parseDouble(String)<br>方法返回原语类型的double<br>变量。</p>
<p>因此，我们就可以断定这是一个本地化（Locale）的问题了。现在再来看一下编译器(lint)给我们String.format()<br>方法的建议：<br>Implicitly using the default locale is a common source of bugs: Use String.format(Locale, …) instead. 隐式地使用默认的区域设置是常见Bug源，请使用String.format(Locale, …)等方法替换它。</p>
<p>也就是说，String.format(String format, Object… args)<br>会调用format(Locale.getDefault(), format, args)<br>使用<strong>用户默认的区域设置</strong>返回格式化好且本地化好的字符串，因用户设置的不同而返回不同的字符串，进而出现Bug。如果你只是想格式化字符串而不是人为干预，应该用</p>
<p><code>String.format(Locale locale, String format, Object... args)</code><br>方法，Locale参数用Locale.US<br>就可以了。<br>因此，我们应该重视本地化问题：<br>将字符串所有字符转为大/小写的方法String.toLowerCase()<br>/String.toUpperCase()<br>并不一定能将字符真正的大/小写（如区域设置为土耳其时，i大写后还是i），因此应该指定要使用的区域设置String.toLowerCase(Locale locale)<br>/String.toUpperCase(Locale locale)<br>。<br>格式化字符串的方法String.format(String format, Object… args)<br>应该指定区域设置，以避免区域设置变化导致的Bug。<br><strong>千万不要将数字format()<br>成字符串后再将该字符串转回原语类型</strong>，因为format()<br>后的字符串可能不是合法的原语类型的数字了。即永远不要出现类似这样</p>
<p>Double.parseDouble(new DecimalFormat(“#.##”).format(doubleValue))<br>的代码。<br>建议使用NumberFormat<br>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static String remain1Places(String str) &#123;</div><div class="line">    NumberFormat numberFormat = NumberFormat.getInstance(Locale.getDefault());</div><div class="line">    numberFormat.setMinimumFractionDigits(1);</div><div class="line">    numberFormat.setMaximumFractionDigits(1);</div><div class="line">    return numberFormat.format(Double.parseDouble(str));</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static String getPercent(String str) &#123;</div><div class="line">    NumberFormat numberFormat = NumberFormat.getPercentInstance(Locale.getDefault());</div><div class="line">    numberFormat.setMinimumFractionDigits(1);</div><div class="line">    numberFormat.setMaximumFractionDigits(2);</div><div class="line">    return numberFormat.format(Double.parseDouble(str));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/04/12/Invalid-double崩溃分析/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-04-03T06:21:44.000Z"><a href="/2016/04/03/Android动态添加权限/">2016-04-03</a></time>
        
  
    <h1 class="title"><a href="/2016/04/03/Android动态添加权限/">Android动态添加权限</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>一、工具</p>
<p>权限适配工具 PermissionsDispatcher</p>
<p>使用注解</p>
<p>@RuntimePermissions 是必须的注册当前activity或fragment</p>
<p>@NeedsPermission 是必须要有的，在需要权限的方法上添加</p>
<p>@OnShowRationale 注释一个方法解释为什么需要这个(个)权限并提示用户判断是否允许</p>
<p>@OnPermissionDenied 当权限被拒绝时调用</p>
<p>@OnNeverAskAgain 当用户勾选了不再提示时调用</p>
<p>使用方法：</p>
<p>注意：同一组内的任何一个权限被授权了，其他权限也自动被授权。例如，一旦READ_CALENDAR被授权了，应用也有WRITE_CALENDAR权限了。</p>
<p>参考文档</p>
<p>Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line">@RuntimePermissions</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line"></div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line"></div><div class="line">super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">findViewById(R.id.button_camera).setOnClickListener(this);</div><div class="line"></div><div class="line">findViewById(R.id.button_contacts).setOnClickListener(this);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line"></div><div class="line">public void onClick(@NonNull View v) &#123;</div><div class="line"></div><div class="line">switch (v.getId()) &#123;</div><div class="line"></div><div class="line">case R.id.button_camera:</div><div class="line"></div><div class="line">// NOTE: delegate the permission handling to generated method</div><div class="line"></div><div class="line">MainActivityPermissionsDispatcher.showCameraWithCheck(this);</div><div class="line"></div><div class="line">break;</div><div class="line"></div><div class="line">case R.id.button_contacts:</div><div class="line"></div><div class="line">// NOTE: delegate the permission handling to generated method</div><div class="line"></div><div class="line">MainActivityPermissionsDispatcher.showContactsWithCheck(this);</div><div class="line"></div><div class="line">break;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line"></div><div class="line">public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</div><div class="line"></div><div class="line">super.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line"></div><div class="line">// NOTE: delegate the permission handling to generated method</div><div class="line"></div><div class="line">MainActivityPermissionsDispatcher.onRequestPermissionsResult(this, requestCode, grantResults);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@NeedsPermission(Manifest.permission.CAMERA)</div><div class="line"></div><div class="line">void showCamera() &#123;</div><div class="line"></div><div class="line">// NOTE: Perform action that requires the permission. If this is run by PermissionsDispatcher, the permission will have been granted</div><div class="line"></div><div class="line">getSupportFragmentManager().beginTransaction()</div><div class="line"></div><div class="line">.replace(R.id.sample_content_fragment, CameraPreviewFragment.newInstance())</div><div class="line"></div><div class="line">.addToBackStack(&quot;camera&quot;)</div><div class="line"></div><div class="line">.commitAllowingStateLoss();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@NeedsPermission(&#123;Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS&#125;)</div><div class="line"></div><div class="line">void showContacts() &#123;</div><div class="line"></div><div class="line">// NOTE: Perform action that requires the permission.</div><div class="line"></div><div class="line">// If this is run by PermissionsDispatcher, the permission will have been granted</div><div class="line"></div><div class="line">getSupportFragmentManager().beginTransaction()</div><div class="line"></div><div class="line">.replace(R.id.sample_content_fragment, ContactsFragment.newInstance())</div><div class="line"></div><div class="line">.addToBackStack(&quot;contacts&quot;)</div><div class="line"></div><div class="line">.commitAllowingStateLoss();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@OnShowRationale(Manifest.permission.CAMERA)</div><div class="line"></div><div class="line">void showRationaleForCamera(PermissionRequest request) &#123;</div><div class="line"></div><div class="line">// NOTE: Show a rationale to explain why the permission is needed, e.g. with a dialog.</div><div class="line"></div><div class="line">// Call proceed() or cancel() on the provided PermissionRequest to continue or abort</div><div class="line"></div><div class="line">showRationaleDialog(R.string.permission_camera_rationale, request);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@OnShowRationale(&#123;Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS&#125;)</div><div class="line"></div><div class="line">void showRationaleForContact(PermissionRequest request) &#123;</div><div class="line"></div><div class="line">// NOTE: Show a rationale to explain why the permission is needed, e.g. with a dialog.</div><div class="line"></div><div class="line">// Call proceed() or cancel() on the provided PermissionRequest to continue or abort</div><div class="line"></div><div class="line">showRationaleDialog(R.string.permission_contacts_rationale, request);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@OnPermissionDenied(Manifest.permission.CAMERA)</div><div class="line"></div><div class="line">void onCameraDenied() &#123;</div><div class="line"></div><div class="line">// NOTE: Deal with a denied permission, e.g. by showing specific UI</div><div class="line"></div><div class="line">// or disabling certain functionality</div><div class="line"></div><div class="line">Toast.makeText(this, R.string.permission_camera_denied, Toast.LENGTH_SHORT).show();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@OnNeverAskAgain(Manifest.permission.CAMERA)</div><div class="line"></div><div class="line">void onCameraNeverAskAgain() &#123;</div><div class="line"></div><div class="line">Toast.makeText(this, R.string.permission_camera_never_askagain, Toast.LENGTH_SHORT).show();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public void onBackClick(View view) &#123;</div><div class="line"></div><div class="line">getSupportFragmentManager().popBackStack();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">private void showRationaleDialog(@StringRes int messageResId, final PermissionRequest request) &#123;</div><div class="line"></div><div class="line">new AlertDialog.Builder(this)</div><div class="line"></div><div class="line">.setPositiveButton(R.string.button_allow, new DialogInterface.OnClickListener() &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line"></div><div class="line">public void onClick(@NonNull DialogInterface dialog, int which) &#123;</div><div class="line"></div><div class="line">request.proceed();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line">.setNegativeButton(R.string.button_deny, new DialogInterface.OnClickListener() &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line"></div><div class="line">public void onClick(@NonNull DialogInterface dialog, int which) &#123;</div><div class="line"></div><div class="line">request.cancel();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line">.setCancelable(false)</div><div class="line"></div><div class="line">.setMessage(messageResId)</div><div class="line"></div><div class="line">.show();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>权限适配工具 PermissionCompat</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/04/03/Android动态添加权限/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-03-12T05:38:32.000Z"><a href="/2016/03/12/Java-SSL-Socket通讯实例二/">2016-03-12</a></time>
        
  
    <h1 class="title"><a href="/2016/03/12/Java-SSL-Socket通讯实例二/">Java SSL Socket通讯实例二</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>对于SSL/TLS协议，如果要每个开发者都自己去实现显然会带来不必要的麻烦，正是为了解决这个问题<a href="http://www.2cto.com/kf/ware/Java/" target="_blank" rel="external">Java</a>为广大开发者提供了Java安全套接字扩展——JSSE，它包含了实现Internet安全通信的一系列包的集合，是SSL和TLS的纯Java实现，同时它是一个开放的标准，每个公司都可以自己实现JSSE，通过它可以透明地提供数据<a href="http://www.2cto.com/Article/jiami/" target="_blank" rel="external">加密</a>、服务器认证、信息完整性等功能，就像使用普通的套接字一样使用安全套接字，大大减轻了开发者的负担，使开发者可以很轻松将SSL协议整合到程序中，并且JSSE能将安全隐患降到了最低点。<br>在利用SSL/TLS进行安全通信时，客户端跟服务器端都必须要支持SSL/TLS协议，不然将无法进行通信。而且客户端和服务器端都可能要设置用于证实自己身份的安全证书，并且还要设置信任对方的哪些安全证书。<br>关于身份认证方面有个名词叫客户端模式，一般情况客户端要对服务器端的身份进行验证，但是无需向服务器证实自己的身份，这样不用向对方证实自己身份的通信端我们就说它处于客户模式，否则成它处于服务器模式。SSLSocket的setUseClientMode(Boolean mode)方法可以设置客户端模式或服务器模式。<br>下面看具体实现的过程<br>① 解决证书问题。<br>一般而言作为服务器端必须要有证书以证明这个服务器的身份，并且证书应该描述此服务器所有者的一些基本信息，例如公司名称、联系人名等。证书由所有人以密码形式签名，基本不可伪造，证书获取的途径有两个：一是从权威机构购买证书，权威机构担保它发出的证书的真实性，而且这个权威机构被大家所信任，进而你可以相信这个证书的有效性；另外一个是自己用JDK提供的工具keytool创建一个自我签名的证书，这种情况下一般是我只想要保证数据的安全性与完整性，避免数据在传送的过程中被窃听或篡改，此时身份的认证已不重要，重点已经在端与端传输的秘密性上，证书的作用只体现在加解密签名。<br>SSL协议通信涉及密钥储存的文件格式比较多，很容易搞混，例如xxx.cer、xxx.pfx、xxx.jks、xxx.keystore、xxx.truststore等格式文件。如图3-1-7-3，搞清楚他们有助于理解后面的程序，.cer格式文件俗称证书，但这个证书中没有私钥，只包含了公钥；.pfx格式文件也称为证书，它一般供<a href="http://www.2cto.com/os/liulanqi/" target="_blank" rel="external">浏览器</a>使用，而且它不仅包含了公钥，还包含了私钥，当然这个私钥是加密的，不输入密码是解不了密的；.jks格式文件表示java密钥存储器（java key store），它可以同时容纳N个公钥跟私钥，是一个密钥库；.keystore格式文件其实跟.jks基本是一样的，只是不同公司叫法不太一样，默认生成的证书存储库格式；.truststore格式文件表示信任证书存储库，它仅仅包含了通信对方的公钥，当然你可以直接把通信对方的jks作为信任库（就算如此你也只能知道通信对方的公钥，要知道密钥都是加密的，你无从获取，只要算法不被<a href="http://www.2cto.com/Article/jiami/" target="_blank" rel="external">破解</a>）。有些时候我们需要把pfx或cert转化为jks以便于用java进行ssl通信，例如一个银行只提供了pfx证书，而我们想用java进行ssl通信时就要将pfx转化为jks格式。<br><img src="http://upload-images.jianshu.io/upload_images/4398977-4282e92c21880f9a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="\"><br>图3-1-7-3 密钥存储文件格式</p>
<p>按照理论上，我们一共需要准备四个文件，两个keystore文件和两个truststore文件，通信双方分别拥有一个keystore和一个truststore，keystore用于存放自己的密钥和公钥，truststore用于存放所有需要信任方的公钥。这里为了方便直接使用jks即keystore替代truststore（免去证书导来导去），因为对方的keystore包含了自己需要的信任公钥。<br>下面使用jdk自带的工具分别生成服务器端证书，通过如下命令并输入姓名、组织单位名称、组织名称、城市、省份、国家信息即可生成证书密码为tomcat的证书，此证书存放在密码也为tomcat的tomcat.jks证书存储库中。如果你继续创建证书将继续往tomcat.jks证书存储库中添加证书。如果你仅仅输入keytool -genkey -alias tomcat -keyalg RSA -keypass tomcat -storepass tomcat，不指定证书存储库的文件名及路径，则工具会在用户的home directory目录下生产一个“.keystore”文件作为证书存储库。<br><img src="http://upload-images.jianshu.io/upload_images/4398977-b9350297f1636989.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="\"><br>类似的，客户端证书也用此方式进行生成。如下<br><img src="http://upload-images.jianshu.io/upload_images/4398977-d60598093e5c7d93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="\"><br>② 服务端TomcatSSLServer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">public class TomcatSSLServer &#123;</div><div class="line"> private static final String SSL_TYPE = &quot;SSL&quot;;</div><div class="line"> private static final String KS_TYPE = &quot;JKS&quot;;</div><div class="line"> private static final String X509 = &quot;SunX509&quot;;</div><div class="line"> private final static int PORT = 443;</div><div class="line"> private static TomcatSSLServer sslServer;</div><div class="line"> private SSLServerSocket svrSocket;</div><div class="line">   </div><div class="line"> public static TomcatSSLServer getInstance() throws Exception &#123;</div><div class="line">   if (sslServer == null) &#123;</div><div class="line">    sslServer = new TomcatSSLServer();</div><div class="line">   &#125;</div><div class="line">   return sslServer;</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> private TomcatSSLServer() throws Exception&#123;</div><div class="line">  SSLContext sslContext = createSSLContext();</div><div class="line">  SSLServerSocketFactory serverFactory = sslContext.getServerSocketFactory();</div><div class="line">  svrSocket =(SSLServerSocket) serverFactory.createServerSocket(PORT);</div><div class="line">  svrSocket.setNeedClientAuth(true); </div><div class="line">  String[] supported = svrSocket.getEnabledCipherSuites();</div><div class="line">  svrSocket.setEnabledCipherSuites(supported);</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> private SSLContext createSSLContext() throws Exception&#123;</div><div class="line">  KeyManagerFactory kmf = KeyManagerFactory.getInstance(X509);</div><div class="line">  TrustManagerFactory tmf = TrustManagerFactory.getInstance(X509);</div><div class="line">  String serverKeyStoreFile = &quot;c:\\tomcat.jks&quot;; </div><div class="line">  String svrPassphrase = &quot;tomcat&quot;;               </div><div class="line">  char[] svrPassword = svrPassphrase.toCharArray();</div><div class="line">  KeyStore serverKeyStore = KeyStore.getInstance(KS_TYPE);</div><div class="line">  serverKeyStore.load(new FileInputStream(serverKeyStoreFile), svrPassword);</div><div class="line">  kmf.init(serverKeyStore, svrPassword);</div><div class="line">  String clientKeyStoreFile = &quot;c:\\client.jks&quot;; </div><div class="line">  String cntPassphrase = &quot;client&quot;;              </div><div class="line">  char[] cntPassword = cntPassphrase.toCharArray();</div><div class="line">  KeyStore clientKeyStore = KeyStore.getInstance(KS_TYPE);</div><div class="line">  clientKeyStore.load(new FileInputStream(clientKeyStoreFile),cntPassword);</div><div class="line">  tmf.init(clientKeyStore);</div><div class="line">  SSLContext sslContext  = SSLContext.getInstance(SSL_TYPE);</div><div class="line">  sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);</div><div class="line">  return sslContext;</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> public void startService() &#123;</div><div class="line">  SSLSocket cntSocket = null;</div><div class="line">  BufferedReader ioReader = null;</div><div class="line">  PrintWriter ioWriter = null;</div><div class="line">  String tmpMsg = null;</div><div class="line">  while( true ) &#123;</div><div class="line">   try &#123;</div><div class="line">    cntSocket =(SSLSocket) svrSocket.accept();</div><div class="line">    ioReader = new BufferedReader(new InputStreamReader(cntSocket.getInputStream()));</div><div class="line">    ioWriter = new PrintWriter(cntSocket.getOutputStream());</div><div class="line">    while ( (tmpMsg = ioReader.readLine()) != null) &#123;</div><div class="line">     System.out.println(&quot;客户端通过SSL协议发送信息:&quot;+tmpMsg);</div><div class="line">     tmpMsg=&quot;欢迎通过SSL协议连接&quot;;</div><div class="line">     ioWriter.println(tmpMsg);</div><div class="line">     ioWriter.flush();</div><div class="line">    &#125;</div><div class="line">   &#125; catch(IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">   &#125; finally &#123;</div><div class="line">    try &#123;</div><div class="line">     if(cntSocket != null) cntSocket.close();</div><div class="line">    &#125; catch(Exception ex) &#123;ex.printStackTrace();&#125;</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> public static void main(String[] args) throws Exception &#123;</div><div class="line">  TomcatSSLServer.getInstance().startService();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本顺序是先得到一个SSLContext实例，再对SSLContext实例进行初始化，密钥管理器及信任管理器作为参数传入，证书管理器及信任管理器按照指定的密钥存储器路径和密码进行加载。接着设置支持的加密套件，最后让SSLServerSocket开始监听客户端发送过来的消息。</p>
<p>③ 客户端TomcatSSLClient.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class TomcatSSLClient &#123;</div><div class="line"> private static final String SSL_TYPE = &quot;SSL&quot;;</div><div class="line"> private static final String X509 = &quot;SunX509&quot;;</div><div class="line"> private static final String KS_TYPE = &quot;JKS&quot;;</div><div class="line"> private SSLSocket sslSocket;</div><div class="line">   </div><div class="line"> public TomcatSSLClient(String targetHost,int port) throws Exception &#123;</div><div class="line">  SSLContext sslContext = createSSLContext(); </div><div class="line">  SSLSocketFactory sslcntFactory =(SSLSocketFactory) sslContext.getSocketFactory();</div><div class="line">  sslSocket = (SSLSocket) sslcntFactory.createSocket(targetHost, port);</div><div class="line">  String[] supported = sslSocket.getSupportedCipherSuites();</div><div class="line">  sslSocket.setEnabledCipherSuites(supported); </div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> private SSLContext createSSLContext() throws Exception&#123;</div><div class="line">  KeyManagerFactory kmf = KeyManagerFactory.getInstance(X509);</div><div class="line">  TrustManagerFactory tmf = TrustManagerFactory.getInstance(X509);</div><div class="line">  String clientKeyStoreFile = &quot;c:\\client.jks&quot;;</div><div class="line">  String cntPassphrase = &quot;client&quot;;</div><div class="line">  char[] cntPassword = cntPassphrase.toCharArray();</div><div class="line">  KeyStore clientKeyStore = KeyStore.getInstance(KS_TYPE);</div><div class="line">  clientKeyStore.load(new FileInputStream(clientKeyStoreFile),cntPassword);</div><div class="line">  String serverKeyStoreFile = &quot;c:\\tomcat.jks&quot;;</div><div class="line">  String svrPassphrase = &quot;tomcat&quot;;</div><div class="line">  char[] svrPassword = svrPassphrase.toCharArray();</div><div class="line">  KeyStore serverKeyStore = KeyStore.getInstance(KS_TYPE);</div><div class="line">  serverKeyStore.load(new FileInputStream(serverKeyStoreFile), svrPassword);</div><div class="line">  kmf.init(clientKeyStore, cntPassword);</div><div class="line">  tmf.init(serverKeyStore);</div><div class="line">  SSLContext sslContext  = SSLContext.getInstance(SSL_TYPE);</div><div class="line">  sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);</div><div class="line">  return sslContext;</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> public String sayToSvr(String sayMsg) throws IOException&#123;</div><div class="line">  BufferedReader ioReader = new BufferedReader(new InputStreamReader(</div><div class="line">    sslSocket.getInputStream()));</div><div class="line">  PrintWriter ioWriter = new PrintWriter(sslSocket.getOutputStream());</div><div class="line">  ioWriter.println(sayMsg);</div><div class="line">  ioWriter.flush();</div><div class="line">  return ioReader.readLine();</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> public static void main(String[] args) throws Exception &#123;</div><div class="line">  TomcatSSLClient sslSocket = new TomcatSSLClient(&quot;127.0.0.1&quot;,443);</div><div class="line">  BufferedReader ioReader = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">  String sayMsg = &quot;&quot;;</div><div class="line">  String svrRespMsg= &quot;&quot;;</div><div class="line">  while( (sayMsg = ioReader.readLine())!= null ) &#123;</div><div class="line">   svrRespMsg = sslSocket.sayToSvr(sayMsg);</div><div class="line">   if(svrRespMsg != null &amp;&amp; !svrRespMsg.trim().equals(&quot;&quot;)) &#123;</div><div class="line">    System.out.println(&quot;服务器通过SSL协议响应:&quot;+svrRespMsg);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端的前面操作基本跟服务器端的一样，先创建一个SSLContext实例，再用密钥管理器及信任管理器对SSLContext进行初始化，当然这里密钥存储的路径是指向客户端的client.jks。接着设置加密套件，最后使用SSLSocket进行通信。</p>
<p>注意服务器端有行代码svrSocket.setNeedClientAuth(true);它是非常重要的一个设置方法，用于设置是否验证客户端的身份。假如我们把它注释掉或设置为false，此时客户端将不再需要自己的密钥管理器，即服务器不需要通过client.jks对客户端的身份进行验证，把密钥管理器直接设置为null也可以跟服务器端进行通信。</p>
<p>最后谈谈信任管理器，它的职责是决定是否信任远端的证书，那么它凭借什么去判断呢？如果不显式设置信任存储器的文件路径，将遵循如下规则：①如果<a href="http://www.2cto.com/os/" target="_blank" rel="external">系统</a>属性javax.net.ssl.truststore指定了truststore文件，那么信任管理器将去jre路径下的lib/security目录寻找这个文件作为信任存储器；②如果没设置①中的系统属性，则去寻找一个%java_home%/lib/security/jssecacerts文件作为信任存储器；③如果jssecacerts不存在而cacerts存在，则cacerts作为信任存储器。<br>至此，一个利用JSSE实现BIO模式的SSL协议通信的例子已完成。</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2016/03/12/Java-SSL-Socket通讯实例二/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



 
<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
      <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title" id="categories">分类</h3>
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cordova/">Cordova</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQTT/">MQTT</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSL/">SSL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安卓直播开发/">安卓直播开发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">7</span></li></ul> 
</div>
 


  <div class="widget tag">
  <h3 class="title">微信公众账号</h3>
    <ul class="entry">
      <img src="/img/default/wx.png" alt="欢迎关注，该账号供个人学习使用，偶尔做一些开发尝试，更新频率较低。" style= "width: 100%">
    </ul>
</div>

  <div class="widget tag">
  <h3 class="title">日历云</h3>
  <div id="calendar"></div>
</div>


  
<div class="widget">
  <h3 class="title">最新评论</h3>
  	<!-- 多说最新评论 start -->
	<div class="ds-recent-comments ds-recent-user" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div>
	<!-- 多说最新评论 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"samychen"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
	<!-- 多说公共JS代码 end -->
</div>



  


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Cordova/" style="font-size: 15px;">Cordova</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MQTT/" style="font-size: 11.67px;">MQTT</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/SSL，Https/" style="font-size: 13.33px;">SSL，Https</a> <a href="/tags/SSL，Https，安卓/" style="font-size: 10px;">SSL，Https，安卓</a> <a href="/tags/单例模式/" style="font-size: 11.67px;">单例模式</a> <a href="/tags/安卓/" style="font-size: 16.67px;">安卓</a> <a href="/tags/安卓，Java/" style="font-size: 18.33px;">安卓，Java</a> <a href="/tags/工厂模式/" style="font-size: 10px;">工厂模式</a> <a href="/tags/生产者消费者模式/" style="font-size: 11.67px;">生产者消费者模式</a> <a href="/tags/网络协议/" style="font-size: 10px;">网络协议</a> <a href="/tags/装饰者模式/" style="font-size: 11.67px;">装饰者模式</a>
  </div>
</div>


  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">公元 2017 年</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">公元 2016 年</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">公元 2015 年</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/">公元 2014 年</a><span class="archive-list-count">10</span></li></ul>
  </div>

</aside>
      <div class="clearfix"></div>
    </div>
  
  <footer id="footer"><div class="footer-content inner">
  <div class="alignleft">
  
    &copy; 2018 SamyChen
    
  </div>
  <div class="alignright">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
    <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
  </div>
  
  <div class="visit">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </div>
  
  <div class="clearfix"></div>
</div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'calendar'});
    
    });
  </script>


<!-- 『不蒜子』计数服务 -->
<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- wumii关联推荐 -->
<script type="text/javascript" src="http://widget.wumii.cn/ext/relatedItemsWidget"></script>

<!-- 百度推荐 -->

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?9acf0cedd48dc53be256ede5a98c2aaa";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

<!-- 站内搜索-Swiftype -->
<!-- <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','sC-iNFrvTTNtiXEVNwo1','2.0.0');
</script> -->

<!-- fancybox -->

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
