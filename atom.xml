<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SamyChen</title>
  <icon>https://www.gravatar.com/avatar/e9c9d34132cf893446c55d87da6fcf36</icon>
  <subtitle>SamyChen的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://samychen.com/"/>
  <updated>2018-02-24T06:34:07.096Z</updated>
  <id>http://samychen.com/</id>
  
  <author>
    <name>SamyChen</name>
    <email>samychen2016@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>霍夫变换</title>
    <link href="http://samychen.com/2018/02/21/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/"/>
    <id>http://samychen.com/2018/02/21/霍夫变换/</id>
    <published>2018-02-21T06:33:20.000Z</published>
    <updated>2018-02-24T06:34:07.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="霍夫变换——直线"><a href="#霍夫变换——直线" class="headerlink" title="霍夫变换——直线"></a>霍夫变换——直线</h2><p>&emsp;&emsp;Hough Line Transform用来做直线检测，前提是已经做了边缘检测。<br>&emsp;&emsp;霍夫变换是平面空间到极坐标空间的转换，具有以下特点：</p><ul><li>对于任意一条直线上的所有点来说，变换到极坐标中，根据theta值可以得到r值</li><li>属于同一条直线上的点在极坐标(r,theta)必然在一个点上有最强的信号出现，因此根据最强信号的极坐标反算到平面坐标中就可以得到直线上各个点的像素坐标，从而得到直线。</li></ul><p>相关API：</p><ul><li>标准的霍夫变换cv::HoughLines从平面坐标转换到霍夫空间，最终输出是(theta,r)，表示极坐标空间</li><li>霍夫变换直线概率cv::HoughLinesP最终输出是直线的两个点</li></ul><p>先进行边缘检测，在进行霍夫直线检测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;math.h&gt;</div><div class="line">using namespace cv;</div><div class="line">using namespace std;</div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/linedec.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">namedWindow(&quot;output img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">Canny(src, gray, 150, 200);</div><div class="line">cvtColor(gray, dst, CV_GRAY2BGR);</div><div class="line">imshow(&quot;edge img&quot;, gray);</div><div class="line">vector&lt;Vec4f&gt; plines;</div><div class="line">HoughLinesP(gray, plines, 1, CV_PI / 180.0, 10, 0, 10);</div><div class="line">Scalar color = Scalar(0, 0, 255);</div><div class="line">for (size_t i = 0; i &lt; plines.size(); i++)</div><div class="line">&#123;</div><div class="line">Vec4f hlines = plines[i];</div><div class="line">line(dst, Point(hlines[0], hlines[1]), Point(hlines[2], hlines[3]), color, 3, LINE_AA);</div><div class="line">&#125;</div><div class="line">imshow(&quot;output img&quot;, dst);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>演示效果<br><img src="http://upload-images.jianshu.io/upload_images/4398977-3047b6b1499e4cfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="霍夫变换——圆检测"><a href="#霍夫变换——圆检测" class="headerlink" title="霍夫变换——圆检测"></a>霍夫变换——圆检测</h2><p>&emsp;&emsp;从平面坐标到极坐标转换三个参数C(x0,y0,r)其中x0与y0是圆心坐标<br>&emsp;&emsp;假设平面坐标的任意一个圆上的点，转换到极坐标中：C(x0,y0,r)处有最大值，霍夫变换正是利用这个原理实现圆的检测。</p><p>相关API：<br>cv::HoughCircles<br>&emsp;&emsp;因为霍夫圆检测对噪声比较敏感，所有先对图像做中值滤波。<br>&emsp;&emsp;基于效率考虑，opencv中实现的霍夫变换圆检测是基于图像梯度的实现，分为两步：</p><ol><li>检测边缘，发现可能的圆心</li><li>基于第一步的基础上从候选圆心开始计数最佳半径大小</li></ol><p>HoughCircles参数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;math.h&gt;</div><div class="line">using namespace cv;</div><div class="line">using namespace std;</div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/circle.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">namedWindow(&quot;output img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;input img&quot;, src);</div><div class="line">//中值滤波</div><div class="line">Mat output;</div><div class="line">medianBlur(src, output, 3);</div><div class="line">cvtColor(output, output, CV_BGR2GRAY);</div><div class="line">//霍夫圆检测</div><div class="line">vector&lt;Vec3f&gt; pcircles;</div><div class="line">HoughCircles(output, pcircles, CV_HOUGH_GRADIENT, 1, 10, 100, 30, 5, 50);</div><div class="line">src.copyTo(dst);</div><div class="line">for (size_t i = 0; i &lt; pcircles.size(); i++)</div><div class="line">&#123;</div><div class="line">Vec3f cc = pcircles[i];</div><div class="line">circle(dst, Point(cc[0], cc[1]), cc[2], Scalar(0, 0, 255), 2, LINE_AA);</div><div class="line">circle(dst, Point(cc[0], cc[1]), 2, Scalar(0, 255, 0), 2, LINE_AA);</div><div class="line">&#125;</div><div class="line">imshow(&quot;output img&quot;, dst);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>演示效果<br><img src="http://upload-images.jianshu.io/upload_images/4398977-e145efe71b57b399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>cc[0]cc[1]代表圆心的x和y的像素值，cc[2]代表半径</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;霍夫变换——直线&quot;&gt;&lt;a href=&quot;#霍夫变换——直线&quot; class=&quot;headerlink&quot; title=&quot;霍夫变换——直线&quot;&gt;&lt;/a&gt;霍夫变换——直线&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Hough Line Transform用来做直线检测，前提是已经做
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://samychen.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>轮廓发现</title>
    <link href="http://samychen.com/2018/02/20/%E8%BD%AE%E5%BB%93%E5%8F%91%E7%8E%B0/"/>
    <id>http://samychen.com/2018/02/20/轮廓发现/</id>
    <published>2018-02-20T06:34:37.000Z</published>
    <updated>2018-02-24T06:35:33.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="轮廓发现"><a href="#轮廓发现" class="headerlink" title="轮廓发现"></a>轮廓发现</h2><p>&emsp;&emsp;轮廓发现是基于图像边缘提取的基础寻找对象轮廓的方法，所以边缘提取的阈值选定会影响最终轮廓发现结果。<br>相关API：<br><code>findContours发现轮廓</code><br><code>drawContours绘制轮廓</code></p><p>操作步骤:</p><ul><li>输入图像转为灰度图像</li><li>使用Canny进行边缘提取，得到二值图像</li><li>使用findContours寻找轮廓</li><li>使用drawContours绘制轮廓<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;math.h&gt;</div><div class="line">using namespace cv;</div><div class="line">using namespace std;</div><div class="line">void contours(int, void *);</div><div class="line">int thread_value = 100;</div><div class="line">int thread_max = 255;</div><div class="line">RNG rng;</div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/circle.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">namedWindow(&quot;output img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line"></div><div class="line">cvtColor(src, src, CV_BGR2GRAY);</div><div class="line">imshow(&quot;input img&quot;, src);</div><div class="line">const char* title = &quot;thread value&quot;;</div><div class="line">createTrackbar(title, &quot;output img&quot;, &amp;thread_value, thread_max, contours);</div><div class="line">contours(0, 0);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">void contours(int, void *)</div><div class="line">&#123;</div><div class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</div><div class="line">vector&lt;Vec4i&gt; hierarchy;</div><div class="line">Canny(src, dst, thread_value, thread_value * 2, 3, false);</div><div class="line">findContours(dst, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));</div><div class="line">Mat drawImg = Mat::zeros(dst.size(), CV_8UC3);</div><div class="line">for (size_t i = 0; i &lt; contours.size(); i++)</div><div class="line">&#123;</div><div class="line">Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));</div><div class="line">drawContours(drawImg, contours, i, color, 2, LINE_8, hierarchy, 0, Point(0, 0));</div><div class="line">&#125;</div><div class="line">imshow(&quot;output img&quot;, drawImg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4398977-959dae316bdf9c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阈值100.png"><br><img src="http://upload-images.jianshu.io/upload_images/4398977-60f32f372de501c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阈值204.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;轮廓发现&quot;&gt;&lt;a href=&quot;#轮廓发现&quot; class=&quot;headerlink&quot; title=&quot;轮廓发现&quot;&gt;&lt;/a&gt;轮廓发现&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;轮廓发现是基于图像边缘提取的基础寻找对象轮廓的方法，所以边缘提取的阈值选定会影响最终轮廓发现结果。&lt;
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://samychen.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>边缘处理</title>
    <link href="http://samychen.com/2018/02/09/%E8%BE%B9%E7%BC%98%E5%A4%84%E7%90%86/"/>
    <id>http://samychen.com/2018/02/09/边缘处理/</id>
    <published>2018-02-09T06:18:57.000Z</published>
    <updated>2018-02-24T06:23:49.001Z</updated>
    
    <content type="html"><![CDATA[<h4 id="卷积边界问题"><a href="#卷积边界问题" class="headerlink" title="卷积边界问题"></a>卷积边界问题</h4><p>图像卷积时边界像素不能被卷积计算进去，因为边界处像素没有完全跟kernel重叠，当ksize等于3时，边缘有1个像素没有被处理，当ksize等于5时，边缘有2个没有被处理。</p><h4 id="处理边缘"><a href="#处理边缘" class="headerlink" title="处理边缘"></a>处理边缘</h4><p>&emsp;&emsp;在卷积开始前增加边缘像素，填充的像素为白色或黑色，这样确保图像的边缘被处理，在卷积计算之后去掉这些边缘，opencv默认处理的方法是<code>copyMakeBorder(src, dst, top, bottom, left, right, borderType, color)</code><br>&emsp;&emsp;其中默认的borderType是BORDER_DEFAULT，另外还有BORDER_WRAP，BORDER_CONSTANT，BORDER_REPLICATE三种类型</p><ul><li>BORDER_WRAP 用另外一边边缘像素来填充</li><li>BORDER_CONSTANT 用指定像素填充</li><li>BORDER_REPLICATE 用已知的边缘像素值填充</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4398977-c1fac43e1dcbc20f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BORDER_REPLICATE .png"><br><img src="http://upload-images.jianshu.io/upload_images/4398977-5c1ae449651f8d01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BORDER_WRAP .png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace cv;</div><div class="line">Mat src, dst;</div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/cat.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">namedWindow(&quot;output img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;input img&quot;, src);</div><div class="line">int top = (int)(0.05*src.rows);</div><div class="line">int bottom = (int)(0.05*src.rows);</div><div class="line">int left = (int)(0.05*src.cols);</div><div class="line">int right = (int)(0.05*src.cols);</div><div class="line">RNG rng(12345);</div><div class="line">int borderType = BORDER_DEFAULT;</div><div class="line">int c = 0;</div><div class="line">while (true) &#123;</div><div class="line">c = waitKey(500);</div><div class="line">//ESC</div><div class="line">if ((char)c == 27) &#123;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">if ((char)c == &apos;r&apos;) &#123;</div><div class="line">borderType = BORDER_REPLICATE;</div><div class="line">&#125;</div><div class="line">if ((char)c == &apos;c&apos;) &#123;</div><div class="line">borderType = BORDER_CONSTANT;</div><div class="line">&#125;</div><div class="line">if ((char)c == &apos;w&apos;) &#123;</div><div class="line">borderType = BORDER_WRAP;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">borderType = BORDER_DEFAULT;</div><div class="line">&#125;</div><div class="line">Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));</div><div class="line">copyMakeBorder(src, dst, top, bottom, left, right, borderType, color);</div><div class="line">imshow(&quot;final result&quot;, dst);</div><div class="line">&#125;</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p>Canny算法是很好的边缘检测算法，算法分5步</p><ul><li>高斯模糊</li><li>灰度转换</li><li>梯度计算</li><li>非最大信号抑制</li><li>高低阈值输出二值图像<br><code>Canny(src, edge_output, low_threshold, h_threshold , ksize, L2gradient)</code><h4 id="高低阈值输出二值图像"><a href="#高低阈值输出二值图像" class="headerlink" title="高低阈值输出二值图像"></a>高低阈值输出二值图像</h4></li></ul><p>高低阈值分别为T2，T1，凡是高于T2的保留，低于T1的舍弃，从逃狱T2的出发，凡是大于T1而且直接连接的都保留，最后得到二值图像。<br>推荐T1和T2的关系是T2：T1 = 2:1或3:1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace cv;</div><div class="line">Mat src, dst, gray;</div><div class="line">int g_value = 60;</div><div class="line">int maxvalue = 255;</div><div class="line">void cannry_callback(int, void *);</div><div class="line"></div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/cat.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">namedWindow(&quot;output img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;input img&quot;, src);</div><div class="line">cvtColor(src, gray, CV_BGR2GRAY);</div><div class="line">createTrackbar(&quot;threshold value:&quot;, &quot;output img&quot;, &amp;g_value, maxvalue, cannry_callback);</div><div class="line">cannry_callback(0, 0);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">void cannry_callback(int, void *) &#123;</div><div class="line">Mat edge_output;</div><div class="line">blur(gray, gray, Size(3, 3), Point(-1, -1), BORDER_DEFAULT);</div><div class="line">Canny(gray, edge_output, g_value, g_value * 2, 3, false);</div><div class="line">imshow(&quot;output img&quot;, ~edge_output);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果演示<br><img src="http://upload-images.jianshu.io/upload_images/4398977-404671bda2f9a019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;卷积边界问题&quot;&gt;&lt;a href=&quot;#卷积边界问题&quot; class=&quot;headerlink&quot; title=&quot;卷积边界问题&quot;&gt;&lt;/a&gt;卷积边界问题&lt;/h4&gt;&lt;p&gt;图像卷积时边界像素不能被卷积计算进去，因为边界处像素没有完全跟kernel重叠，当ksize等于3时，边缘有
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://samychen.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>图像金字塔——降采样与上采样</title>
    <link href="http://samychen.com/2018/02/07/%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94%E2%80%94%E2%80%94%E9%99%8D%E9%87%87%E6%A0%B7%E4%B8%8E%E4%B8%8A%E9%87%87%E6%A0%B7/"/>
    <id>http://samychen.com/2018/02/07/图像金字塔——降采样与上采样/</id>
    <published>2018-02-07T06:18:13.000Z</published>
    <updated>2018-02-24T06:23:43.356Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4398977-5a5b19bdf7bf168c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>往下和往上，图像的宽高是原来的一倍和一半</p><h4 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h4><p>&emsp;&emsp;我们在图像处理中常常会调整图像大小，最常见的就是放大和缩小操作。一个图像金字塔是一系列图像的组合，最底下图像尺寸最大，最顶端图像尺寸最小，从空间上往下看就像一个金字塔。<br>&emsp;&emsp;图像处理当中最常见的就是利用图像金字塔产生一系列不同分辨率图像，然后在不同尺度空间去寻找图像对应的特征，因为我们输入的图像我们不知道是什么样子，而图像金字塔可以保证图像特征存在。</p><h4 id="常见opencv金字塔"><a href="#常见opencv金字塔" class="headerlink" title="常见opencv金字塔"></a>常见opencv金字塔</h4><ul><li>高斯金字塔——用来对图像进行降采样</li><li>拉普拉斯金字塔——用来重建一张图片，根据他的上层图像降采样图片</li></ul><h4 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h4><p>&emsp;&emsp;从底像上，逐层降采样得到。必须是逐层采用，不能隔层采用1/4。<br>降采样之后图像大小是原来的1/2 x 1/2，就是对原图像删除偶数行与列。</p><p>高斯金字塔生成过程分为两步：</p><ol><li>对当前层进行高斯模糊</li><li>删除当前层的行与列</li></ol><h4 id="高斯不同DOG"><a href="#高斯不同DOG" class="headerlink" title="高斯不同DOG"></a>高斯不同DOG</h4><p>&emsp;&emsp;就是把一张图像在不同参数下做高斯模糊之后的结果相减，得到输出图像。<br>&emsp;&emsp;高斯不同是图像的内在特征，在灰度图像增强，角点检测中经常用到。</p><ul><li>上采样 <code>pyrUp(Mat src,Mat dst,Size(src.cols*2,src.rows*2))</code></li><li>降采样 <code>pyrDown(Mat src,Mat dst,Size(src.cols/2,src.rows/2))</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace cv;</div><div class="line">Mat src, dst;</div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/cat.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">namedWindow(&quot;output img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;input img&quot;, src);</div><div class="line">//上采样</div><div class="line">pyrUp(src, dst, Size(src.cols * 2, src.rows * 2));</div><div class="line">imshow(&quot;上采样&quot;, dst);</div><div class="line">//降采样</div><div class="line">Mat dst_;</div><div class="line">pyrDown(src, dst_, Size(src.cols / 2, src.rows / 2));</div><div class="line">imshow(&quot;降采样&quot;, dst_);</div><div class="line">//DOG</div><div class="line">Mat gray_src, g1, g2, catImg;</div><div class="line">cvtColor(src, gray_src, CV_BGR2GRAY);</div><div class="line">GaussianBlur(gray_src, g1, Size(3, 3), 0, 0);</div><div class="line">GaussianBlur(g1, g2, Size(3, 3), 0, 0);</div><div class="line">subtract(g1, g2, catImg, Mat());</div><div class="line">normalize(catImg, catImg, 255, 0, NORM_MINMAX);</div><div class="line">imshow(&quot;DOG&quot;, catImg);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>输出结果演示<br><img src="http://upload-images.jianshu.io/upload_images/4398977-49b4a74b81ae066b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>从上面可以看到上采样和降采样分别提高和降低了图像的分辨率，高斯不同处理结果显示了图像的内在特征。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4398977-5a5b19bdf7bf168c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://samychen.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>形态学操作</title>
    <link href="http://samychen.com/2018/02/07/%E5%BD%A2%E6%80%81%E5%AD%A6%E6%93%8D%E4%BD%9C/"/>
    <id>http://samychen.com/2018/02/07/形态学操作/</id>
    <published>2018-02-07T06:17:57.000Z</published>
    <updated>2018-02-24T06:23:37.426Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;图像形态学操作是基于形状的一系列图像处理操作的合集，主要是基于集合论基础上的形态学数学。主要有四个操作：膨胀，腐蚀，开，闭。</p><h4 id="形态学操作——膨胀"><a href="#形态学操作——膨胀" class="headerlink" title="形态学操作——膨胀"></a>形态学操作——膨胀</h4><p>&emsp;&emsp;膨胀与腐蚀跟卷积操作类似，假设有图像A和结构元素B，B在A上面移动，其中B定义其中心是锚点，计算B覆盖下的A的最大像素值用来替代锚点的像素，其中B作为结构元素可以是任意形状。</p><h4 id="形态学操作——腐蚀"><a href="#形态学操作——腐蚀" class="headerlink" title="形态学操作——腐蚀"></a>形态学操作——腐蚀</h4><p>&emsp;&emsp;腐蚀过程和膨胀过程类似，唯一不同的是以最小像素值替代锚点像素。<br><img src="http://upload-images.jianshu.io/upload_images/4398977-7aa69130561e7542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="膨胀与腐蚀.png"></p><ul><li>获取结构元素 <code>getStructuringElement(int shape,Size ksize,Point anchor)</code> 其中形状shape可以是MORPH_RECT,MORPH_CROSS,MORPH_ELLIPSE，锚点默认是Point(-1,-1)，意思是中心元素。</li><li>膨胀 <code>dilate(src,dst,kernel)</code></li><li>腐蚀 <code>erode(src,dst,kernel)</code><br><img src="http://upload-images.jianshu.io/upload_images/4398977-8a9d2f32378cad1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>&emsp;&emsp;opencv提供了状态条TrackBar来动态调整结构元素大小。<br>createTrackBar(const String&amp; trackbarname,const String windowname,int <em> value,int count,Trackbarcallback func,void </em> userdata=0) 回调函数如果为NULL，就只会update，不会调用callback函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace cv;</div><div class="line">int elementsize = 3;</div><div class="line">int maxsize = 21;</div><div class="line">Mat src, dst, dst_;</div><div class="line">void callback(int, void *);</div><div class="line"></div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">int ksize = 0;</div><div class="line">src = imread(&quot;F:/cat.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;show img&quot;, src);</div><div class="line">char TrackbarName[50];</div><div class="line">sprintf_s(TrackbarName, &quot;Alpha x %d&quot;, elementsize);</div><div class="line">namedWindow(&quot;output result&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">createTrackbar(TrackbarName, &quot;output result&quot;, &amp;elementsize, maxsize, callback);</div><div class="line">callback(0, 0);</div><div class="line">//Mat kernel = getStructuringElement(MORPH_RECT, Size(5, 5), Point(-1, -1));</div><div class="line">//dilate(src, dst, kernel);</div><div class="line">//erode(src, dst_, kernel);</div><div class="line">//namedWindow(&quot;dilate result&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">//namedWindow(&quot;erode result&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">//imshow(&quot;dilate&quot;, dst);</div><div class="line">//imshow(&quot;erode&quot;, dst_);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void callback(int, void *)</div><div class="line">&#123;</div><div class="line">int s = elementsize * 2 + 1;</div><div class="line">Mat sturctEle = getStructuringElement(MORPH_RECT, Size(s, s), Point(-1, -1));</div><div class="line">dilate(src, dst, sturctEle);</div><div class="line">//erode(src, dst_, sturctEle);</div><div class="line">imshow(&quot;dilate&quot;, dst);</div><div class="line">//imshow(&quot;erode&quot;, dst_);</div><div class="line">return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果演示<br><img src="http://upload-images.jianshu.io/upload_images/4398977-474ad50164475ec3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="形态学操作——开操作"><a href="#形态学操作——开操作" class="headerlink" title="形态学操作——开操作"></a>形态学操作——开操作</h4><p>&emsp;&emsp;先腐蚀后膨胀，可以去掉小的对象<br><img src="http://upload-images.jianshu.io/upload_images/4398977-0b01f36f97a810ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="形态学操作——闭操作"><a href="#形态学操作——闭操作" class="headerlink" title="形态学操作——闭操作"></a>形态学操作——闭操作</h4><p>&emsp;&emsp;先膨胀后腐蚀，可以填充小对象<br><img src="http://upload-images.jianshu.io/upload_images/4398977-0744fa33888a4948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h4><p>&emsp;&emsp;膨胀减去腐蚀<br><img src="http://upload-images.jianshu.io/upload_images/4398977-75b873b27d371ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="形态学操作——顶帽"><a href="#形态学操作——顶帽" class="headerlink" title="形态学操作——顶帽"></a>形态学操作——顶帽</h4><p>&emsp;&emsp;顶帽是原图像与开操作图像之间的差值图像<br><img src="http://upload-images.jianshu.io/upload_images/4398977-f00d9cf541840c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="形态学操作——黑帽"><a href="#形态学操作——黑帽" class="headerlink" title="形态学操作——黑帽"></a>形态学操作——黑帽</h4><p>&emsp;&emsp;黑帽是闭操作图像与原图像之间的差值图像<br><img src="http://upload-images.jianshu.io/upload_images/4398977-8a3b4195fcd51dfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace cv;</div><div class="line">Mat src, dst;</div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/black_hole.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;show img&quot;, src);</div><div class="line">Mat kernel = getStructuringElement(MORPH_RECT, Size(15, 15), Point(-1, -1));</div><div class="line">//morphologyEx(src, dst, CV_MOP_OPEN, kernel);</div><div class="line">//morphologyEx(src, dst, CV_MOP_CLOSE, kernel);</div><div class="line">//morphologyEx(src, dst, CV_MOP_GRADIENT, kernel);</div><div class="line">//morphologyEx(src, dst, CV_MOP_TOPHAT, kernel);</div><div class="line">morphologyEx(src, dst, CV_MOP_BLACKHAT, kernel);</div><div class="line"></div><div class="line">namedWindow(&quot;output result&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;erode&quot;, dst);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>morphologyEx(Mat src,Mat dst,int opt,kernel)<br>其中opt是形态学操作，可以为CV_MOP_OPEN,CV_MOP_CLOSE,CV_MOP_GRADIENT,CV_MOP_TOPHAT,CV_MOP_BLACKHAT</p><h3 id="形态学应用"><a href="#形态学应用" class="headerlink" title="形态学应用"></a>形态学应用</h3><h4 id="提取水平和垂直线"><a href="#提取水平和垂直线" class="headerlink" title="提取水平和垂直线"></a>提取水平和垂直线</h4><p>&emsp;&emsp;可以通过自定义结构元素实现结构元素对输入图像一些对象敏感，一些对象不敏感，这样就会让敏感对象改变而不敏感对象保留输出。通过使用膨胀与腐蚀，使用不同的结构元素来得到不同的结果。</p><p>操作步骤：</p><ul><li>输入图像转换为灰度图像</li><li>灰度图像转换为二值图像</li><li>定义结构元素</li><li>开操作提取水平与垂直线<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace cv;</div><div class="line">Mat src, dst;</div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/line.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">Mat gray;</div><div class="line">cvtColor(src, gray, CV_BGR2GRAY);</div><div class="line">imshow(&quot;gray img&quot;, gray);</div><div class="line">Mat binImg;</div><div class="line">adaptiveThreshold(~gray, binImg, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 15, -2);</div><div class="line">imshow(&quot;binary img&quot;, binImg);</div><div class="line"></div><div class="line">Mat hline = getStructuringElement(MORPH_RECT, Size(src.cols/16, 1), Point(-1, -1));</div><div class="line">Mat vline = getStructuringElement(MORPH_RECT, Size(1, src.rows/16), Point(-1, -1));</div><div class="line">Mat temp;</div><div class="line">//erode(binImg, temp, hline);</div><div class="line">//dilate(temp, dst, hline);</div><div class="line">erode(binImg, temp, vline);</div><div class="line">dilate(temp, dst, vline);</div><div class="line">bitwise_not(dst, dst);</div><div class="line">imshow(&quot;final result&quot;, dst);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4398977-4c4afd0990074f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水平线.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-a402aa3d6abcbd6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="垂直线.png"></p><p>扩展：去除打码平台无用的线条</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-750f5d6097a5b58f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace cv;</div><div class="line">Mat src, dst;</div><div class="line">int main(int argc, int ** argv)</div><div class="line">&#123;</div><div class="line">src = imread(&quot;F:/number.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">Mat gray;</div><div class="line">cvtColor(src, gray, CV_BGR2GRAY);</div><div class="line">imshow(&quot;gray img&quot;, gray);</div><div class="line">Mat binImg;</div><div class="line">adaptiveThreshold(~gray, binImg, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 15, -2);</div><div class="line">imshow(&quot;binary img&quot;, binImg);</div><div class="line">Mat hline = getStructuringElement(MORPH_RECT, Size(src.cols/16, 1), Point(-1, -1));</div><div class="line">Mat vline = getStructuringElement(MORPH_RECT, Size(1, src.rows/16), Point(-1, -1));</div><div class="line">Mat kernel = getStructuringElement(MORPH_RECT, Size(3, 3), Point(-1, -1));</div><div class="line">Mat temp;</div><div class="line"></div><div class="line">erode(binImg, temp, kernel);</div><div class="line">dilate(temp, dst, kernel);</div><div class="line">bitwise_not(dst, dst);</div><div class="line">imshow(&quot;final result&quot;, dst);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;图像形态学操作是基于形状的一系列图像处理操作的合集，主要是基于集合论基础上的形态学数学。主要有四个操作：膨胀，腐蚀，开，闭。&lt;/p&gt;
&lt;h4 id=&quot;形态学操作——膨胀&quot;&gt;&lt;a href=&quot;#形态学操作——膨胀&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://samychen.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>模糊图像——线性滤波</title>
    <link href="http://samychen.com/2018/02/04/%E6%A8%A1%E7%B3%8A%E5%9B%BE%E5%83%8F%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/"/>
    <id>http://samychen.com/2018/02/04/模糊图像——线性滤波/</id>
    <published>2018-02-04T06:17:39.000Z</published>
    <updated>2018-02-24T06:23:24.508Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;模糊图像是opencv常见的操作，使用模糊操作的原因是为了给图像预处理时降低噪声影响，Smooth和Blur是opencv图像模糊的API，其背后的原理其实是数学的卷积操作，而卷积算子计算通常是线性计算，所以也可以称为线性滤波。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-ca27910845d5e18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卷积.png"></p><p>&emsp;&emsp;卷积是图像处理的一个操作，是kernel在图像上的每个像素上的操作。kernel本质是一个固定大小的矩阵数组，中心点称为锚点（anchor point）。<br>&emsp;&emsp;把kernel放到像素数组上，求锚点周围覆盖的像素乘积之和（包括锚点），用来替换锚点覆盖下像素点值称为卷积处理。</p><p>&emsp;&emsp;上面的卷积过程是一个3x3的窗口从左到右，从上到下平移过程。黄色的每个像素点之和取平均值赋值给中心的红色点作为卷积处理后的像素值。这是一种均值滤波。<br>opencv提供了均值滤波（模糊）的API <code>blur(Mat src,Mat dst,Size(xradius,yradius),Point(-1,-1))</code><br>&emsp;&emsp;当然还有其他模糊的方式，如高斯模糊 <code>GaussianBlur(Mat src,Mat dst,Size(x,y),sigmax,sigmay)</code> 其中Size(x,y)的x和y必须为正基数，且一般x=y</p><p>&emsp;&emsp;不同卷积算子可以看做不同的滤波结果：<br><img src="http://upload-images.jianshu.io/upload_images/4398977-ea34e661d7992c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卷积.png"></p><h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>中值滤波的应用medianBlur(Mat src,Mat dst,ksize)</p><ul><li>统计排序滤波器</li><li>中值滤波对椒盐噪声有很好的抑制作用</li></ul><p>&emsp;&emsp;椒盐噪声一般是作为最值对信号产生影响，中值滤波对最值有很好的抑制作用。<br>那么是否均值滤波能做为生产环境的滤波处理，均值滤波有什么缺陷呢？</p><p>均值模糊无法克服边缘信息丢失缺陷，因为均值滤波是基于平均权重处理。而高斯模糊部分克服了改缺陷，但是无法完全避免，因为高斯模糊没有考虑像素值不同的影响。</p><h4 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h4><p>&emsp;&emsp;双边滤波也可以称为高斯双边模糊，是边缘保留的滤波方法，避免了边缘信息的丢失，保留了图像轮廓不变。</p><p>&emsp;&emsp;考虑像素值的处理，如果有1和255两个像素值，那么在各自的像素值处离的比较远，可以不做处理</p><p>bilateralFilter(Mat src,Mat dst,d=15,150,3) </p><ul><li>15表示计算的半径，半径之内像素全部纳入计算，如果是-1，那么根据sigma space参数取值</li><li>150 sigma color 决定多少差值之内的像素会被计算</li><li>3 sigma space 如果d的值大于0则声明无效，否则根据它来计算d值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">using namespace cv;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">Mat src, dst;</div><div class="line">src = imread(&quot;F:/cat.jpg&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return - 1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;show img&quot;, src);</div><div class="line">dst = Mat::zeros(src.size(),src.type());</div><div class="line">//medianBlur(src, dst, 3);</div><div class="line">bilateralFilter(src, dst, 15, 100, 5);</div><div class="line">namedWindow(&quot;bilateralFilter&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;bilateralFilter result&quot;, dst);</div><div class="line"></div><div class="line">//Mat bgblur(src.size(), src.type());</div><div class="line">//GaussianBlur(src, bgblur, Size(15, 15), 3, 3);</div><div class="line">//imshow(&quot;GaussianBlur result&quot;, bgblur);</div><div class="line">//可以在双边滤波后做对比度增强</div><div class="line">Mat resultImg(src.size(), src.type());</div><div class="line">Mat kernel = (Mat_&lt;int&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0);</div><div class="line">filter2D(src, resultImg, -1, kernel, Point(-1, -1), 0);</div><div class="line">imshow(&quot;result&quot;, resultImg);</div><div class="line">waitKey(0);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果演示<br><img src="http://upload-images.jianshu.io/upload_images/4398977-7850d49ec36abfe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="自定义线性滤波"><a href="#自定义线性滤波" class="headerlink" title="自定义线性滤波"></a>自定义线性滤波</h4><p>&emsp;&emsp;线性滤波常用的算子有Sobel算子，Laplance算子，当然我们可以自己定义算子然后通过opencv提供的filter2D来实现自己的滤波器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">using namespace cv;</div><div class="line">int main(int argc,int ** argv)</div><div class="line">&#123;</div><div class="line">Mat src, dst;</div><div class="line">int ksize = 0;</div><div class="line">src = imread(&quot;F:/cat.png&quot;);</div><div class="line">if (!src.data) &#123;</div><div class="line">printf(&quot;无法加载图片\n&quot;);</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">namedWindow(&quot;input img&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;show img&quot;, src);</div><div class="line">dst = Mat::zeros(src.size(), src.type());</div><div class="line">namedWindow(&quot;bilateralFilter&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">//Robert X方向</div><div class="line">//Mat kernelx = (Mat_&lt;int&gt;(2, 2) &lt;&lt; 1, 0, 0, -1);</div><div class="line">//filter2D(src, dst, -1, kernelx, Point(-1, -1), 0.0);</div><div class="line">//Robert Y方向</div><div class="line">//Mat result = Mat::zeros(src.size(), src.type());</div><div class="line">//Mat kernely = (Mat_&lt;int&gt;(2, 2) &lt;&lt; 0, 1, -1, 0);</div><div class="line">//filter2D(src, result, -1, kernely, Point(-1, -1), 0.0);</div><div class="line"></div><div class="line">//Sobel X方向</div><div class="line">Mat kernelx = (Mat_&lt;int&gt;(3, 3) &lt;&lt; -1, 0, 1, -2, 0, 2, -1, 0, 1);</div><div class="line">filter2D(src, dst, -1, kernelx, Point(-1, -1), 0.0);</div><div class="line">//Sobel Y方向</div><div class="line">Mat result = Mat::zeros(src.size(), src.type());</div><div class="line">Mat kernely = (Mat_&lt;int&gt;(3, 3) &lt;&lt; -1, -2, -1, 0, 0, 0, 1, 2, 1);</div><div class="line">filter2D(src, result, -1, kernely, Point(-1, -1), 0.0);</div><div class="line">//拉普拉斯算子</div><div class="line">Mat result_ = Mat::zeros(src.size(), src.type());</div><div class="line">Mat kernel_ = (Mat_&lt;int&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 4, -1, 0, -1, 0);</div><div class="line">filter2D(src, result_, -1, kernel_, Point(-1, -1), 0.0);</div><div class="line">imshow(&quot;Sobel X result&quot;, dst);</div><div class="line">imshow(&quot;Sobel Y result&quot;, result);</div><div class="line">imshow(&quot;laplance result&quot;, result_);</div><div class="line">waitKey(0);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果演示<br><img src="http://upload-images.jianshu.io/upload_images/4398977-3fdac31efef3a3ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看出，针对不同卷积算子，得到不同的结果，其中沿X方向的算子和沿Y方向的算子得到的结果都只有部分原图像的特征，使用高斯算子得到的特征比较符合原图像的要求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;模糊图像是opencv常见的操作，使用模糊操作的原因是为了给图像预处理时降低噪声影响，Smooth和Blur是opencv图像模糊的API，其背后的原理其实是数学的卷积操作，而卷积算子计算通常是线性计算，所以也可以称为线性滤波。&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://samychen.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>Mat基本操作</title>
    <link href="http://samychen.com/2018/02/01/Mat%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://samychen.com/2018/02/01/Mat基本操作/</id>
    <published>2018-02-01T06:17:12.000Z</published>
    <updated>2018-02-24T06:22:54.692Z</updated>
    
    <content type="html"><![CDATA[<h4 id="矩阵基本操作"><a href="#矩阵基本操作" class="headerlink" title="矩阵基本操作"></a>矩阵基本操作</h4><p>opencv最基本的结构体是Mat，opencv提供了一系列Mat基本操作<br>加载图片cv::imgread<br>修改图片(色彩变化)cv::cvtColor 第三个参数表示从源色彩空间转换到目的色彩空间<br>保存图片cv::imgwrite<br>显示图像cv::namedWindows cv::imshow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">using namespace cv;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">Mat src = imread(&quot;F:/build_android.png&quot;,IMREAD_GRAYSCALE);</div><div class="line">Mat output_img = Mat::zeros(src.size(),src.type());</div><div class="line">namedWindow(&quot;test opencv&quot;, CV_WINDOW_AUTOSIZE);//CV_WINDOW_AUTOSIZE不允许任务修改窗口大小</div><div class="line">imshow(&quot;show img&quot;, src);</div><div class="line"></div><div class="line">namedWindow(&quot;test opencv2&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line"></div><div class="line">cvtColor(src, output_img, COLOR_BGR2HLS);</div><div class="line">imshow(&quot;show img2&quot;, output_img);</div><div class="line"></div><div class="line">int cols = src.cols*src.channels();//图像宽度等于图像的cols乘以图像的通道数</div><div class="line">int rows = src.rows;//图像高度等于图像的rows</div><div class="line">for (int row = 1; row &lt; rows-1; row++) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//imwrite(&quot;F:/hlstest.png&quot;,output_img);</div><div class="line">waitKey(0);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="获取图像像素指针"><a href="#获取图像像素指针" class="headerlink" title="获取图像像素指针"></a>获取图像像素指针</h4><p>CV_Assert(myImage.depth()==CV_8U)<br>Mat.ptr<uchar>(int i=0)获取像素矩阵的指针，索引i表示第几行，从0开始计数<br>获取当前行指针const uchar* current = myImage.ptr<uchar>(row);<br>获取当前像素点P(row,col)的像素值p(row,col) = current[col]</uchar></uchar></p><h4 id="像素范围处理saturate-cast"><a href="#像素范围处理saturate-cast" class="headerlink" title="像素范围处理saturate_cast"></a>像素范围处理saturate_cast<uchar></uchar></h4><p>saturate_cast<uchar>(-100)，返回0<br>saturate_cast<uchar>(2888)，返回255<br>小于0返回0，大于255返回255 这个函数确保像素值在0到255之间</uchar></uchar></p><h4 id="矩阵掩膜操作-对比度提高，立体感增强"><a href="#矩阵掩膜操作-对比度提高，立体感增强" class="headerlink" title="矩阵掩膜操作(对比度提高，立体感增强)"></a>矩阵掩膜操作(对比度提高，立体感增强)</h4><p>数字图像处理中,掩模为二维矩阵数组,有时也用多值图像。数字图像处理中,图像掩模主要用于：</p><ul><li>提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。</li><li>屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。</li><li>结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。</li><li>特殊形状图像的制作。</li></ul><p>掩膜操作实现图像对比度调整，根据掩膜来重新计算每个像素的像素值，掩膜(mask)也被称为 kernel。<br>通过掩膜操作实现图像对比度提高。<br><img src="http://upload-images.jianshu.io/upload_images/4398977-222e88ac7a2228da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mask.png"></p><p>上面矩阵像素操作可以用下面公式来表示<br><code>I(i,j) = 5*I(i,j) - [I(i-1,j) + I(i+1,j) + I(i,j-1) + I(i,j+1)]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;math.h&gt;</div><div class="line"></div><div class="line">using namespace cv;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    Mat src, dst;</div><div class="line">    //加载图像</div><div class="line">    src = imread(&quot;F:/build_android.jpg&quot;);</div><div class="line">    </div><div class="line">    if (!src.data) &#123;</div><div class="line">        printf(&quot;could not load image\n&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    //显示</div><div class="line">    namedWindow(&quot;input Image&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">    imshow(&quot;input Image&quot;, src);</div><div class="line"></div><div class="line">     //掩膜操作</div><div class="line">     int cols = (src.cols-1) * src.channels();//图像宽度等于图像的cols乘以图像的通道数</div><div class="line">     int offsetx = src.channels();</div><div class="line">     int rows = src.rows;//图像高度等于图像的rows</div><div class="line">     dst = Mat::zeros(src.size(), src.type());</div><div class="line"></div><div class="line">     for (int row = 1; row &lt; rows-1; row++) &#123;</div><div class="line">       const uchar *previous = src.ptr&lt;uchar&gt;(row-1);</div><div class="line">       const uchar *current = src.ptr&lt;uchar&gt;(row);</div><div class="line">       const uchar *next = src.ptr&lt;uchar&gt;(row+1);</div><div class="line">       uchar *output = dst.ptr&lt;uchar&gt;(row);</div><div class="line">       for (int col = offsetx; col &lt; cols; col++) &#123;</div><div class="line">         output[col] = saturate_cast&lt;uchar&gt;(5*current[col] - (current[col-offsetx] + current[col+offsetx] + previous[col] + next[col]));</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    //显示</div><div class="line">    namedWindow(&quot;contrast Image&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">    imshow(&quot;contrast Image&quot;, dst);</div><div class="line">    </div><div class="line">    waitKey(0);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么每次处理图片我们都需要把上面一长串代码拷贝到工程里面去吗，上述代码太多，其实opencv已经实现了上面功能。<br>filter2D函数可以实现上面效果，在第四个参数添加掩膜矩阵就可以实现相同效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//定义掩膜</div><div class="line">Mat kern = (Mat_&lt;char&gt;(3,3) &lt;&lt;  0, -1,  0,</div><div class="line">                               -1,  5, -1,</div><div class="line">                                0, -1,  0);</div></pre></td></tr></table></figure></p><p>上面代码可以用下面代码替代<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">double t = getTickCount();  //获得当前时间</div><div class="line">Mat kernel = (Mat_&lt;char&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1 ,0);</div><div class="line">//src.depth() 表示与原图深度一样，-1也表示一样</div><div class="line">filter2D(src, dst, src.depth(), kernel);</div><div class="line">double time = (getTickCount() - t) / getTickFrequency();</div><div class="line">printf(&quot;time consume %.5f&quot;, time);</div><div class="line">namedWindow(&quot;contrast Image&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">imshow(&quot;contrast Image&quot;, dst);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;矩阵基本操作&quot;&gt;&lt;a href=&quot;#矩阵基本操作&quot; class=&quot;headerlink&quot; title=&quot;矩阵基本操作&quot;&gt;&lt;/a&gt;矩阵基本操作&lt;/h4&gt;&lt;p&gt;opencv最基本的结构体是Mat，opencv提供了一系列Mat基本操作&lt;br&gt;加载图片cv::imgre
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://samychen.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建crtmp服务器</title>
    <link href="http://samychen.com/2017/09/23/%E6%90%AD%E5%BB%BAcrtmp%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://samychen.com/2017/09/23/搭建crtmp服务器/</id>
    <published>2017-09-23T08:15:00.000Z</published>
    <updated>2018-01-25T12:18:12.486Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;crtmpserver开源,在windows平台以及linux平台下都可以运行,但他是一个单线程的select模型，不能满足高并发的性能要求，想要对其进行并发结构修改，在实际项目对接情况下又有跟大的困难，并且实际情况下的技术瓶颈是出现在带宽上，想要用crtmpserver其实不是最好的选择。</p><p>如何<br>crtmp server搭建简单点播服务器步骤：</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-df41f8e629df8c4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点播服务器.png"></p><p>想要测试点播服务器是否搭建好，播放器可以采用potplayer或者VLC就可以了。</p><p>&emsp;&emsp;crtmpserver也可以搭建直播服务，初学者可以尝试使用crtmpserver搭建，也可以用red5搭建，但是想要实现更多的功能，推荐还是使用nginx和srs服务器，其中srs只支持linux系统，国内的点播服务器基本上也是使用这两种来搭建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;crtmpserver开源,在windows平台以及linux平台下都可以运行,但他是一个单线程的select模型，不能满足高并发的性能要求，想要对其进行并发结构修改，在实际项目对接情况下又有跟大的困难，并且实际情况下的技术瓶颈是出现在带宽上，想要用
      
    
    </summary>
    
      <category term="安卓直播开发" scheme="http://samychen.com/categories/%E5%AE%89%E5%8D%93%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>FFmpeg实战 保存网络流</title>
    <link href="http://samychen.com/2017/09/03/FFmpeg%E5%AE%9E%E6%88%98-%E4%BF%9D%E5%AD%98%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://samychen.com/2017/09/03/FFmpeg实战-保存网络流/</id>
    <published>2017-09-03T10:15:00.000Z</published>
    <updated>2018-01-25T12:17:26.860Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天我们开始正式进入FFmpeg的篇章，FFmpeg作为著名的开源框架，可以生成用于处理多媒体框架的库和程序，是音视频界内的圣经，市面上直播开发99%都是基于FFmpeg来开发的，这足以证明FFmpeg的强大。关于FFmpeg的源码和官方文档可以去<a href="http://ffmpeg.org/doxygen/trunk/index.html" target="_blank" rel="external">FFmpeg</a>下载源码和编译好的库。<br>&emsp;&emsp;闲话不多说，下面就开始今天的主要内容，FFmpeg保存网络流到本地<br>&emsp;&emsp;直播不像点播，当我们看到想看的内容时，我们不能倒退回去，但是我们可以保存直播流为本地文件，这样我们想看随时都可以。</p><p>保存网络流的流程主要有以下步骤：<br>               &emsp;&emsp; 第一步：注册所有的组件（编解码、滤镜特效处理库、封装格式处理库、工具库、音频采样数据格式转换库、视频像素数据格式转换等等…）<br>        &emsp;&emsp;第二步：获取视频流的封装信息，查找视频和音频流的位置<br>        &emsp;&emsp;第三步：查找视频和音频解码器id，根据解码器id打开解码器<br>        &emsp;&emsp;第四步：创建输出流并拷贝流上下文信息<br>        &emsp;&emsp;第五步：循环读取网络流，解码packet并写入本地<br>        &emsp;&emsp;第六步：关闭解码器释放内存</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &quot;pch.h&quot;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;memory&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">AVFormatContext *inputContext = nullptr;</div><div class="line">AVFormatContext * outputContext;</div><div class="line">int64_t lastReadPacktTime ;</div><div class="line"></div><div class="line">static int interrupt_cb(void *ctx)</div><div class="line">&#123;</div><div class="line">int  timeout  = 3;</div><div class="line">if(av_gettime() - lastReadPacktTime &gt; timeout *1000 *1000)</div><div class="line">&#123;</div><div class="line">return -1;</div><div class="line">&#125;</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">int OpenInput(string inputUrl)</div><div class="line">&#123;</div><div class="line">inputContext = avformat_alloc_context();</div><div class="line">lastReadPacktTime = av_gettime();</div><div class="line">inputContext-&gt;interrupt_callback.callback = interrupt_cb;</div><div class="line">int ret = avformat_open_input(&amp;inputContext, inputUrl.c_str(), nullptr,nullptr);</div><div class="line">if(ret &lt; 0)</div><div class="line">&#123;</div><div class="line">av_log(NULL, AV_LOG_ERROR, &quot;Input file open input failed\n&quot;);</div><div class="line">return  ret;</div><div class="line">&#125;</div><div class="line">ret = avformat_find_stream_info(inputContext,nullptr);</div><div class="line">if(ret &lt; 0)</div><div class="line">&#123;</div><div class="line">av_log(NULL, AV_LOG_ERROR, &quot;Find input file stream inform failed\n&quot;);</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">av_log(NULL, AV_LOG_FATAL, &quot;Open input file  %s success\n&quot;,inputUrl.c_str());</div><div class="line">&#125;</div><div class="line">return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">shared_ptr&lt;AVPacket&gt; ReadPacketFromSource()</div><div class="line">&#123;</div><div class="line">shared_ptr&lt;AVPacket&gt; packet(static_cast&lt;AVPacket*&gt;(av_malloc(sizeof(AVPacket))), [&amp;](AVPacket *p) &#123; av_packet_free(&amp;p); av_freep(&amp;p);&#125;);</div><div class="line">av_init_packet(packet.get());</div><div class="line">lastReadPacktTime = av_gettime();</div><div class="line">int ret = av_read_frame(inputContext, packet.get());</div><div class="line">if(ret &gt;= 0)</div><div class="line">&#123;</div><div class="line">return packet;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">return nullptr;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">void av_packet_rescale_ts(AVPacket *pkt, AVRational src_tb, AVRational dst_tb)</div><div class="line">&#123;</div><div class="line">if (pkt-&gt;pts != AV_NOPTS_VALUE)</div><div class="line">pkt-&gt;pts = av_rescale_q(pkt-&gt;pts, src_tb, dst_tb);</div><div class="line">if (pkt-&gt;dts != AV_NOPTS_VALUE)</div><div class="line">pkt-&gt;dts = av_rescale_q(pkt-&gt;dts, src_tb, dst_tb);</div><div class="line">if (pkt-&gt;duration &gt; 0)</div><div class="line">pkt-&gt;duration = av_rescale_q(pkt-&gt;duration, src_tb, dst_tb);</div><div class="line">&#125;</div><div class="line">int WritePacket(shared_ptr&lt;AVPacket&gt; packet)</div><div class="line">&#123;</div><div class="line">auto inputStream = inputContext-&gt;streams[packet-&gt;stream_index];</div><div class="line">auto outputStream = outputContext-&gt;streams[packet-&gt;stream_index];</div><div class="line">av_packet_rescale_ts(packet.get(),inputStream-&gt;time_base,outputStream-&gt;time_base);//时间戳转换，输入上下文与输出上下文时间基准不同</div><div class="line">//也可以用av_write_frame</div><div class="line">return av_interleaved_write_frame(outputContext, packet.get());</div><div class="line">&#125;</div><div class="line"></div><div class="line">int OpenOutput(string outUrl)</div><div class="line">&#123;</div><div class="line"></div><div class="line">int ret  = avformat_alloc_output_context2(&amp;outputContext, nullptr, &quot;mpegts&quot;, outUrl.c_str());</div><div class="line">if(ret &lt; 0)</div><div class="line">&#123;</div><div class="line">av_log(NULL, AV_LOG_ERROR, &quot;open output context failed\n&quot;);</div><div class="line">goto Error;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ret = avio_open2(&amp;outputContext-&gt;pb, outUrl.c_str(), AVIO_FLAG_WRITE,nullptr, nullptr);</div><div class="line">if(ret &lt; 0)</div><div class="line">&#123;</div><div class="line">av_log(NULL, AV_LOG_ERROR, &quot;open avio failed&quot;);</div><div class="line">goto Error;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(int i = 0; i &lt; inputContext-&gt;nb_streams; i++)</div><div class="line">&#123;</div><div class="line">//输出依赖于输入</div><div class="line">AVStream * stream = avformat_new_stream(outputContext, inputContext-&gt;streams[i]-&gt;codec-&gt;codec);</div><div class="line">ret = avcodec_copy_context(stream-&gt;codec, inputContext-&gt;streams[i]-&gt;codec);</div><div class="line">if(ret &lt; 0)</div><div class="line">&#123;</div><div class="line">av_log(NULL, AV_LOG_ERROR, &quot;copy coddec context failed&quot;);</div><div class="line">goto Error;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ret = avformat_write_header(outputContext, nullptr);</div><div class="line">if(ret &lt; 0)</div><div class="line">&#123;</div><div class="line">av_log(NULL, AV_LOG_ERROR, &quot;format write header failed&quot;);</div><div class="line">goto Error;</div><div class="line">&#125;</div><div class="line"></div><div class="line">av_log(NULL, AV_LOG_FATAL, &quot; Open output file success %s\n&quot;,outUrl.c_str());</div><div class="line">return ret ;</div><div class="line">Error:</div><div class="line">if(outputContext)</div><div class="line">&#123;</div><div class="line">for(int i = 0; i &lt; outputContext-&gt;nb_streams; i++)</div><div class="line">&#123;</div><div class="line">avcodec_close(outputContext-&gt;streams[i]-&gt;codec);</div><div class="line">&#125;</div><div class="line">avformat_close_input(&amp;outputContext);</div><div class="line">&#125;</div><div class="line">return ret ;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CloseInput()</div><div class="line">&#123;</div><div class="line">if(inputContext != nullptr)</div><div class="line">&#123;</div><div class="line">avformat_close_input(&amp;inputContext);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CloseOutput()</div><div class="line">&#123;</div><div class="line">if(outputContext != nullptr)</div><div class="line">&#123;</div><div class="line">for(int i = 0 ; i &lt; outputContext-&gt;nb_streams; i++)</div><div class="line">&#123;</div><div class="line">AVCodecContext *codecContext = outputContext-&gt;streams[i]-&gt;codec;</div><div class="line">avcodec_close(codecContext);</div><div class="line">&#125;</div><div class="line">avformat_close_input(&amp;outputContext);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">void Init()</div><div class="line">&#123;</div><div class="line">av_register_all();</div><div class="line">avfilter_register_all();</div><div class="line">avformat_network_init();</div><div class="line">av_log_set_level(AV_LOG_ERROR);</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">Init();</div><div class="line">int ret = OpenInput(&quot;rtmp://v1.one-tv.com/live/mpegts.stream&quot;);</div><div class="line">if(ret &gt;= 0)</div><div class="line">&#123;</div><div class="line">//rtmp://192.168.1.107/oflaDemo/test</div><div class="line">//ret = OpenOutput(&quot;rtmp://127.0.0.1:1935/live/stream0&quot;); //播放地址为rtmp://127.0.0.1/live/stream0 live=1</div><div class="line">ret = OpenOutput(&quot;D:\\test.ts&quot;); </div><div class="line">&#125;</div><div class="line">if(ret &lt;0) goto Error;</div><div class="line"></div><div class="line">while(true)</div><div class="line">&#123;</div><div class="line">auto packet = ReadPacketFromSource();</div><div class="line">if(packet)</div><div class="line">&#123;</div><div class="line">ret = WritePacket(packet);</div><div class="line">if(ret &gt;= 0)</div><div class="line">&#123;</div><div class="line">cout&lt;&lt;&quot;WritePacket Success!&quot;&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">cout&lt;&lt;&quot;WritePacket failed!&quot;&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Error:</div><div class="line">CloseInput();</div><div class="line">CloseOutput();</div><div class="line">while(true)</div><div class="line">&#123;</div><div class="line">this_thread::sleep_for(chrono::seconds(100));</div><div class="line">&#125;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&emsp;&emsp;在上面代码函数里面有个函数av_packet_rescale_ts是不是看不懂，其实这里是跳调整时间戳，因为输入和输出流的时间基准不一定相同，所有这里需要进行时间戳转换。</p><p>&emsp;&emsp;interrupt_cb这个函数的官方解释是为I/O层自定义中断回调，在avformat_open_input之前设置，其实就是读取输入数据时的一个回调，在这里我们稍微做一个超时处理，如果读取超过3秒就返回一个错误码中断读取流数据。</p><p>&emsp;&emsp;好了，利用FFmpeg保存网络流就是这么简单，这里留个扩展，你可以试试利用FFmpeg保存网络图片。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天我们开始正式进入FFmpeg的篇章，FFmpeg作为著名的开源框架，可以生成用于处理多媒体框架的库和程序，是音视频界内的圣经，市面上直播开发99%都是基于FFmpeg来开发的，这足以证明FFmpeg的强大。关于FFmpeg的源码和官方文档可以去&lt;
      
    
    </summary>
    
      <category term="安卓直播开发" scheme="http://samychen.com/categories/%E5%AE%89%E5%8D%93%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>视频编解码学习四 边解码边播放视频</title>
    <link href="http://samychen.com/2017/09/02/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E8%BE%B9%E8%A7%A3%E7%A0%81%E8%BE%B9%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"/>
    <id>http://samychen.com/2017/09/02/视频编解码学习四-边解码边播放视频/</id>
    <published>2017-09-02T09:15:00.000Z</published>
    <updated>2018-01-25T12:16:38.144Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一节说到了播放本地的yuv文件，这节我们省去解码保存yuv文件，直接边解码边播放。流程还是同直接解码流程一样。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-f889d70e2f360717.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图"><br>SDL2.0显示YUV的流程图：<br><img src="http://upload-images.jianshu.io/upload_images/4398977-255f44eaeabdf0f4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div></pre></td><td class="code"><pre><div class="line">#include &lt;jni.h&gt;</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line"></div><div class="line">#define LOG_I(...) __android_log_print(ANDROID_LOG_ERROR , &quot;main&quot;, __VA_ARGS__)</div><div class="line"></div><div class="line">#include &quot;SDL.h&quot;</div><div class="line">#include &quot;SDL_log.h&quot;</div><div class="line">#include &quot;SDL_main.h&quot;</div><div class="line"></div><div class="line">////avcodec:编解码(最重要的库)</div><div class="line">//#include &quot;libavcodec/avcodec.h&quot;</div><div class="line">////avformat:封装格式处理</div><div class="line">//#include &quot;libavformat/avformat.h&quot;</div><div class="line">////avutil:工具库(大部分库都需要这个库的支持)</div><div class="line">//#include &quot;libavutil/imgutils.h&quot;</div><div class="line">////swscale:视频像素数据格式转换</div><div class="line">//#include &quot;libswscale/swscale.h&quot;</div><div class="line">////导入音频采样数据格式转换库</div><div class="line">//#include &quot;libswresample/swresample.h&quot;</div><div class="line"></div><div class="line">extern &quot;C&quot; &#123;</div><div class="line">#include &quot;libavcodec/avcodec.h&quot;</div><div class="line">#include &quot;libavformat/avformat.h&quot;</div><div class="line">#include &quot;libavutil/imgutils.h&quot;</div><div class="line">#include &quot;libswscale/swscale.h&quot;</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">    const char *cinputFilePath = &quot;/storage/emulated/0/Test.mov&quot;;</div><div class="line">    //第一步：注册所有组件</div><div class="line">    av_register_all();</div><div class="line">    //支持网络流输入</div><div class="line">    avformat_network_init();</div><div class="line">    //第二步：打开视频输入文件</div><div class="line">    //参数一：封装格式上下文-&gt;AVFormatContext-&gt;包含了视频信息(视频格式、大小等等...)</div><div class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</div><div class="line">    //参数二：打开文件(入口文件)-&gt;url</div><div class="line">    int avformat_open_result = avformat_open_input(&amp;pFormatCtx, cinputFilePath, NULL, NULL);</div><div class="line">    if (avformat_open_result != 0) &#123;</div><div class="line">        //获取异常信息</div><div class="line">        char *error_info;</div><div class="line">        av_strerror(avformat_open_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;异常信息：%s&quot;, error_info);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //第三步：查找视频文件信息</div><div class="line">    //参数一：封装格式上下文-&gt;AVFormatContext</div><div class="line">    //参数二：配置</div><div class="line">    //返回值：0&gt;=返回OK，否则失败</div><div class="line">    int avformat_find_stream_info_result = avformat_find_stream_info(pFormatCtx, NULL);</div><div class="line">    if (avformat_find_stream_info_result &lt; 0) &#123;</div><div class="line">        //获取失败</div><div class="line">        char *error_info;</div><div class="line">        av_strerror(avformat_find_stream_info_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;异常信息：%s&quot;, error_info);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    // Dump valid information onto standard error可忽略</div><div class="line">    av_dump_format(pFormatCtx, 0, cinputFilePath, false);</div><div class="line"></div><div class="line">    //第四步：查找解码器</div><div class="line">    //第一点：获取当前解码器是属于什么类型解码器-&gt;找到了视频流</div><div class="line">    //音频解码器、视频解码器、字幕解码器等等...</div><div class="line">    //获取视频解码器流引用-&gt;指针</div><div class="line">    int av_stream_index = -1;</div><div class="line">    for (int i = 0; i &lt; pFormatCtx-&gt;nb_streams; ++i) &#123;</div><div class="line">        //循环遍历每一流</div><div class="line">        //视频流、音频流、字幕流等等...</div><div class="line">        if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</div><div class="line">            //找到了</div><div class="line">            av_stream_index = i;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (av_stream_index == -1) &#123;</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;%s&quot;, &quot;没有找到视频流&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    //第二点：根据视频流-&gt;查找到视频解码器上下文-&gt;视频压缩数据</div><div class="line">    AVCodecContext *avcodec_context = pFormatCtx-&gt;streams[av_stream_index]-&gt;codec;</div><div class="line">    //第三点：根据解码器上下文-&gt;获取解码器ID</div><div class="line">    AVCodec *avcodec = avcodec_find_decoder(avcodec_context-&gt;codec_id);</div><div class="line">    if (avcodec == NULL) &#123;</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;%s&quot;, &quot;没有找到视频解码器&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //第五步：打开解码器</div><div class="line">    int avcodec_open2_result = avcodec_open2(avcodec_context, avcodec, NULL);</div><div class="line">    if (avcodec_open2_result != 0) &#123;</div><div class="line">        char *error_info;</div><div class="line">        av_strerror(avcodec_open2_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;异常信息：%s&quot;, error_info);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //输出视频信息</div><div class="line">    //输出：文件格式</div><div class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;文件格式：%s&quot;, pFormatCtx-&gt;iformat-&gt;name);</div><div class="line">    //输出：解码器名称</div><div class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;解码器名称：%s&quot;, avcodec-&gt;name);</div><div class="line">    //第六步：循环读取视频帧，进行循环解码-&gt;输出YUV420P视频-&gt;格式：yuv格式</div><div class="line">    //读取帧数据换成到哪里-&gt;缓存到packet里面</div><div class="line">    AVPacket *av_packet = (AVPacket *) av_malloc(sizeof(AVPacket));</div><div class="line">    //输入-&gt;环境一帧数据-&gt;缓冲区-&gt;类似于一张图</div><div class="line">    AVFrame *av_frame_in = av_frame_alloc();</div><div class="line">    //输出-&gt;帧数据-&gt;视频像素数据格式-&gt;yuv420p</div><div class="line">    AVFrame *av_frame_out_yuv420p = av_frame_alloc();</div><div class="line">    //解码的状态类型(0:表示解码完毕，非0:表示正在解码)</div><div class="line">    int av_decode_result, current_frame_index = 0;</div><div class="line">    //只有指定了AVFrame的像素格式、画面大小才能真正分配内存</div><div class="line">    //缓冲区</div><div class="line">    //作用：计算音频/视频占用的字节数，开辟对应的内存空间</div><div class="line">    //参数一：缓冲区格式</div><div class="line">    //参数二：缓冲区宽度</div><div class="line">    //参数三：缓冲区高度</div><div class="line">    //参数四：字节对齐(设置通用1)</div><div class="line">    int image_size = av_image_get_buffer_size(AV_PIX_FMT_YUV420P, avcodec_context-&gt;width, avcodec_context-&gt;height,1);</div><div class="line">    //开辟缓存空间</div><div class="line">    uint8_t *frame_buffer_out = (uint8_t *)av_malloc(image_size);</div><div class="line">    //对开辟的缓存空间指定填充数据格式</div><div class="line">    //参数一：数据</div><div class="line">    //参数二：行数</div><div class="line">    //参数三：缓存区</div><div class="line">    //参数四：格式</div><div class="line">    //参数五：宽度</div><div class="line">    //参数六：高度</div><div class="line">    //参数七：字节对齐(设置通用1)</div><div class="line">    av_image_fill_arrays(av_frame_out_yuv420p-&gt;data, av_frame_out_yuv420p-&gt;linesize,frame_buffer_out,</div><div class="line">                         AV_PIX_FMT_YUV420P,avcodec_context-&gt;width, avcodec_context-&gt;height,1);</div><div class="line">    //准备一个视频像素数据格式上下文</div><div class="line">    //参数一：输入帧数据宽</div><div class="line">    //参数二：输入帧数据高</div><div class="line">    //参数三：输入帧数据格式</div><div class="line">    //参数四：输出帧数据宽</div><div class="line">    //参数五：输出帧数据高</div><div class="line">    //参数六：输出帧数据格式-&gt;AV_PIX_FMT_YUV420P</div><div class="line">    //参数七：视频像素数据格式转换算法类型</div><div class="line">    //参数八：字节对齐类型(C/C++里面)-&gt;提高读取效率</div><div class="line">    SwsContext *sws_context = sws_getContext(avcodec_context-&gt;width,</div><div class="line">                                             avcodec_context-&gt;height,</div><div class="line">                                             avcodec_context-&gt;pix_fmt,</div><div class="line">                                             avcodec_context-&gt;width,</div><div class="line">                                             avcodec_context-&gt;height,</div><div class="line">                                             AV_PIX_FMT_YUV420P,</div><div class="line">                                             SWS_BICUBIC, NULL, NULL, NULL);</div><div class="line">    // 加载SDL</div><div class="line">    //第一步：初始化SDL多媒体框架-&gt;SDL_Init</div><div class="line">    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER) == -1) &#123;</div><div class="line">        LOG_I(&quot;SDL_Init failed %s&quot;, SDL_GetError());</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    LOG_I(&quot;SDL_Init Success!&quot;);</div><div class="line">    //第二步：初始化SDL窗口</div><div class="line">    //参数一：窗口名称-&gt;要求必需是UTF-8编码</div><div class="line">    //参数二：窗口在屏幕上面X坐标</div><div class="line">    //参数三：窗口在屏幕上面Y坐标</div><div class="line">    //参数四：窗口在屏幕上面宽</div><div class="line">    int width = 640;</div><div class="line">    //参数五：窗口在屏幕上面高</div><div class="line">    int height = 352;</div><div class="line">    //参数六：窗口状态(打开的状态:SDL_WINDOW_OPENGL)</div><div class="line">    SDL_Window *sdl_window = SDL_CreateWindow(&quot;SDL播放器&quot;,</div><div class="line">                                              SDL_WINDOWPOS_CENTERED,</div><div class="line">                                              SDL_WINDOWPOS_CENTERED,</div><div class="line">                                              width,</div><div class="line">                                              height,</div><div class="line">                                              SDL_WINDOW_OPENGL);</div><div class="line">    if (sdl_window == NULL) &#123;</div><div class="line">        LOG_I(&quot;窗口创建失败&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //第三步：创建渲染器-&gt;渲染窗口(OpenGL ES)</div><div class="line">    //最新一期VIP课程</div><div class="line">    //参数一：渲染目标窗口</div><div class="line">    //参数二：从哪里开始渲染(-1:默认从第一个为止开始)</div><div class="line">    //参数三：渲染类型</div><div class="line">    //SDL_RENDERER_SOFTWARE:软件渲染</div><div class="line">    //...</div><div class="line">    SDL_Renderer *sdl_renderer = SDL_CreateRenderer(sdl_window, -1, 0);</div><div class="line">    //第四步：创建纹理</div><div class="line">    //参数一：纹理目标渲染器</div><div class="line">    //参数二：渲染格式</div><div class="line">    //参数三：绘制方式(SDL_TEXTUREACCESS_STREAMING:频繁绘制)</div><div class="line">    //参数四：纹理宽</div><div class="line">    //参数五：纹理高</div><div class="line">    SDL_Texture *sdl_texture = SDL_CreateTexture(sdl_renderer,</div><div class="line">                                                 SDL_PIXELFORMAT_IYUV,</div><div class="line">                                                 SDL_TEXTUREACCESS_STREAMING,</div><div class="line">                                                 width,</div><div class="line">                                                 height);</div><div class="line">    SDL_Rect sdl_rect;</div><div class="line">    sdl_rect.x = 0;</div><div class="line">    sdl_rect.y = 0;</div><div class="line">    sdl_rect.w = width;</div><div class="line">    sdl_rect.h = height;</div><div class="line">    //&gt;=0:说明有数据，继续读取</div><div class="line">    //&lt;0:说明读取完毕，结束</div><div class="line">    while (av_read_frame(pFormatCtx, av_packet) &gt;= 0) &#123;</div><div class="line">        //解码什么类型流(视频流、音频流、字幕流等等...)</div><div class="line">        if (av_packet-&gt;stream_index == av_stream_index) &#123;</div><div class="line">            //扩展知识面(有更新)</div><div class="line">            //解码一帧视频流数据</div><div class="line">            //分析：avcodec_decode_video2函数</div><div class="line">            //参数一：解码器上下文</div><div class="line">            //参数二：一帧数据</div><div class="line">            //参数三：got_picture_ptr-&gt;是否正在解码(0:表示解码完毕，非0:表示正在解码)</div><div class="line">            //参数四：一帧压缩数据(对压缩数据进行解码操作)</div><div class="line">            //返回值：av_decode_result == 0表示解码一帧数据成功，否则失败</div><div class="line">            //av_decode_result = avcodec_decode_video2(avcodec_context,av_frame_in,&amp;got_picture_ptr,av_packet);</div><div class="line">            //新的API操作</div><div class="line">            //发送一帧数据-&gt;接收一帧数据</div><div class="line">            //发送一帧数据</div><div class="line">            avcodec_send_packet(avcodec_context, av_packet);</div><div class="line">            //接收一帧数据-&gt;解码一帧</div><div class="line">            av_decode_result = avcodec_receive_frame(avcodec_context, av_frame_in);</div><div class="line">            //解码出来的每一帧数据成功之后，将每一帧数据保存为YUV420格式文件类型(.yuv文件格式)</div><div class="line">            if (av_decode_result == 0) &#123;</div><div class="line">                //sws_scale：作用将视频像素数据格式-&gt;yuv420p格式</div><div class="line">                //输出.yuv文件-&gt;视频像素数据格式文件-&gt;输出到文件API</div><div class="line">                //参数一：视频像素数据格式-&gt;上下文</div><div class="line">                //参数二：输入数据</div><div class="line">                //参数三：输入画面每一行的大小</div><div class="line">                //参数四：输入画面每一行的要转码的开始位置</div><div class="line">                //参数五：每一帧数据高</div><div class="line">                //参数六：输出画面数据</div><div class="line">                //参数七：输出画面每一行的大小</div><div class="line">                sws_scale(sws_context,</div><div class="line">                          (const uint8_t *const *) av_frame_in-&gt;data,</div><div class="line">                          av_frame_in-&gt;linesize,</div><div class="line">                          0,</div><div class="line">                          avcodec_context-&gt;height,</div><div class="line">                          av_frame_out_yuv420p-&gt;data,</div><div class="line">                          av_frame_out_yuv420p-&gt;linesize);</div><div class="line">                //  sart SDL  //</div><div class="line">                //SDL渲染实现</div><div class="line">                //设置纹理数据</div><div class="line">                //参数一：目标纹理对象</div><div class="line">                //参数二：渲染区域(NULL:表示默认屏幕窗口宽高)</div><div class="line">                //参数三：视频像素数据</div><div class="line">                //参数四：帧画面宽</div><div class="line">                SDL_UpdateTexture(sdl_texture, NULL, av_frame_out_yuv420p-&gt;data[0],</div><div class="line">                                  av_frame_out_yuv420p-&gt;linesize[0]);</div><div class="line">                //先清空</div><div class="line">                SDL_RenderClear(sdl_renderer);</div><div class="line">                //再渲染</div><div class="line">                SDL_RenderCopy(sdl_renderer, sdl_texture, NULL, &amp;sdl_rect);</div><div class="line">                //第七步：显示帧画面</div><div class="line">                SDL_RenderPresent(sdl_renderer);</div><div class="line">                //第八步：延时渲染(没渲染一帧间隔时间)</div><div class="line">                SDL_Delay(20);</div><div class="line">                // end SDL //</div><div class="line">                current_frame_index++;</div><div class="line">                __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;当前遍历第%d帧&quot;, current_frame_index);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //第七步：关闭解码组件-&gt;释放内存</div><div class="line">    SDL_DestroyTexture(sdl_texture);</div><div class="line">    SDL_DestroyRenderer(sdl_renderer);</div><div class="line">    //第十步：推出SDL程序</div><div class="line">    SDL_Quit();</div><div class="line">    av_packet_free(&amp;av_packet);</div><div class="line">    av_frame_free(&amp;av_frame_in);</div><div class="line">    av_frame_free(&amp;av_frame_out_yuv420p);</div><div class="line">    avcodec_close(avcodec_context);</div><div class="line">    avformat_free_context(pFormatCtx);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>FFmpeg在解码一帧之后转换像素数据格式，并没有立马进行渲染，这里延时了20毫秒，如果没有延时这20毫秒，视频一下子就可以播放完毕了。实际在播放视频时，SDL延时不能使用固定值，需要根据视频的pts来计算，同时要考虑视频和音频直接的同步，这里先不做进一步研究了，之后的博客会给出延时时间的计算。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://github.com/samychen/SDL_FFmpeg_Tutorial" target="_blank" rel="external">https://github.com/samychen/SDL_FFmpeg_Tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;上一节说到了播放本地的yuv文件，这节我们省去解码保存yuv文件，直接边解码边播放。流程还是同直接解码流程一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/43989
      
    
    </summary>
    
      <category term="安卓直播开发" scheme="http://samychen.com/categories/%E5%AE%89%E5%8D%93%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>视频编解码学习三 播放yuv格式视频</title>
    <link href="http://samychen.com/2017/09/01/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%89-%E6%92%AD%E6%94%BEyuv%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91/"/>
    <id>http://samychen.com/2017/09/01/视频编解码学习三-播放yuv格式视频/</id>
    <published>2017-09-01T08:15:00.000Z</published>
    <updated>2018-01-25T15:27:29.495Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天的主题是播放yuv格式视频。<br>在上两篇博客里面介绍过了如何将视频解码为单独的视频和音频，但是如果播放这些格式的文件呢，安卓原生是没有这些控件来直播播放yuv格式视频的，必须通过借助其他方式来播放，今天就介绍SDL2来解码播放yuv文件。</p><h4 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h4><p>&emsp;&emsp;什么是SDL？SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，专门用来开发多媒体，游戏等。详细想了解的可以去<a href="https://wiki.libsdl.org/" target="_blank" rel="external">SDL</a>官方文档查看</p><p>下面是FFmpeg官方给出的播放流程<br><img src="http://upload-images.jianshu.io/upload_images/4398977-b6aa3b7ee5e0791e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>根据上面的流程，在得到yuv像素数据的时候就可以渲染了</p><p>采用SDL播放yuv文件播放流程:<br>               &emsp;&emsp; 第一步：初始化SDL多媒体框架-&gt;SDL_Init<br>        &emsp;&emsp;第二步：初始化SDL窗口<br>        &emsp;&emsp;第三步：创建渲染器-&gt;渲染窗口(OpenGL ES)<br>        &emsp;&emsp;第四步：设置纹理数据-&gt;播放YUV视频<br>        &emsp;&emsp;第五步：将纹理数据拷贝到渲染器<br>        &emsp;&emsp;第六步：显示帧画面<br>        &emsp;&emsp;第七步：退出SDL释放内存</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">#include &lt;jni.h&gt;</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line"></div><div class="line">#define LOG_I(...) __android_log_print(ANDROID_LOG_ERROR , &quot;main&quot;, __VA_ARGS__)</div><div class="line"></div><div class="line">#include &quot;SDL.h&quot;</div><div class="line">#include &quot;SDL_log.h&quot;</div><div class="line">#include &quot;SDL_main.h&quot;</div><div class="line"></div><div class="line">////avcodec:编解码(最重要的库)</div><div class="line">//#include &quot;libavcodec/avcodec.h&quot;</div><div class="line">////avformat:封装格式处理</div><div class="line">//#include &quot;libavformat/avformat.h&quot;</div><div class="line">////avutil:工具库(大部分库都需要这个库的支持)</div><div class="line">//#include &quot;libavutil/imgutils.h&quot;</div><div class="line">////swscale:视频像素数据格式转换</div><div class="line">//#include &quot;libswscale/swscale.h&quot;</div><div class="line">////导入音频采样数据格式转换库</div><div class="line">//#include &quot;libswresample/swresample.h&quot;</div><div class="line"></div><div class="line">extern &quot;C&quot; &#123;</div><div class="line">#include &quot;libavcodec/avcodec.h&quot;</div><div class="line">#include &quot;libavformat/avformat.h&quot;</div><div class="line">#include &quot;libavutil/imgutils.h&quot;</div><div class="line">#include &quot;libswscale/swscale.h&quot;</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">    //第一步：初始化SDL多媒体框架-&gt;SDL_Init</div><div class="line">    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER) == -1) &#123;</div><div class="line">        LOG_I(&quot;SDL_Init failed %s&quot;, SDL_GetError());</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    LOG_I(&quot;SDL_Init Success!&quot;);</div><div class="line"></div><div class="line">    //第二步：初始化SDL窗口</div><div class="line">    //参数一：窗口名称-&gt;要求必需是UTF-8编码</div><div class="line">    //参数二：窗口在屏幕上面X坐标</div><div class="line">    //参数三：窗口在屏幕上面Y坐标</div><div class="line">    //参数四：窗口在屏幕上面宽</div><div class="line">    int width = 640;</div><div class="line">    //参数五：窗口在屏幕上面高</div><div class="line">    int height = 352;</div><div class="line">    //参数六：窗口状态(打开的状态:SDL_WINDOW_OPENGL)</div><div class="line">    SDL_Window* sdl_window = SDL_CreateWindow(&quot;SDL播放器&quot;,</div><div class="line">                                              SDL_WINDOWPOS_CENTERED,</div><div class="line">                                              SDL_WINDOWPOS_CENTERED,</div><div class="line">                                              width ,</div><div class="line">                                              height,</div><div class="line">                                              SDL_WINDOW_OPENGL);</div><div class="line">    if (sdl_window == NULL)&#123;</div><div class="line">        LOG_I(&quot;窗口创建失败&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //第三步：创建渲染器-&gt;渲染窗口(OpenGL ES)</div><div class="line">    //最新一期VIP课程</div><div class="line">    //参数一：渲染目标窗口</div><div class="line">    //参数二：从哪里开始渲染(-1:默认从第一个为止开始)</div><div class="line">    //参数三：渲染类型</div><div class="line">    //SDL_RENDERER_SOFTWARE:软件渲染</div><div class="line">    //...</div><div class="line">    SDL_Renderer* sdl_renderer = SDL_CreateRenderer(sdl_window, -1, 0);</div><div class="line"></div><div class="line">    //第四步：创建纹理</div><div class="line">    //参数一：纹理目标渲染器</div><div class="line">    //参数二：渲染格式</div><div class="line">    //参数三：绘制方式(SDL_TEXTUREACCESS_STREAMING:频繁绘制)</div><div class="line">    //参数四：纹理宽</div><div class="line">    //参数五：纹理高</div><div class="line">    SDL_Texture * sdl_texture = SDL_CreateTexture(sdl_renderer,</div><div class="line">                                                  SDL_PIXELFORMAT_IYUV,</div><div class="line">                                                  SDL_TEXTUREACCESS_STREAMING,</div><div class="line">                                                  width,</div><div class="line">                                                  height);</div><div class="line"></div><div class="line">    //第五步：设置纹理数据-&gt;播放YUV视频</div><div class="line">    //着色器语言(着色器)、渲染器、纹理等等...</div><div class="line">    //第一点：打开YUV文件(手机：)</div><div class="line">    FILE* yuv_file = fopen(&quot;/storage/emulated/0/DreamTestFile/Test.yuv&quot;,&quot;rb+&quot;);</div><div class="line">    if (yuv_file == NULL)&#123;</div><div class="line">        LOG_I(&quot;文件打开失败&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //第二点：循环读取YUV视频像素数据格式每一帧画面-&gt;渲染-&gt;设置纹理数据</div><div class="line">    //定义缓冲区(内存空间开辟多大?)</div><div class="line">    //Y:U:V = 4 : 1 : 1</div><div class="line">    //假设：Y = 1.0  U = 0.25  V = 0.25</div><div class="line">    //宽度：Y + U + V = 1.5</div><div class="line">    //换算：Y + U + V = width * height * 1.5</div><div class="line">    char buffer_pix[width * height * 3 / 2];</div><div class="line"></div><div class="line">    //定义渲染器区域</div><div class="line">    SDL_Rect sdl_rect;</div><div class="line">    while (true)&#123;</div><div class="line">        //一行一行的读取</div><div class="line">        fread(buffer_pix, 1, width * height * 3 / 2, yuv_file);</div><div class="line">        //判定是否读取完毕</div><div class="line">        if (feof(yuv_file))&#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //设置纹理数据</div><div class="line">        //参数一：目标纹理对象</div><div class="line">        //参数二：渲染区域(NULL:表示默认屏幕窗口宽高)</div><div class="line">        //参数三：视频像素数据</div><div class="line">        //参数四：帧画面宽</div><div class="line">        SDL_UpdateTexture(sdl_texture, NULL, buffer_pix, width);</div><div class="line"></div><div class="line">        //第六步：将纹理数据拷贝到渲染器</div><div class="line">        sdl_rect.x = 0;</div><div class="line">        sdl_rect.y = 0;</div><div class="line">        sdl_rect.w = width;</div><div class="line">        sdl_rect.h = height;</div><div class="line"></div><div class="line">        //先清空</div><div class="line">        SDL_RenderClear(sdl_renderer);</div><div class="line">        //再渲染</div><div class="line">        SDL_RenderCopy(sdl_renderer,sdl_texture,NULL,&amp;sdl_rect);</div><div class="line"></div><div class="line">        //第七步：显示帧画面</div><div class="line">        SDL_RenderPresent(sdl_renderer);</div><div class="line"></div><div class="line">        //第八步：延时渲染(没渲染一帧间隔时间)</div><div class="line">        SDL_Delay(20);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //第九步：是否内存</div><div class="line">    fclose(yuv_file);</div><div class="line"></div><div class="line">    SDL_DestroyTexture(sdl_texture);</div><div class="line"></div><div class="line">    SDL_DestroyRenderer(sdl_renderer);</div><div class="line"></div><div class="line"></div><div class="line">    //第十步：推出SDL程序</div><div class="line">    SDL_Quit();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的源码只是演示如何播放yuv格式视频，当然在实际项目中还需要根据具体业务加入具体业务逻辑，在播放网络流的情况下还需要处理音频和视频间的同步和时间戳问题。这里推荐一个<a href="http://dranger.com/ffmpeg/ffmpeg.html" target="_blank" rel="external">SDL和FFmpeg的国外教程</a>，很实用的一个教程。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://github.com/samychen/SDL_FFmpeg_Tutorial" target="_blank" rel="external">https://github.com/samychen/SDL_FFmpeg_Tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天的主题是播放yuv格式视频。&lt;br&gt;在上两篇博客里面介绍过了如何将视频解码为单独的视频和音频，但是如果播放这些格式的文件呢，安卓原生是没有这些控件来直播播放yuv格式视频的，必须通过借助其他方式来播放，今天就介绍SDL2来解码播放yuv文件。&lt;/
      
    
    </summary>
    
      <category term="安卓直播开发" scheme="http://samychen.com/categories/%E5%AE%89%E5%8D%93%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>视频编解码学习二 pcm</title>
    <link href="http://samychen.com/2017/08/29/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%BA%8C-pcm/"/>
    <id>http://samychen.com/2017/08/29/视频编解码学习二-pcm/</id>
    <published>2017-08-29T12:13:48.000Z</published>
    <updated>2018-01-25T12:14:36.325Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天的主题是音频解码，主要实现将视频中的音频解码为音频采用格式pcm。<br>首先在文章开头给出两个问题</p><p>第一个问题：音频解码和视频解码目的是什么？为什么要进行音频压缩或者是视频压缩？<br>目的：压缩音频流、视频流、字幕流等等…（减小数据量）</p><p>第二个问题：音频采样数据作用？<br>保存音频中每一个采样点的值</p><p>我们来计算2分钟pcm音频的大小:<br>规定：采样率:44100HZ<br>在图像学中：每8位 = 1字节<br>编码（采样精度）：16位 = 2字节<br>声道数量：2个<br>pcm格式体积 = 2 <em> 60 </em> 44100 <em> 2 </em> 2 = 21MB<br>mp3 = 2MB</p><p>从计算过程就可以看出，实际情况必须采用压缩来存储音频。</p><p>那么pcm有哪些格式，我们平常说的单声道，双声道又是什么回事？这里又分两种情况<br>第一种:单声道(左右声道)<br>第二种:双声道(排版顺序”左右”,”左右”)<br>二者都是采样点顺序排版存储<br><img src="http://upload-images.jianshu.io/upload_images/4398977-95a2b92724521c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>那么音频解码的环节又是怎样的过程呢，参照官方给出的流程图<br><img src="http://upload-images.jianshu.io/upload_images/4398977-33571f7eaa809c60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FFmpeg解码"><br>从上图我们可以看出音频解码流程<br>        第一步：注册所有的组件（编解码、滤镜特效处理库、封装格式处理库、工具库、音频采样数据格式转换库、视频像素数据格式转换等等…）<br>        第二步：获取音频封装格式信息<br>        第三步：查找音频流<br>        第四步：查找音频解码器<br>        第五步：打开音频解码器<br>        第六步：读取音频压缩数据进行解码（循环解码）<br>        第七步：关闭音频解码器释放内存</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div></pre></td><td class="code"><pre><div class="line">#include &lt;jni.h&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">//导入android-log日志</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line"></div><div class="line">//当前C++兼容C语言</div><div class="line">extern &quot;C&quot;&#123;</div><div class="line">//avcodec:编解码(最重要的库)</div><div class="line">#include &quot;libavcodec/avcodec.h&quot;</div><div class="line">//avformat:封装格式处理</div><div class="line">#include &quot;libavformat/avformat.h&quot;</div><div class="line">//avutil:工具库(大部分库都需要这个库的支持)</div><div class="line">#include &quot;libavutil/imgutils.h&quot;</div><div class="line">//swscale:视频像素数据格式转换</div><div class="line">#include &quot;libswscale/swscale.h&quot;</div><div class="line">//导入音频采样数据格式转换库</div><div class="line">#include &quot;libswresample/swresample.h&quot;</div><div class="line"></div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegTest</div><div class="line">        (JNIEnv *, jobject);</div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegDecoder</div><div class="line">        (JNIEnv *env, jobject jobj,jstring jInFilePath,jstring jOutFilePath);</div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegDecoderAudio</div><div class="line">        (JNIEnv *env, jobject jobj,jstring jInFilePath,jstring jOutFilePath);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//1、NDK音视频编解码：FFmpeg-测试配置</div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegTest(</div><div class="line">        JNIEnv *env, jobject jobj) &#123;</div><div class="line">    //(char *)表示C语言字符串</div><div class="line">    const char *configuration = avcodec_configuration();</div><div class="line">    __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;%s&quot;,configuration);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//NDK音视频编解码：FFmpeg-音频解码-音频采样数据pcm格式</div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegDecoderAudio</div><div class="line">        (JNIEnv *env, jobject jobj,jstring jInFilePath,jstring jOutFilePath) &#123;</div><div class="line"></div><div class="line">    //第一步：注册所有的组件</div><div class="line">    // （编解码、滤镜特效处理库、封装格式处理库、工具库、音频采样数据格式转换库、视频像素数据格式转换等等...）</div><div class="line">    av_register_all();</div><div class="line">    avcodec_register_all();</div><div class="line">    //第二步：获取音频封装格式信息</div><div class="line">    AVFormatContext *avformat_context = avformat_alloc_context();</div><div class="line">    //参数一：封装格式上下文-&gt;保存了音频信息</div><div class="line">    //参数二：输入文件(你要对那一个文件进行解封装)</div><div class="line">    //普及知识：env是JNI环境指针(作用：专门用于管理对象创建和销毁)</div><div class="line">    const char *cInFilePath = env-&gt;GetStringUTFChars(jInFilePath, NULL);</div><div class="line">    //参数三：封装格式类型(NULL：表示系统自动获取格式类型)</div><div class="line">    //返回值：avformat_open_input_result = 0表示成功，否则失败</div><div class="line">    int avformat_open_input_result = avformat_open_input(&amp;avformat_context, cInFilePath, NULL,</div><div class="line">                                                         NULL);</div><div class="line">    if (avformat_open_input_result != 0) &#123;</div><div class="line">        char *error_info;</div><div class="line">        av_strerror(avformat_open_input_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;获取失败，错误信息：%s&quot;, error_info);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //第三步：查找音频流</div><div class="line">    //返回值：&gt;=0 if OK, AVERROR_xxx on error(&gt;=0表示成功，否则失败)</div><div class="line">    int avformat_find_stream_info_result = avformat_find_stream_info(avformat_context, NULL);</div><div class="line">    if (avformat_find_stream_info_result &lt; 0) &#123;</div><div class="line">        char *error_info;</div><div class="line">        av_strerror(avformat_find_stream_info_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;查找失败，错误信息：%s&quot;, error_info);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //第四步：查找音频解码器</div><div class="line">    //第一点：查找音频流索引位置</div><div class="line">    int av_stream_index_audio = -1;</div><div class="line">    for (int i = 0; i &lt; avformat_context-&gt;nb_streams; ++i) &#123;</div><div class="line">        if (avformat_context-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</div><div class="line">            av_stream_index_audio = i;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (av_stream_index_audio == -1) &#123;</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;没有找到音频流&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //第二点：查找音频解码器上下文(根据流索引位置-&gt;获取音频解码买上下文)</div><div class="line">    //新的API</div><div class="line">//    AVCodecParameters *avcodec_parameters = avformat_context-&gt;streams[av_stream_index_audio]-&gt;codecpar;</div><div class="line">//    avcodec_parameters-&gt;codec_id;</div><div class="line"></div><div class="line">    //老的API</div><div class="line">    AVCodecContext *avcodec_context = avformat_context-&gt;streams[av_stream_index_audio]-&gt;codec;</div><div class="line"></div><div class="line"></div><div class="line">    //第三点：根据音频解码器上下文-&gt;获取到-&gt;音频解码器</div><div class="line">    AVCodec *avcodec = avcodec_find_decoder(avcodec_context-&gt;codec_id);</div><div class="line">    if (avcodec == NULL) &#123;</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;找不到这个音频解码器&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //第五步：打开音频解码器(调试运行-&gt;观察锁定C/C++基于NDK开发异常-&gt;便于调试运行)</div><div class="line">    int avcodec_open2_result = avcodec_open2(avcodec_context, avcodec, NULL);</div><div class="line">    if (avcodec_open2_result != 0) &#123;</div><div class="line">        char *error_info;</div><div class="line">        av_strerror(avcodec_open2_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;打开音频解码器失败，错误信息：%s&quot;, error_info);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //打印音频信息</div><div class="line">    //输出视频信息</div><div class="line">    //输出：文件格式</div><div class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;文件格式：%s&quot;, avformat_context-&gt;iformat-&gt;name);</div><div class="line">    //输出：解码器名称</div><div class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;解码器名称：%s&quot;, avcodec-&gt;name);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    //第六步：读取音频压缩数据进行解码（循环解码）</div><div class="line"></div><div class="line">    //读取一帧音频压缩数据(缓冲区)</div><div class="line">    AVPacket *av_packet = (AVPacket *) av_malloc(sizeof(AVPacket));</div><div class="line"></div><div class="line">    //接收一帧音频采样数据(缓冲区)</div><div class="line">    AVFrame *av_frame_in = av_frame_alloc();</div><div class="line"></div><div class="line">    //音频解码返回结果</div><div class="line">    int avcodec_receive_frame_result;</div><div class="line"></div><div class="line">    //音频采样数据上下文-&gt;SwrContext</div><div class="line">    //第一点：创建上下文-&gt;开辟内存空间(声明)</div><div class="line">    SwrContext *swr_context = swr_alloc();</div><div class="line">    //第二点：给我们的音频采样数据上下文-&gt;绑定数据</div><div class="line">    //参数一：音频采样数据上下文</div><div class="line">    //参数二：输出声道布局类型(立体声、环绕、室内等等...)</div><div class="line">    //立体声</div><div class="line">    int out_ch_layout = AV_CH_LAYOUT_STEREO;</div><div class="line">    //参数三：输出音频采样数据格式(说白了：采样精度)</div><div class="line">    AVSampleFormat av_sample_format = AV_SAMPLE_FMT_S16;</div><div class="line">    //参数四：输出音频采样数据-&gt;采样率</div><div class="line">    int out_sample_rate = avcodec_context-&gt;sample_rate;</div><div class="line">    //参数五：输入声道布局类型(立体声、环绕、室内等等...)-&gt;默认格式</div><div class="line">    int in_ch_layout = av_get_default_channel_layout(avcodec_context-&gt;channels);</div><div class="line">    //参数六：输入音频采样数据格式(说白了：采样精度)</div><div class="line">    AVSampleFormat in_sample_fmt = avcodec_context-&gt;sample_fmt;</div><div class="line">    //参数七：输入音频采样数据-&gt;采样率</div><div class="line">    int in_sample_rate = avcodec_context-&gt;sample_rate;</div><div class="line">    //参数八：Log日志偏移量</div><div class="line">    //参数九：Log日志统计上下文</div><div class="line">    swr_alloc_set_opts(swr_context,</div><div class="line">                       out_ch_layout,</div><div class="line">                       av_sample_format,</div><div class="line">                       out_sample_rate,</div><div class="line">                       in_ch_layout,</div><div class="line">                       in_sample_fmt,</div><div class="line">                       in_sample_rate,</div><div class="line">                       0, NULL);</div><div class="line"></div><div class="line">    //输出音频采样数据缓冲区(目标)-&gt;人的耳朵最大采样率-&gt;44100HZ</div><div class="line">    int out_count = 16000;</div><div class="line">    uint8_t *out_buffer = (uint8_t *) av_malloc(out_count);</div><div class="line">    int pktsize, flush_complete = 0;</div><div class="line">    //获取声道数量</div><div class="line">    int out_nb_layout = av_get_channel_layout_nb_channels(out_ch_layout);</div><div class="line"></div><div class="line">    //打开文件</div><div class="line">    const char *coutputFilePath = env-&gt;GetStringUTFChars(jOutFilePath, NULL);</div><div class="line">    FILE *out_file_pcm = fopen(coutputFilePath, &quot;wb+&quot;);</div><div class="line">    if (out_file_pcm == NULL) &#123;</div><div class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;文件不存在&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int frame_index = 0;</div><div class="line">//    while (av_read_frame(avformat_context, av_packet) == 0) &#123;</div><div class="line">//        ++frame_index;</div><div class="line">//        if (av_packet-&gt;stream_index == av_stream_index_audio) &#123;</div><div class="line">//            out_buffer = av_packet-&gt;data;</div><div class="line">//            pktsize = av_packet-&gt;size;</div><div class="line">//            int frameFinished = 0;</div><div class="line">//            int len = avcodec_decode_audio4(avcodec_context, av_frame_in, &amp;frameFinished,</div><div class="line">//                                            av_packet);</div><div class="line">//            if (frameFinished) &#123;</div><div class="line">//                pktsize -= len;</div><div class="line">//                out_buffer += len;</div><div class="line">//                int data_size = av_samples_get_buffer_size(NULL,</div><div class="line">//                                                           out_nb_layout,</div><div class="line">//                                                           av_frame_in-&gt;nb_samples,</div><div class="line">//                                                           av_sample_format,</div><div class="line">//                                                           1);</div><div class="line">//                /*****************************************************</div><div class="line">//                以下代码使用swr_convert函数进行转换，但是转换后的文件连mp3到pcm文件都不能播放了，所以注释了</div><div class="line">//                const uint8_t *in[] = &#123;frame-&gt;data[0]&#125;;</div><div class="line">//</div><div class="line">//                int len=swr_convert(swrContext,out,sizeof(audio_buf)/codecContext-&gt;channels/av_get_bytes_per_sample(AV_SAMPLE_FMT_S16P),</div><div class="line">//                    in,frame-&gt;linesize[0]/codecContext-&gt;channels/av_get_bytes_per_sample(codecContext-&gt;sample_fmt));</div><div class="line">//</div><div class="line">//                len=len*codecContext-&gt;channels*av_get_bytes_per_sample(AV_SAMPLE_FMT_S16P);</div><div class="line">//</div><div class="line">//                if (len &lt; 0) &#123;</div><div class="line">//                    fprintf(stderr, &quot;audio_resample() failed\n&quot;);</div><div class="line">//                    break;</div><div class="line">//                &#125;</div><div class="line">//                if (len == sizeof(audio_buf) / codecContext-&gt;channels / av_get_bytes_per_sample(AV_SAMPLE_FMT_S16P)) &#123;</div><div class="line">//                    fprintf(stderr, &quot;warning: audio buffer is probably too small\n&quot;);</div><div class="line">//                    swr_init(swrContext);</div><div class="line">//                &#125;</div><div class="line">//                *****************************************************/</div><div class="line">//                char *data = (char *) malloc(data_size);</div><div class="line">//                short *sample_buffer = (short *) av_frame_in-&gt;data[0];</div><div class="line">//                for (int i = 0; i &lt; data_size / 2; i++) &#123;</div><div class="line">//                    data[i * 2] = (char) (sample_buffer[i / 2] &amp; 0xFF);</div><div class="line">//                    data[i * 2 + 1] = (char) ((sample_buffer[i / 2] &gt;&gt; 8) &amp; 0xFF);</div><div class="line">//</div><div class="line">//                &#125;</div><div class="line">//                fwrite(data, data_size, 1, out_file_pcm);</div><div class="line">//                fflush(out_file_pcm);</div><div class="line">//            &#125;</div><div class="line">//        &#125;</div><div class="line">        //返回值：&lt;0表示读取完毕，否则正在读取</div><div class="line">        while (av_read_frame(avformat_context, av_packet) &gt;= 0) &#123;</div><div class="line">            //判定当前帧是否是音频流-&gt;音频采样数据</div><div class="line">            if (av_packet-&gt;stream_index == av_stream_index_audio) &#123;</div><div class="line">                //确定是我们的音频流-&gt;解码</div><div class="line">                //解码一帧音频流数据</div><div class="line">                //老的API</div><div class="line">                //avcodec_decode_audio4();</div><div class="line">                //新的API(发送-&gt;接收)</div><div class="line">                //发送</div><div class="line">                avcodec_send_packet(avcodec_context, av_packet);</div><div class="line">                //接收</div><div class="line">                avcodec_receive_frame_result = avcodec_receive_frame(avcodec_context, av_frame_in);</div><div class="line"></div><div class="line">                if (avcodec_receive_frame_result == 0) &#123;</div><div class="line">                    //解码一帧音频压缩数据成功-&gt;得到了-&gt;一帧音频采样数据</div><div class="line">                    //音频采样数据-&gt;转成pcm格式</div><div class="line">                    //将输入-&gt;输出(pcm格式)</div><div class="line">                    //参数一：音频采样数据上下文-&gt;SwrContext</div><div class="line">                    //参数二：输出音频采样数据缓冲区(目标)</div><div class="line">                    //参数三：输出缓冲区大小</div><div class="line">                    //参数四：输入音频采样数据缓冲区</div><div class="line">                    //参数五：输入缓冲区大小</div><div class="line">                    swr_convert(swr_context,</div><div class="line">                                &amp;out_buffer,</div><div class="line">                                out_count,</div><div class="line">                                (const uint8_t **) av_frame_in-&gt;data,</div><div class="line">                                av_frame_in-&gt;nb_samples);</div><div class="line">                    //获取缓冲区实际数据大小</div><div class="line">                    //参数一：行大小</div><div class="line">                    //参数二：声道数量</div><div class="line">                    //参数三：输出大小</div><div class="line">                    //参数四：输出音频采样数据格式</div><div class="line">                    //参数五：字节对齐类型</div><div class="line">                    int out_buffer_size = av_samples_get_buffer_size(NULL,</div><div class="line">                                                                     out_nb_layout,</div><div class="line">                                                                     av_frame_in-&gt;nb_samples,</div><div class="line">                                                                     av_sample_format,</div><div class="line">                                                                     1);</div><div class="line">                    //写入文件</div><div class="line">                    fwrite(av_frame_in-&gt;data[0], 1, out_buffer_size, out_file_pcm);</div><div class="line">                    fflush(out_file_pcm);</div><div class="line">                    frame_index++;</div><div class="line">                    __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;当前是第%d帧&quot;, frame_index);</div><div class="line">                    __android_log_print(ANDROID_LOG_INFO, &quot;main&quot;, &quot;当前是第%d帧&quot;, out_buffer);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //第七步：关闭音频解码器释放内存</div><div class="line">        av_packet_free(&amp;av_packet);</div><div class="line">        //关闭流</div><div class="line">        fclose(out_file_pcm);</div><div class="line"></div><div class="line">        swr_free(&amp;swr_context);</div><div class="line"></div><div class="line">        av_free(out_buffer);</div><div class="line"></div><div class="line">        avcodec_close(avcodec_context);</div><div class="line">        avformat_free_context(avformat_context);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>是不是和视频解码大体流程完全一样，唯一的区别就是视频像素数据格式的转换和音频采样数据的重新采样了。<br>上述代码实现完成之后可以在pc端下载Adobe audition cs6来直接播放</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://github.com/samychen/SDL_FFmpeg_Tutorial" target="_blank" rel="external">https://github.com/samychen/SDL_FFmpeg_Tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天的主题是音频解码，主要实现将视频中的音频解码为音频采用格式pcm。&lt;br&gt;首先在文章开头给出两个问题&lt;/p&gt;
&lt;p&gt;第一个问题：音频解码和视频解码目的是什么？为什么要进行音频压缩或者是视频压缩？&lt;br&gt;目的：压缩音频流、视频流、字幕流等等…（减小
      
    
    </summary>
    
      <category term="安卓直播开发" scheme="http://samychen.com/categories/%E5%AE%89%E5%8D%93%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>视频编解码学习一 yuv格式</title>
    <link href="http://samychen.com/2017/08/25/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%80-yuv%E6%A0%BC%E5%BC%8F/"/>
    <id>http://samychen.com/2017/08/25/视频编解码学习一-yuv格式/</id>
    <published>2017-08-25T11:11:22.000Z</published>
    <updated>2018-01-25T12:13:10.636Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近研究直播，一路下来遇到了很多问题，但最终经过半年的学习，在音视频这块已经有了进一步的理解，感谢我的朋友们给予的帮助，打算写下这半年来总结出来的经验，让更多的人能够接触到音视频这块。</p><p>&emsp;&emsp;今天说下视频解码基础知识<br>&emsp;&emsp;众所周知，我们日常看到的视频都有各种各样的视频格式，mp4，flv，rmvb，mkv，wmv。。。这些视频是根据什么区分的，为什么会有这么多视频格式。<br>&emsp;&emsp;首先说下视频压缩，视频都是一帧一帧的图片组成，他们都是通过容器封装成各种各样的格式。人眼的视觉残留特性导致人眼的分辨率不能超过30帧每秒，那么我们也就没有必要按照视频最初采集的大小进行存储，否则存储消耗实在是太大，比如1080p电影15分钟经过YUV4:2:0格式下的数据量为1920 x 1028 x 12 x 25 x 15 x 60/8/1024/1024/1024=62.03GB。这对于拍摄一部90分钟的电影来说简直是噩梦。</p><p>&emsp;&emsp;在摄像头之类编程经常是会碰到YUV格式,而非大家比较熟悉的RGB格式. 我们可以把YUV看成是一个RGB的变种来理解。YUV的原理是把亮度与色度分离，研究证明,人眼对亮度的敏感超过色度。利用这个原理，可以把色度信息减少一点，人眼也无法查觉这一点。<br>&emsp;&emsp;YUV三个字母中，其中”Y”表示明亮度（Lumina nce或Luma），也就是灰阶值；而”U”和”V”表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。用这个三个字母好象就是通道命令。</p><p>&emsp;&emsp;那么我们如果将本地视频解码并保存为yuv格式呢？在这里FFmpeg官方给出的视频解码流程</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-f889d70e2f360717.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FFmpeg解码"><br>从上面流程图我们可以看出视频解码流程<br>        第一步：注册所有组件<br>        第二步：打开视频输入文件<br>        第三步：查找视频文件信息<br>        第四步：查找解码器<br>        第五步：打开解码器<br>        第六步：循环读取视频帧，进行循环解码<br>        第七步：关闭解码组件</p><p>下面我们就来实现使用FFmpeg将视频解码为yuv格式</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div></pre></td><td class="code"><pre><div class="line">#include &lt;jni.h&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">//导入android-log日志</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line"></div><div class="line">//当前C++兼容C语言</div><div class="line">extern &quot;C&quot;&#123;</div><div class="line">//avcodec:编解码(最重要的库)</div><div class="line">#include &quot;libavcodec/avcodec.h&quot;</div><div class="line">//avformat:封装格式处理</div><div class="line">#include &quot;libavformat/avformat.h&quot;</div><div class="line">//avutil:工具库(大部分库都需要这个库的支持)</div><div class="line">#include &quot;libavutil/imgutils.h&quot;</div><div class="line">//swscale:视频像素数据格式转换</div><div class="line">#include &quot;libswscale/swscale.h&quot;</div><div class="line">//导入音频采样数据格式转换库</div><div class="line">#include &quot;libswresample/swresample.h&quot;</div><div class="line"></div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegTest</div><div class="line">        (JNIEnv *, jobject);</div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegDecoder</div><div class="line">        (JNIEnv *env, jobject jobj,jstring jInFilePath,jstring jOutFilePath);</div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegDecoderAudio</div><div class="line">        (JNIEnv *env, jobject jobj,jstring jInFilePath,jstring jOutFilePath);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//1、NDK音视频编解码：FFmpeg-测试配置</div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegTest(</div><div class="line">        JNIEnv *env, jobject jobj) &#123;</div><div class="line">    //(char *)表示C语言字符串</div><div class="line">    const char *configuration = avcodec_configuration();</div><div class="line">    __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;%s&quot;,configuration);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//2.NDK音视频编解码：FFmpeg-视频解码-视频像素数据(YUV420P)</div><div class="line">JNIEXPORT void JNICALL Java_com_samychen_ffmpeg_FFmpegTest_ffmpegDecoder(</div><div class="line">        JNIEnv *env, jobject jobj, jstring jinputFilePath, jstring joutputFilePath) &#123;</div><div class="line"></div><div class="line">    //将java-&gt;string类型-&gt;C字符串-&gt;char*</div><div class="line">    const char* cinputFilePath = env-&gt;GetStringUTFChars(jinputFilePath,NULL);</div><div class="line">    const char* coutputFilePath = env-&gt;GetStringUTFChars(joutputFilePath,NULL);</div><div class="line"></div><div class="line">    //第一步：注册所有组件</div><div class="line">    av_register_all();</div><div class="line"></div><div class="line">    //第二步：打开视频输入文件</div><div class="line">    //参数一：封装格式上下文-&gt;AVFormatContext-&gt;包含了视频信息(视频格式、大小等等...)</div><div class="line">    AVFormatContext* avformat_context = avformat_alloc_context();</div><div class="line">    //参数二：打开文件(入口文件)-&gt;url</div><div class="line">    int avformat_open_result = avformat_open_input(&amp;avformat_context,cinputFilePath,NULL,NULL);</div><div class="line">    if (avformat_open_result != 0)&#123;</div><div class="line">        //获取异常信息</div><div class="line">        char* error_info;</div><div class="line">        av_strerror(avformat_open_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;异常信息1：%s&quot;,error_info);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //第三步：查找视频文件信息</div><div class="line">    //参数一：封装格式上下文-&gt;AVFormatContext</div><div class="line">    //参数二：配置</div><div class="line">    //返回值：0&gt;=返回OK，否则失败</div><div class="line">    int avformat_find_stream_info_result = avformat_find_stream_info(avformat_context, NULL);</div><div class="line">    if (avformat_find_stream_info_result &lt; 0)&#123;</div><div class="line">        //获取失败</div><div class="line">        char* error_info;</div><div class="line">        av_strerror(avformat_find_stream_info_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;异常信息：%s&quot;,error_info);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //第四步：查找解码器</div><div class="line">    //第一点：获取当前解码器是属于什么类型解码器-&gt;找到了视频流</div><div class="line">    //音频解码器、视频解码器、字幕解码器等等...</div><div class="line">    //获取视频解码器流引用-&gt;指针</div><div class="line">    int av_stream_index = -1;</div><div class="line">    for (int i = 0; i &lt; avformat_context-&gt;nb_streams; ++i) &#123;</div><div class="line">        //循环遍历每一流</div><div class="line">        //视频流、音频流、字幕流等等...</div><div class="line">        if (avformat_context-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123;</div><div class="line">            //找到了</div><div class="line">            av_stream_index = i;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (av_stream_index == -1)&#123;</div><div class="line">        __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;%s&quot;,&quot;没有找到视频流&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //第二点：根据视频流-&gt;查找到视频解码器上下文-&gt;视频压缩数据</div><div class="line">    AVCodecContext* avcodec_context = avformat_context-&gt;streams[av_stream_index]-&gt;codec;</div><div class="line"></div><div class="line">    //第三点：根据解码器上下文-&gt;获取解码器ID</div><div class="line">    AVCodec* avcodec = avcodec_find_decoder(avcodec_context-&gt;codec_id);</div><div class="line">    if (avcodec == NULL)&#123;</div><div class="line">        __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;%s&quot;,&quot;没有找到视频解码器&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //第五步：打开解码器</div><div class="line">    int avcodec_open2_result = avcodec_open2(avcodec_context,avcodec,NULL);</div><div class="line">    if (avcodec_open2_result != 0)&#123;</div><div class="line">        char* error_info;</div><div class="line">        av_strerror(avcodec_open2_result, error_info, 1024);</div><div class="line">        __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;异常信息：%s&quot;,error_info);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //输出视频信息</div><div class="line">    //输出：文件格式</div><div class="line">    __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;文件格式：%s&quot;,avformat_context-&gt;iformat-&gt;name);</div><div class="line">    //输出：解码器名称</div><div class="line">    __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;解码器名称：%s&quot;,avcodec-&gt;name);</div><div class="line"></div><div class="line"></div><div class="line">    //第六步：循环读取视频帧，进行循环解码-&gt;输出YUV420P视频-&gt;格式：yuv格式</div><div class="line"></div><div class="line">    //读取帧数据换成到哪里-&gt;缓存到packet里面</div><div class="line">    AVPacket* av_packet = (AVPacket*)av_malloc(sizeof(AVPacket));</div><div class="line"></div><div class="line">    //输入-&gt;环境一帧数据-&gt;缓冲区-&gt;类似于一张图</div><div class="line">    AVFrame* av_frame_in = av_frame_alloc();</div><div class="line">    //输出-&gt;帧数据-&gt;视频像素数据格式-&gt;yuv420p</div><div class="line">    AVFrame* av_frame_out_yuv420p = av_frame_alloc();</div><div class="line"></div><div class="line">    //解码的状态类型(0:表示解码完毕，非0:表示正在解码)</div><div class="line">    int got_picture_ptr, av_decode_result, y_size, u_size, v_size, current_frame_index = 0;</div><div class="line"></div><div class="line">    //准备一个视频像素数据格式上下文</div><div class="line">    //参数一：输入帧数据宽</div><div class="line">    //参数二：输入帧数据高</div><div class="line">    //参数三：输入帧数据格式</div><div class="line">    //参数四：输出帧数据宽</div><div class="line">    //参数五：输出帧数据高</div><div class="line">    //参数六：输出帧数据格式-&gt;AV_PIX_FMT_YUV420P</div><div class="line">    //参数七：视频像素数据格式转换算法类型</div><div class="line">    //参数八：字节对齐类型(C/C++里面)-&gt;提高读取效率</div><div class="line">    SwsContext* sws_context = sws_getContext(avcodec_context-&gt;width,</div><div class="line">                                             avcodec_context-&gt;height,</div><div class="line">                                             avcodec_context-&gt;pix_fmt,</div><div class="line">                                             avcodec_context-&gt;width,</div><div class="line">                                             avcodec_context-&gt;height,</div><div class="line">                                             AV_PIX_FMT_YUV420P,</div><div class="line">                                             SWS_BICUBIC,NULL,NULL,NULL);</div><div class="line"></div><div class="line"></div><div class="line">    //打开文件</div><div class="line">    FILE* out_file_yuv = fopen(coutputFilePath,&quot;wb+&quot;);</div><div class="line">    if (out_file_yuv == NULL)&#123;</div><div class="line">        __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;文件不存在&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //&gt;=0:说明有数据，继续读取</div><div class="line">    //&lt;0:说明读取完毕，结束</div><div class="line">    while (av_read_frame(avformat_context,av_packet) &gt;= 0)&#123;</div><div class="line">        //解码什么类型流(视频流、音频流、字幕流等等...)</div><div class="line">        if (av_packet-&gt;stream_index == av_stream_index)&#123;</div><div class="line"></div><div class="line">            //扩展知识面(有更新)</div><div class="line">            //解码一帧视频流数据</div><div class="line">            //分析：avcodec_decode_video2函数</div><div class="line">            //参数一：解码器上下文</div><div class="line">            //参数二：一帧数据</div><div class="line">            //参数三：got_picture_ptr-&gt;是否正在解码(0:表示解码完毕，非0:表示正在解码)</div><div class="line">            //参数四：一帧压缩数据(对压缩数据进行解码操作)</div><div class="line">            //返回值：av_decode_result == 0表示解码一帧数据成功，否则失败</div><div class="line">            //av_decode_result = avcodec_decode_video2(avcodec_context,av_frame_in,&amp;got_picture_ptr,av_packet);</div><div class="line"></div><div class="line">            //新的API操作</div><div class="line">            //发送一帧数据-&gt;接收一帧数据</div><div class="line"></div><div class="line">            //发送一帧数据</div><div class="line">            avcodec_send_packet(avcodec_context, av_packet);</div><div class="line"></div><div class="line">            //接收一帧数据-&gt;解码一帧</div><div class="line">            av_decode_result = avcodec_receive_frame(avcodec_context, av_frame_in);</div><div class="line"></div><div class="line">            //解码出来的每一帧数据成功之后，将每一帧数据保存为YUV420格式文件类型(.yuv文件格式)</div><div class="line">            if ( av_decode_result == 0 )&#123;</div><div class="line">                //sws_scale：作用将视频像素数据格式-&gt;yuv420p格式</div><div class="line">                //输出.yuv文件-&gt;视频像素数据格式文件-&gt;输出到文件API</div><div class="line">                //参数一：视频像素数据格式-&gt;上下文</div><div class="line">                //参数二：输入数据</div><div class="line">                //参数三：输入画面每一行的大小</div><div class="line">                //参数四：输入画面每一行的要转码的开始位置</div><div class="line">                //参数五：每一帧数据高</div><div class="line">                //参数六：输出画面数据</div><div class="line">                //参数七：输出画面每一行的大小</div><div class="line">                sws_scale(sws_context,</div><div class="line">                          (const uint8_t *const*)av_frame_in-&gt;data,</div><div class="line">                          av_frame_in-&gt;linesize,</div><div class="line">                          0,</div><div class="line">                          avcodec_context-&gt;height,</div><div class="line">                          av_frame_out_yuv420p-&gt;data,</div><div class="line">                          av_frame_out_yuv420p-&gt;linesize);</div><div class="line"></div><div class="line"></div><div class="line">                //一帧一帧写入文件-&gt;yuv420p-&gt;视频像素数据格式</div><div class="line">                //第一点：分析yuv420p格式原理</div><div class="line">                //写入文件：按照像素点位置来进行写入-&gt;将av_frame_out_yuv420p一帧数据一个个字节读取</div><div class="line">                //普及一下YUV420格式(人对眼睛亮度敏感，对色度不敏感)</div><div class="line">                //Y代表：亮度</div><div class="line">                //UV代表：色度</div><div class="line">                //第二点：分析yuv420规则-&gt;计算机图像原理（听老师讲解于原理-&gt;扩展知识面）-&gt;直播技术</div><div class="line">                //yuv420规则一：Y结构表示一个像素点</div><div class="line">                //yuv420规则二：四个Y对应一个U和一个V（也就是四个像素点，对应一个U和一个V）</div><div class="line">                //第三点：分析Y和U、V大小计算原理</div><div class="line">                // y = 宽 * 高</div><div class="line">                // u = y / 4</div><div class="line">                // v = y / 4</div><div class="line">                y_size = avcodec_context-&gt;width * avcodec_context-&gt;height;</div><div class="line">                u_size = y_size / 4;</div><div class="line">                v_size = y_size / 4;</div><div class="line"></div><div class="line"></div><div class="line">                //第四点：写入文件</div><div class="line">                //写入-&gt;Y</div><div class="line">                //av_frame_in-&gt;data[0]:表示Y</div><div class="line">                fwrite(av_frame_in-&gt;data[0], 1, y_size, out_file_yuv);</div><div class="line">                //写入-&gt;U</div><div class="line">                //av_frame_in-&gt;data[1]:表示U</div><div class="line">                fwrite(av_frame_in-&gt;data[1], 1, u_size, out_file_yuv);</div><div class="line">                //写入-&gt;V</div><div class="line">                //av_frame_in-&gt;data[2]:表示V</div><div class="line">                fwrite(av_frame_in-&gt;data[2], 1, v_size, out_file_yuv);</div><div class="line"></div><div class="line">                current_frame_index++;</div><div class="line"></div><div class="line">                __android_log_print(ANDROID_LOG_INFO,&quot;main&quot;,&quot;当前遍历第%d帧&quot;,current_frame_index);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //第七步：关闭解码组件-&gt;释放内存</div><div class="line">    av_packet_free(&amp;av_packet);</div><div class="line">    //关闭流</div><div class="line">    fclose(out_file_yuv);</div><div class="line">    av_frame_free(&amp;av_frame_in);</div><div class="line">    av_frame_free(&amp;av_frame_out_yuv420p);</div><div class="line">    avcodec_close(avcodec_context);</div><div class="line">    avformat_free_context(avformat_context);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码实现完成之后可以在pc端下载yuv player来直接播放，还有一点注意就是设置屏幕大小必须设置对，否则会出现花屏。关于如何在移动端实现播放本地yuv视频，可以参考<a href="http://www.jianshu.com/p/5ade5b050832" target="_blank" rel="external">视频编解码学习三 播放yuv格式视频</a></p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://github.com/samychen/SDL_FFmpeg_Tutorial" target="_blank" rel="external">https://github.com/samychen/SDL_FFmpeg_Tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近研究直播，一路下来遇到了很多问题，但最终经过半年的学习，在音视频这块已经有了进一步的理解，感谢我的朋友们给予的帮助，打算写下这半年来总结出来的经验，让更多的人能够接触到音视频这块。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;今天说下视频解码基础知识&lt;
      
    
    </summary>
    
      <category term="安卓直播开发" scheme="http://samychen.com/categories/%E5%AE%89%E5%8D%93%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin基础语法</title>
    <link href="http://samychen.com/2017/05/25/kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://samychen.com/2017/05/25/kotlin基础语法/</id>
    <published>2017-05-25T02:24:21.000Z</published>
    <updated>2018-01-25T12:25:19.078Z</updated>
    
    <content type="html"><![CDATA[<p>  每种编程语言都有一定的语法、语义和执行顺序(同步)，学习一种新语言也都是从这三者出发，下面我们就只针对kotlin的语法来做简单的介绍。</p><p>Kotlin有自己的特性不该被Java的思维所束缚。</p><ol><li>基本语法准则:<br>在Kotlin中常量用 val 声明，变量用 var 声明；<br>关键字在前面，类型以冒号 :隔开在后面，也可以省略直接赋值；<br>类型后带问号 ? 表示可为空类型(默认空类型安全)；<br>常量 val 延迟加载 by lazy{} ；<br>默认是线程安全的，关闭线程安全 lazy(LazyThreadSafetyMode.NONE){} ；<br>变量 var 延迟加载 lateinit ;<br>内部类和参数默认为public，而在Java中为private<br>类默认为不可继承(final)，想要可被继承要声明为 open 或 abstract<br>取消了static关键字，静态方法和参数统一写在 companion object 块<br>internal模块内可见，inner内部类<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//常量数组int[][][] arrs = new int[3][2][1];</div><div class="line">val arrs = Array(3) &#123; Array(2) &#123; IntArray(1) &#125; &#125;</div><div class="line">internal var name: String? = null//类型后带问号 ? 表示可为空类型(默认空安全)</div><div class="line">internal var age: Int = 0//internal模块内可见，inner内部类</div><div class="line">//当我们只有单个构造器时，我们需要在从父类继承下来的构造器中指定需要的参数。这是用来替换Java中的super调用的。</div><div class="line">open class Animal(name: String)</div><div class="line">class Person(name: String, surname: String) : Animal(name)</div></pre></td></tr></table></figure></li></ol><p>kotlin是空类型安全的，所有变量默认为”not null”，必须显式在类型后添加？修饰符才可赋值为null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var notNullArtist: Artist = null//编译不通过，因为notNullArtist不能为null</div><div class="line">var artist: Artist? = null//编译通过</div><div class="line">artist.print()//编译不通过，因为artist可能为空</div><div class="line">/** Kotlin进行空判断处理，有两种处理方式:</div><div class="line">     * 1. 抛出空异常，字段后加 !! </div><div class="line">     * 2. 不做处理直接跳过，字段后加 ?</div><div class="line">     */</div><div class="line">artist?.print()//编译通过，做了非空判断,只有当artist！=null时才调用print()</div><div class="line">artist!!.print()//这种用法只有在确认artist不为null时才能调用，否则抛出空指针异常</div><div class="line">val name = artist?.name?:&quot;empty&quot;//当artist为null时可以指定一个默认值</div></pre></td></tr></table></figure></p><ol><li>条件语句<br>if…else 正常使用，不过移除了 switch 用更强大的 when 替代，when子式可以是各种返回Boolean的表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val x = 7</div><div class="line">when (x) &#123;</div><div class="line">  in 1..5 -&gt; print(&quot;x is in the range&quot;)</div><div class="line">  in validNumbers -&gt; print(&quot;x is valid&quot;)</div><div class="line">  !in 10..20 -&gt; print(&quot;x is outside the range&quot;)</div><div class="line">  else -&gt; print(&quot;none of the above&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>kotlin尽可能多的使用when</p><ol><li>循环语句<br>while 和 do…while 同Java并无区别， for 则有很大改变并多出了几个变种</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var list = ArrayList&lt;String&gt;()</div><div class="line">    add(list)</div><div class="line">    list.forEachIndexed &#123; i, s -&gt;</div><div class="line">    print(list[i])</div><div class="line">    print(s)</div><div class="line">    &#125;</div><div class="line">    println()</div><div class="line">    //如果没有指定函数的返回值，它就会返回Unit，与Java中的void类似，但是Unit是一个真正的对象。当然也可以指定任何其它的返回类型：</div><div class="line">    list.forEachIndexed(object :(Int,String) -&gt; Unit&#123;</div><div class="line">    override fun invoke(i: Int, s: String) &#123;</div><div class="line">        print(list[i])</div><div class="line">        print(s)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">&#125;</div><div class="line">//递增for (int i = 0; i &lt; list.size(); i++)</div><div class="line">for (i in list.indices) &#123;</div><div class="line">   print(list[i])</div><div class="line">&#125;</div><div class="line">//递增for (int i = 2; i &lt; list.size(); i++)</div><div class="line">for (i in 2..list.size-1) &#123;</div><div class="line">   print(list[i])</div><div class="line">&#125;</div><div class="line">//递减for (int i = list.size(); i &gt;= 0; i--)</div><div class="line">for (i in list.size downTo 0) &#123;</div><div class="line">    print(list[i])</div><div class="line">&#125;</div><div class="line">//操作列表内的对象</div><div class="line">for (item in list) &#123;</div><div class="line">    print(item)</div><div class="line">&#125;</div><div class="line">//加强版</div><div class="line">for((i,item) in list.withIndex())&#123;</div><div class="line">    print(list[i])</div><div class="line">    print(item)</div><div class="line">&#125;</div><div class="line">//变种版</div><div class="line">list.forEach &#123;</div><div class="line">    print(it)</div><div class="line">&#125;</div><div class="line"></div><div class="line">list.forEachIndexed &#123; i, s -&gt;</div><div class="line">    print(list[i])</div><div class="line">    print(s)</div><div class="line">&#125;</div><div class="line"></div><div class="line">list.forEachIndexed(object :(Int,String) -&gt; Unit&#123;</div><div class="line">    override fun invoke(i: Int, s: String) &#123;</div><div class="line">        print(list[i])</div><div class="line">        print(s)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">fun add(list:MutableList&lt;String&gt;) &#123;</div><div class="line">        for (i in 0..4) &#123;</div><div class="line">            list.add(i.toString() + &quot;&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><strong>冒号使用</strong><br>  在Kotlin中冒号 : 用万能来称呼绝不为过。常量变量的类型声明，函数的返回值，类的继承都需要它</p><p>  除此之外还有一个特别的地方也需要它，使用Java类的时候。Kotlin最终会还是编译成Java字节码，使用到Java类是必然的，在Kotlin语法如下<br><figure class="highlight plain"><figcaption><span>intent = Intent(this, MainActivity::class.java)```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**指定上下文的@**</div><div class="line"></div><div class="line">  除了冒号另一个重要符号 @ ，java代码中经常用到内部类和匿名内部类，有时我们不能确定this指代的上下文，Java可以使用XXX.this指代具体上下文，在kotlin中的做法是this@XXX</div></pre></td></tr></table></figure></p><p>class User {<br>    inner class State{<br>        fun getUser(): User{<br>            //返回User<br>            return this@User<br>        }<br>        fun getState(): State{<br>            //返回State<br>            return this@State<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### kotlin的特色</div><div class="line">  Java的 getter/setter 方法自动转换成属性，对应到Kotlin属性的调用</div></pre></td></tr></table></figure></p><p>public class User {<br>    private String name;<br>    private String age;</p><pre><code>public String getName() {    return name;}public void setName(String name) {    this.name = name;}public String getAge() {    return age;}public void setAge(String age) {    this.age = age;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对应的kotlin</div></pre></td></tr></table></figure></p><p>val user = User()<br>//赋值<br>user.name = “tutu”<br>user.age = “23”<br>//取值<br>val name = user.name<br>val age = user.age</p><p>class User {<br>    var name: String? = null<br>    var age: String? = null<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有时 getter/setter 方法比较复杂，这就需要自定义 getter/setter 了，实现一个Java中常用的单例，这里只为了展示，单例在Kotlin有更简单的方法实现，只要在 package 级别创建一个 object 即可</div></pre></td></tr></table></figure></p><p>class User {<br>    companion object {//静态方法和参数统一写在 companion object 块<br>         //volatile不保证原子操作，所以，很容易读到脏数据。在两个或者更多的线程访问的成员变量上使用volatile<br>        @Volatile var instance: User? = null<br>            get() {<br>                if (field == null) {<br>                    synchronized(User::class.java) {<br>                        if (field == null)<br>                            field = User()<br>                    }<br>                }<br>                return field<br>            }<br>    }</p><pre><code>var name: String? = nullvar age: String? = null</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">自定义 getter/setter 重点在 field ，跟我们熟悉所Java的 this 指代当前类一样， field 指代当前参数，直接使用参数名 instance 代替不会报错但单例就没效果了</div><div class="line"></div><div class="line">#### 字符串问题</div><div class="line">  在Java中拼接字符串的代码可读性都很差，在Kotlin字符串拼接变得非常简洁，只需用 $ 后面加上参数名，复杂的参数要加上 &#123;&#125;</div></pre></td></tr></table></figure></p><p> val pair = Pair(1, “one”)<br> val (num, name) = pair<br> println(“num = $num, name = $name”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">输出num = 1, name = one</div><div class="line"></div><div class="line">#### Java8新特性lambda的支持</div><div class="line">  lambda需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。使用功能接口，把**接口名、方法名和参数类型**省掉不写再加个 -&gt; 罢了。</div><div class="line"></div><div class="line">  使用Java开发Android时，处理监听回调是常见的事，kotlin可以直接编写监听回调而不用再通过匿名对象传递onClick方法，这个特性被称为Lambda表达式</div></pre></td></tr></table></figure></p><p>view.setOnclickListener({<br>      Toast.makeText(this, “Hello World!”, Toast.LENGTH_LONG).show()<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 扩展函数</div><div class="line">  可以为任何已经存在的类添加新函数，相比传统工具类，扩展函数更具有可读性。</div></pre></td></tr></table></figure></p><p>//为Fragment添加扩展函数<br>fun Fragment.toast(message: CharSequence, duration: Int = Toast.LENGTH_LONG){<br>      Toast.makeText(getActivity(), message, duration).show()<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">  调用时直接调用```fragment.toast(&quot;Hello World!&quot;)或fragment.toast(&quot;Hello World!&quot;, 2000)</div></pre></td></tr></table></figure></p><p>  Kotlin中的参数与Java中有些不同。如你所见，我们先写参数的名字再写它的类型。上面调用的第二个参数（length）指定了一个默认值。这意味着你调用的时候可以传入第二个值或者不传，这样可以避免你需要的重载函数。</p><p>  函数式支持(lambda)，函数是一级公民</p><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><p>&emsp;&emsp;list转map(associateBy)</p><p>&emsp;&emsp;场景：订单列表转换成以 id为key 的订单map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val mainOrders = orderDao!!.queryUserOrder(param)</div><div class="line">val orderMap = mainOrders.associateBy &#123; it.id &#125;.toMap()</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;map的key或者value转换</p><p>&emsp;&emsp;假如一个map的key是String，需要转换成Long；或者map的value是一个对象，要转成另一个对象。按照标准Java写法，可以要new一个新的map，然后循环老的map，在kotlin中，一行代码搞定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">val map = mutableMapOf(1 to 1, 2 to 2)</div><div class="line">val newMap = map.mapKeys &#123; &quot;key_$&#123;it.key&#125;&quot; &#125;.mapValues &#123; &quot;value_$&#123;it.value&#125;&quot; &#125;</div><div class="line">println(newMap)</div><div class="line">//打印结果 &#123;key_1=value_1, key_2=value_2&#125;</div><div class="line">val pair = Pair(&quot;ss&quot;,&quot;sg&quot;)</div><div class="line"> val map = mapOf(pair)</div><div class="line">val map1=map.mapKeys &#123; entry -&gt; &quot;$&#123;entry.value&#125;!&quot;  &#125;</div><div class="line">    for((key,value) in map1)&#123;</div><div class="line">        println(&quot;map1:key=$key&quot;)</div><div class="line">        println(&quot;map1:value=$value&quot;)</div><div class="line">    &#125;</div><div class="line">        val map2 =map.mapKeys &#123; (key, value) -&gt; &quot;$value&quot;  &#125;</div><div class="line">    for((key,value) in map2)&#123;</div><div class="line">        println(&quot;map2:key=$key&quot;)</div><div class="line">        println(&quot;map2:value=$value&quot;)</div><div class="line">    &#125;</div><div class="line">        val map3=map.mapValues &#123; entry -&gt; &quot;$&#123;entry.value&#125;!&quot; &#125;</div><div class="line">    for((key,value) in map3)&#123;</div><div class="line">        println(&quot;map3:key=$key&quot;)</div><div class="line">        println(&quot;map3:value=$value&quot;)</div><div class="line">    &#125;</div><div class="line">        val map4=map.mapValues &#123; (key, value) -&gt; &quot;$value&quot; &#125;</div><div class="line">    for((key,value) in map4)&#123;</div><div class="line">        println(&quot;map4:key=$key&quot;)</div><div class="line">        println(&quot;map4:value=$value&quot;)</div><div class="line">    &#125;</div><div class="line">打印结果:</div><div class="line">map1:key=sg!</div><div class="line">map1:value=sg</div><div class="line">map2:key=sg</div><div class="line">map2:value=sg</div><div class="line">map3:key=ss</div><div class="line">map3:value=sg!</div><div class="line">map4:key=ss</div><div class="line">map4:value=sg</div></pre></td></tr></table></figure></p><p>  参考文献<br>  <a href="https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/content/zen_yao_ding_yi_yi_ge_lei.html" target="_blank" rel="external">Kotlin for android Developers</a><br>  <a href="http://try.kotlinlang.org/#/Examples/Hello,%20world!/A%20multi-language%20Hello/A%20multi-language%20Hello.kt" target="_blank" rel="external">kotlin 脚本练习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  每种编程语言都有一定的语法、语义和执行顺序(同步)，学习一种新语言也都是从这三者出发，下面我们就只针对kotlin的语法来做简单的介绍。&lt;/p&gt;
&lt;p&gt;Kotlin有自己的特性不该被Java的思维所束缚。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本语法准则:&lt;br&gt;在Kotlin中
      
    
    </summary>
    
      <category term="kotlin" scheme="http://samychen.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>MQTT消息格式之SUBACK消息分析</title>
    <link href="http://samychen.com/2017/05/18/MQTT%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E4%B9%8BSUBACK%E6%B6%88%E6%81%AF%E5%88%86%E6%9E%90/"/>
    <id>http://samychen.com/2017/05/18/MQTT消息格式之SUBACK消息分析/</id>
    <published>2017-05-18T05:26:57.000Z</published>
    <updated>2017-05-18T16:46:12.249Z</updated>
    
    <content type="html"><![CDATA[<p>在上一节中（<a href="http://www.jianshu.com/p/363044e62afd" target="_blank" rel="external">MQTT消息格式之SUBSCRIBE(消息订阅)消息分析</a>），客户端发送了订阅的消息，这个时候，服务器端收到订阅主题的MQTT消息之后，肯定需要给一个应答，这个应答信息就是SUBACK(消息订阅应答)。消息订阅应答相对来说比较简单。</p><h4 id="1-运行java工程"><a href="#1-运行java工程" class="headerlink" title="1.运行java工程"></a>1.运行java工程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">import org.eclipse.paho.client.mqttv3.MqttClient;  </div><div class="line"></div><div class="line">import org.eclipse.paho.client.mqttv3.MqttConnectOptions;  </div><div class="line"></div><div class="line">import org.eclipse.paho.client.mqttv3.MqttException;  </div><div class="line"></div><div class="line">import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;  </div><div class="line"></div><div class="line">import com.tibco.mqtt.test.CustomMQTTCallBack;  </div><div class="line"></div><div class="line"> </div><div class="line">public class SubScriberExample &#123;  </div><div class="line"></div><div class="line">  </div><div class="line">    /** </div><div class="line"></div><div class="line">     * @param args </div><div class="line"></div><div class="line">     */  </div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line"></div><div class="line">         String topicFilter =&quot;test&quot;;  </div><div class="line"></div><div class="line">         String broker = &quot;tcp://192.168.80.196:1883&quot; ;  </div><div class="line"></div><div class="line">         String clientId = &quot;paho-1&quot; ;  </div><div class="line"></div><div class="line">         MemoryPersistence persistence = new MemoryPersistence();  </div><div class="line"></div><div class="line">          try &#123;  </div><div class="line"></div><div class="line">                 MqttClient sampleClient = new MqttClient(broker, clientId,persistence);  </div><div class="line"></div><div class="line">                 MqttConnectOptions connOpts = new MqttConnectOptions();  </div><div class="line"></div><div class="line">                 connOpts.setCleanSession( false );  </div><div class="line"></div><div class="line">                 System. out .println( &quot;Connecting to broker: &quot; + broker);  </div><div class="line"></div><div class="line">                 sampleClient.connect(connOpts);  </div><div class="line"></div><div class="line">                 System. out .println( &quot;Connected&quot; );  </div><div class="line"></div><div class="line">                 sampleClient.setCallback(new CustomMQTTCallBack());  </div><div class="line"></div><div class="line">                 sampleClient.subscribe(topicFilter,0);  </div><div class="line"></div><div class="line">                 System. out .println( &quot;Subscribe success for: &quot;+topicFilters.toString());  </div><div class="line"></div><div class="line">         &#125; catch (MqttException me) &#123;  </div><div class="line"></div><div class="line">                 System. out .println( &quot;reason &quot; + me.getReasonCode());  </div><div class="line"></div><div class="line">                 System. out .println( &quot;msg &quot; + me.getMessage());  </div><div class="line"></div><div class="line">                 System. out .println( &quot;loc &quot; + me.getLocalizedMessage());  </div><div class="line"></div><div class="line">                 System. out .println( &quot;cause &quot; + me.getCause());  </div><div class="line"></div><div class="line">                 System. out .println( &quot;excep &quot; + me);  </div><div class="line"></div><div class="line">                 me.printStackTrace();  </div><div class="line"></div><div class="line">         &#125;  </div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>抓包结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/4398977-cbdeba532e9fed6d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-协议分析"><a href="#2-协议分析" class="headerlink" title="2.协议分析"></a>2.协议分析</h4><p>协议的地址(<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068" target="_blank" rel="external">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>)</p><ol><li>固定头部</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/4398977-f4b7853b0f2fe7ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>从上图的抓包程序得到的数据可知，固定头部的16进制为：90 04<br>结合上面的表1，我们可知其具体含义如下：<br>90—1001 0000 表示连接的请求是SUBACK<br>04–  表示后面将会跟着4个字节</p><ol><li>可变头部</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/4398977-942c17dd742db174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>从上图的抓包程序得到的数据可知，可变头部的16进制为：00 01<br>结合上面的表2，我们可知其具体含义如下：<br>00 01 —表示当前的SUBACK的消息ID是1,这个和上节中的SUBSCRIBE（消息订阅）的消息ID的值必须保持一致。</p><p>3.负载部分<br>SUBACK负载部分的消息格式见下表,负载部分主要返回订阅的结果。其返回的值下面4中类型，其他的都是没有意义的。<br>允许返回的值<br>0x00 - 表示成功- 最大的QoS 0<br>0x01 - 表示成功- 最大的 QoS 1<br>0x02 - 表示成功- 最大的 QoS 2<br>0x80 - 表示订阅失败。 </p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-c12c5e1371568645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>从上图的抓包程序得到的数据可知，负载部分实际捕获的数据为：00 00<br>其表示消息订阅成功，且以后收到得到订阅的消息的QoS的值只能够为0.</p><p>发送确认不需要额外部分，因此负载部分长度只有两个字节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一节中（&lt;a href=&quot;http://www.jianshu.com/p/363044e62afd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MQTT消息格式之SUBSCRIBE(消息订阅)消息分析&lt;/a&gt;），客户端发送了订阅的消息，这个时候，服
      
    
    </summary>
    
      <category term="MQTT" scheme="http://samychen.com/categories/MQTT/"/>
    
    
      <category term="MQTT" scheme="http://samychen.com/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>MQTT消息格式之SUBSCRIBE消息分析</title>
    <link href="http://samychen.com/2017/05/18/MQTT%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E4%B9%8BSUBSCRIBE%E6%B6%88%E6%81%AF%E5%88%86%E6%9E%90/"/>
    <id>http://samychen.com/2017/05/18/MQTT消息格式之SUBSCRIBE消息分析/</id>
    <published>2017-05-18T02:26:57.000Z</published>
    <updated>2017-05-18T16:33:29.969Z</updated>
    
    <content type="html"><![CDATA[<p>  物联网最近曝光率越来越高。虽然HTTP是网页的事实标准，不过机器之间（Machine-to-Machine，M2M）的大规模沟通需要不同的模式：之前的请求/回答模式不再合适，取而代之的是发布/订阅（Publish/Subscribe）模式。这就是轻量级、可扩展的MQTT（Message Queuing Telemetry Transport）可以施展拳脚的舞台。</p><p>MQTT协议文档<a href="https://www.gitbook.com/book/mcxiaoke/mqtt-cn/details" target="_blank" rel="external">https://www.gitbook.com/book/mcxiaoke/mqtt-cn/details</a></p><p>  采用WireShark抓包工具分析MQTT消息，参考<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718063分析协议包" target="_blank" rel="external">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718063分析协议包</a></p><p>首先运行工程</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">[java] view plain copy print?import org.eclipse.paho.client.mqttv3.MqttClient;  </div><div class="line">import org.eclipse.paho.client.mqttv3.MqttConnectOptions;  </div><div class="line">import org.eclipse.paho.client.mqttv3.MqttException;  </div><div class="line">import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;  </div><div class="line">  </div><div class="line">  </div><div class="line">public class SubScriberExample &#123;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * @param args </div><div class="line">     */  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">         String[] topicFilters =&#123;&quot;topic1&quot;,&quot;topic2&quot;&#125; ;  </div><div class="line">         String broker = &quot;tcp://192.168.80.196:1883&quot; ;  </div><div class="line">         String clientId = &quot;paho-1&quot; ;  </div><div class="line">         MemoryPersistence persistence = new MemoryPersistence();  </div><div class="line">          try &#123;  </div><div class="line">                 MqttClient sampleClient = new MqttClient(broker, clientId,persistence);  </div><div class="line">                 MqttConnectOptions connOpts = new MqttConnectOptions();  </div><div class="line">                 connOpts.setCleanSession( false );  </div><div class="line">                 System. out .println( &quot;Connecting to broker: &quot; + broker);  </div><div class="line">                 sampleClient.connect(connOpts);  </div><div class="line">                 System. out .println( &quot;Connected&quot; );  </div><div class="line">                 sampleClient.setCallback(new CustomMQTTCallBack());  </div><div class="line">                 sampleClient.subscribe(topicFilters,new int[]&#123;1,1&#125;);  </div><div class="line">                 System. out .println( &quot;Subscribe success for: &quot;+topicFilters.toString());  </div><div class="line">         &#125; catch (MqttException me) &#123;  </div><div class="line">                 System. out .println( &quot;reason &quot; + me.getReasonCode());  </div><div class="line">                 System. out .println( &quot;msg &quot; + me.getMessage());  </div><div class="line">                 System. out .println( &quot;loc &quot; + me.getLocalizedMessage());  </div><div class="line">                 System. out .println( &quot;cause &quot; + me.getCause());  </div><div class="line">                 System. out .println( &quot;excep &quot; + me);  </div><div class="line">                 me.printStackTrace();  </div><div class="line">         &#125;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当运行客户端之后通过抓取TCP数据包<br><img src="http://upload-images.jianshu.io/upload_images/4398977-0961315a087e8c62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol><li>固定头部<br>SUBSCRIBE 固定头部的消息格式见下表</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/4398977-9a31d63c14e39111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>从上图的抓包程序得到的数据可知，固定头部的16进制为：82 14<br>结合上面的表1，我们可知其具体含义如下：<br>82—1000 0010 表示连接的请求是Subscribe<br>14–1*16+4=20 表示后面将会跟着20个字节</p><p>2.可变头部</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-91b6849a0ff18fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>从上图的抓包程序得到的数据可知，可变头部的16进制为：00 01<br>结合上面的表2，我们可知其具体含义如下：<br>00 01 —表示当前的Package的ID是1</p><p>3.负载部分<br>SUBSCRIBE 负载部分的消息格式见下表,负载部分主要指定订阅的主题（Topic）的名称以及每个订阅的主题对应的QoS级别（总共三种类型的值：0,1,2）,需要注意的是，在负载部分，一次可以订阅多个主题。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-a40f92187e41129c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>从上图的抓包程序得到的数据可知，负载部分实际捕获的数据为：00 06 74 6f 70 69 63 31 01 00 06 74 6f 70 69 63 32 01 因为总共有两个主题：topic1 和topic2，所以我们拿第一个主题(topic1)来分析就行了，后面的Topic类似.<br>00 06 代表这个topic的长度是6个字节<br>74 6f 70 69 63 31 代表 topic1<br>01 代表QoS为1</p><p>从此看出MQTT数据包并不复杂，掌握了就能看懂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  物联网最近曝光率越来越高。虽然HTTP是网页的事实标准，不过机器之间（Machine-to-Machine，M2M）的大规模沟通需要不同的模式：之前的请求/回答模式不再合适，取而代之的是发布/订阅（Publish/Subscribe）模式。这就是轻量级、可扩展的MQTT
      
    
    </summary>
    
      <category term="MQTT" scheme="http://samychen.com/categories/MQTT/"/>
    
    
      <category term="MQTT" scheme="http://samychen.com/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议架构</title>
    <link href="http://samychen.com/2017/03/18/TCP-IP%E5%8D%8F%E8%AE%AE%E6%9E%B6%E6%9E%84/"/>
    <id>http://samychen.com/2017/03/18/TCP-IP协议架构/</id>
    <published>2017-03-18T15:24:50.000Z</published>
    <updated>2017-03-18T15:25:36.179Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>1.1 五层模型</p><p>&emsp;&emsp;互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p><p>&emsp;&emsp;用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p><p>&emsp;&emsp;如何分层有不同的模型，有的模型分七层（OSI），有的分四层。TCP/IP协议把互联网分成五层，从上到下分别是应用层，传输层，网络层，链路层，物理层。</p><p>1.2 层与协议</p><p>&emsp;&emsp;每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p><p>&emsp;&emsp;大家都遵守的规则，就叫做”协议”（protocol）。</p><p>&emsp;&emsp;互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>&emsp;&emsp;电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-12030d41beda5bdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;这就叫做”物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p><h4 id="三、链接层"><a href="#三、链接层" class="headerlink" title="三、链接层"></a>三、链接层</h4><p>3.1 定义</p><p>&emsp;&emsp;单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p><p>3.2 以太网协议</p><p>&emsp;&emsp;早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><blockquote><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4398977-3c046cb4b1f40846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;”标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>&emsp;&emsp;”标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><p>3.3 MAC地址</p><p>&emsp;&emsp;上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>&emsp;&emsp;以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-66a1563794237498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-05b34425d4da2359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><p>3.4 广播</p><p>&emsp;&emsp;定义地址只是第一步，后面还有更多的步骤。</p><p>&emsp;&emsp;首先，一块网卡怎么会知道另一块网卡的MAC地址？</p><p>&emsp;&emsp;回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p><p>&emsp;&emsp;其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>&emsp;&emsp;回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-626cd5d8b23c97ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><p>&emsp;&emsp;有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p><h4 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h4><p>4.1 网络层的由来</p><p>&emsp;&emsp;以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>&emsp;&emsp;但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>&emsp;&emsp;互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-368084d8b45815f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>&emsp;&emsp;这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p><p>&emsp;&emsp;于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p>&emsp;&emsp;网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><p>4.2 IP协议</p><p>&emsp;&emsp;规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>&emsp;&emsp;目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p>&emsp;&emsp;习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>&emsp;&emsp;互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>&emsp;&emsp;但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>&emsp;&emsp;那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p><p>&emsp;&emsp;所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>&emsp;&emsp;知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>&emsp;&emsp;比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>&emsp;&emsp;总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><p>4.3 IP数据包</p><p>&emsp;&emsp;根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>&emsp;&emsp;但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p><p>&emsp;&emsp;回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>&emsp;&emsp;具体来说，IP数据包也分为”标头”和”数据”两个部分。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-a379261656d1e9b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;”标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-bd92ed69f23b4332.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>4.4 ARP协议</p><p>&emsp;&emsp;关于”网络层”，还有最后一点需要说明。</p><p>&emsp;&emsp;因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p><p>&emsp;&emsp;所以，我们需要一种机制，能够从IP地址得到MAC地址。</p><p>&emsp;&emsp;这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>&emsp;&emsp;第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>&emsp;&emsp;总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h4 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h4><p>5.1 传输层的由来</p><p>&emsp;&emsp;有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>&emsp;&emsp;接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>&emsp;&emsp;也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>&emsp;&emsp;”端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>&emsp;&emsp;”传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p><p>5.2 UDP协议</p><p>&emsp;&emsp;现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。<br>UDP数据包，也是由”标头”和”数据”两部分组成。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-922bb6e832b3b811.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-2a0413dc3f1ecb1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><p>5.3 TCP协议</p><p>&emsp;&emsp;UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>&emsp;&emsp;为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>&emsp;&emsp;因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>&emsp;&emsp;TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h4 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h4><p>&emsp;&emsp;应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p>&emsp;&emsp;”应用层”的作用，就是规定应用程序的数据格式。</p><p>&emsp;&emsp;举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p>&emsp;&emsp;这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-5f0127aee01adb3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="七、一个小结"><a href="#七、一个小结" class="headerlink" title="七、一个小结"></a>七、一个小结</h4><p>&emsp;&emsp;先对前面的内容，做一个小结。</p><p>&emsp;&emsp;我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-7347e9c34541edb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;发送这个包，需要知道两个地址：对方的MAC地址和对方的IP地址。<br>&emsp;&emsp;有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-395607516976f5f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p>&emsp;&emsp;1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</p><p>|  场景                      |  数据包地址<br>|  同一个子网络    |  对方的MAC地址，对方的IP地址<br>|  非同一个子网络    |  网关的MAC地址，对方的IP地址</p><p>&emsp;&emsp;发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p><h4 id="八、用户的上网设置"><a href="#八、用户的上网设置" class="headerlink" title="八、用户的上网设置"></a>八、用户的上网设置</h4><p>8.1 静态IP地址</p><p>&emsp;&emsp;你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p><p>&emsp;&emsp;通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p><ul><li>本机的IP地址</li><li>子网掩码</li><li>网关的IP地址</li><li>DNS的IP地址</li></ul><p>下图是Windows系统的设置窗口。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-bc88618b29602fe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p><p>&emsp;&emsp;但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p><p>8.2 动态IP地址</p><p>&emsp;&emsp;所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。</p><p>&emsp;&emsp;这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><p>&emsp;&emsp;前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p><p>&emsp;&emsp;DHCP协议做了一些巧妙的规定。</p><p>8.3 DHCP协议</p><p>&emsp;&emsp;首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的:</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-f5c3bd9a1e40eaca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p>（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>&emsp;&emsp;这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>&emsp;&emsp;接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>&emsp;&emsp;新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><p>8.4 上网设置：小结</p><p>&emsp;&emsp;这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p><ul><li>本机的IP地址</li><li>子网掩码</li><li>网关的IP地址</li><li>DNS的IP地址<br>&emsp;&emsp;有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</li></ul><h4 id="九、一个实例：访问网页"><a href="#九、一个实例：访问网页" class="headerlink" title="九、一个实例：访问网页"></a>九、一个实例：访问网页</h4><p>9.1 本机参数</p><p>&emsp;&emsp;我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p><ul><li>本机的IP地址：192.168.1.100</li><li>子网掩码：255.255.255.0</li><li>网关的IP地址：192.168.1.1</li><li>DNS的IP地址：8.8.8.8<br>&emsp;&emsp;然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。</li></ul><p>&emsp;&emsp;这意味着，浏览器要向Google发送一个网页请求的数据包。</p><p>9.2 DNS协议</p><p>&emsp;&emsp;我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。</p><p>&emsp;&emsp;DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-cd772c6c05b352b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>&emsp;&emsp;然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><p>9.3 子网掩码</p><p>&emsp;&emsp;接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p><p>&emsp;&emsp;已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>&emsp;&emsp;因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p><p>9.4 应用层协议</p><p>&emsp;&emsp;浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-1a573347e6289f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>HTTP部分的内容，类似于下面这样：</p><p>GET / HTTP/1.1<br>　　Host: www.google.com<br>　　Connection: keep-alive<br>　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ……<br>　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>　　Accept-Encoding: gzip,deflate,sdch<br>　　Accept-Language: zh-CN,zh;q=0.8<br>　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>　　Cookie: … …</p><p>&emsp;&emsp;我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><p>9.5 TCP协议</p><p>&emsp;&emsp;TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>&emsp;&emsp;TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><p>9.6 IP协议</p><p>&emsp;&emsp;然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>&emsp;&emsp;IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><p>9.7 以太网协议</p><p>&emsp;&emsp;最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>&emsp;&emsp;以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-348189e13ddbf234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>9.8 服务器端响应</p><p>&emsp;&emsp;经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>&emsp;&emsp;根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p><p>&emsp;&emsp;本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;p&gt;1.1 五层模型&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一
      
    
    </summary>
    
    
      <category term="网络协议" scheme="http://samychen.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>原生Android中嵌入Cordova Webview</title>
    <link href="http://samychen.com/2017/03/15/%E5%8E%9F%E7%94%9FAndroid%E4%B8%AD%E5%B5%8C%E5%85%A5Cordova-Webview/"/>
    <id>http://samychen.com/2017/03/15/原生Android中嵌入Cordova-Webview/</id>
    <published>2017-03-15T09:14:43.000Z</published>
    <updated>2017-03-21T10:34:10.353Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Android实现在当前进程打开网页可以将Cordova中的WebView嵌入Android项目中，实现简单，不需要自己实现，所以掌握如何嵌入WebView对项目快速开发很有帮助</p><p>&emsp;&emsp;官方也有这方面的教程操作，但最新版本的cordova android（4.0.0）对其代码库做了大的改动。这种变化，大多是一种设计模式，使得上面描述的方法不能正常工作。</p><p>&emsp;&emsp;本文将展示如何与cordova Android的新变化合作，嵌入cordova webview在本机Android应用程序。</p><h4 id="创建Cordova安卓项目"><a href="#创建Cordova安卓项目" class="headerlink" title="创建Cordova安卓项目"></a>创建Cordova安卓项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cordova create test_cordova com.example.hello HelloWorld</div><div class="line">cordova platform add android</div><div class="line">cordova plugin add nl.x-services.plugins.toast</div><div class="line">cordova plugin add org.apache.cordova.device</div><div class="line">cordova build</div></pre></td></tr></table></figure><p>上面第三行和第四行是将其他的第三方插件也嵌入安卓原生工程使用</p><h4 id="创建Android-Native项目"><a href="#创建Android-Native项目" class="headerlink" title="创建Android Native项目"></a>创建Android Native项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startCordovaActivity(View view) &#123;</div><div class="line">        Intent intent = new Intent(this, TestCordovaActivity.class);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startCordovaActivityWithLayout(View view) &#123;</div><div class="line">        Intent intent = new Intent(this, TestCordovaWithLayoutActivity.class);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>startCordovaActivity 将转移到一个新活动，其布局是以程序方式创建的cordova webview。</li><li>startCordovaActivity 将转移到一个新的活动，其布局使用xml布局文件定义并嵌入cordova webview。</li></ul><p>TestCordovaActivity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class TestCordovaActivity extends CordovaActivity &#123;</div><div class="line"></div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        super.init();</div><div class="line">        // Load your application</div><div class="line">         launchUrl = &quot;file:///android_asset/www/index.html&quot;;</div><div class="line">//        launchUrl = &quot;file:///android_asset/www/index2.html&quot;;</div><div class="line">        loadUrl(launchUrl);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不需要xml布局，加载的是index.html网页</p><p>TestCordovaWithLayoutActivity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class TestCordovaWithLayoutActivity extends CordovaActivity &#123;</div><div class="line"></div><div class="line"></div><div class="line">    /** Called when the activity is first created. */</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_test_cordova_with_layout);</div><div class="line">        super.init();</div><div class="line">        // Load your application</div><div class="line">        // launchUrl = &quot;file:///android_asset/www/index.html&quot;</div><div class="line">        launchUrl = &quot;file:///android_asset/www/index2.html&quot;;</div><div class="line">        loadUrl(launchUrl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected CordovaWebView makeWebView() &#123;</div><div class="line">        SystemWebView webView = (SystemWebView)findViewById(R.id.cordovaWebView);</div><div class="line">        return new CordovaWebViewImpl(new SystemWebViewEngine(webView));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void createViews() &#123;</div><div class="line">        //Why are we setting a constant as the ID? This should be investigated</div><div class="line">//        appView.getView().setId(100);</div><div class="line">//        appView.getView().setLayoutParams(new FrameLayout.LayoutParams(</div><div class="line">//                ViewGroup.LayoutParams.MATCH_PARENT,</div><div class="line">//                ViewGroup.LayoutParams.MATCH_PARENT));</div><div class="line">//</div><div class="line">//        setContentView(appView.getView());</div><div class="line"></div><div class="line">        if (preferences.contains(&quot;BackgroundColor&quot;)) &#123;</div><div class="line">            int backgroundColor = preferences.getInteger(&quot;BackgroundColor&quot;, Color.BLACK);</div><div class="line">            // Background of activity:</div><div class="line">            appView.getView().setBackgroundColor(backgroundColor);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        appView.getView().requestFocusFromTouch();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用setContentView显式设置布局xml。需要重写两个方法：</p><ul><li>makeWebView： 它使用R.id.cordovaWebView，在layout xml文件中定义</li><li>createViews ： 我们重写它只是因为它将默认使用setContentView。但是我们想使用我们的xml布局，所以需要它。</li></ul><p>activity_test_cordova_with_layout.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    tools:context=&quot;com.example.jimmy.embeddedcordovawebviewdemo.TestCordovaWithLayoutActivity&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:background=&quot;#FF0000&quot;</div><div class="line">        android:textColor=&quot;#FFFFFF&quot;</div><div class="line">        android:gravity=&quot;center&quot;</div><div class="line">        android:text=&quot;This is native text view&quot;</div><div class="line">        /&gt;</div><div class="line"></div><div class="line">    &lt;org.apache.cordova.engine.SystemWebView</div><div class="line">        android:id=&quot;@+id/cordovaWebView&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>为了向后兼容，我们使用cordova库中的org.apache.cordova.engine.SystemWebView,直到4.0.0之前也是可以使用org.apache.cordova.CordovaWebView</p><h4 id="将Cordova-Android项目复制到本机Android应用程序"><a href="#将Cordova-Android项目复制到本机Android应用程序" class="headerlink" title="将Cordova Android项目复制到本机Android应用程序"></a>将Cordova Android项目复制到本机Android应用程序</h4><h4 id="拷贝jar包"><a href="#拷贝jar包" class="headerlink" title="拷贝jar包"></a>拷贝jar包</h4><p>去Apache官方网站下载最新的<a href="https://github.com/apache/cordova-android/releases/tag/4.0.0" target="_blank" rel="external">cordova Android Packet</a>，然后创建jar包。<a href="http://cordova.apache.org/docs/en/5.0.0/guide/platforms/android/webview.html" target="_blank" rel="external">官方网站</a><br>下载好官方压缩文件cordova-android-xxx.zip，解压缩，通过ant工具导航到 <code>/framework</code>目录下，执行ant jar命令，如果提示<br>build fali, you need to create the file’local.properties’ by running ‘android update project -p .’命令，在cmd窗口执行如上命令之后再次执行ant jar<br>将会在当前目录生成cordova-4.0.0.jar<br>拷贝jar包到项目中，在build.gradle中添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile files(&apos;libs/cordova-4.0.0.jar&apos;)</div></pre></td></tr></table></figure></p><h4 id="拷贝www目录"><a href="#拷贝www目录" class="headerlink" title="拷贝www目录"></a>拷贝www目录</h4><p>目录结构如下<br><strong><code>platforms/android/assets/www</code> -&gt; <code>src/main/assets/www</code></strong></p><h4 id="拷贝插件"><a href="#拷贝插件" class="headerlink" title="拷贝插件"></a>拷贝插件</h4><p><strong>注意：</strong>拷贝<code>platforms/android/src/</code>目录结构下的所有文件，而不是plugins/下的所有文件。因为在运行cordova build命令时，cordova将复制<code>plugins/</code>文件夹下的插件到目录<code>platforms/android/src/</code>下，并执行一些操作。</p><h4 id="拷贝config-xml"><a href="#拷贝config-xml" class="headerlink" title="拷贝config.xml"></a>拷贝config.xml</h4><p><strong>注意：</strong>不要拷贝更目录下的config.xml，要拷贝的是platforms下的config.xml<br>目录结构如下<br><code>platforms/android/res/xml/config.xml</code> -&gt; <code>src/main/res/xml/</code></p><p>整个工程的目录结构如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-ec810e0277b57799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/4398977-0254bcf13589b1b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考文献：</p><ul><li><a href="http://cordova.apache.org/docs/en/5.0.0/guide_platforms_android_webview.md.html" target="_blank" rel="external">http://cordova.apache.org/docs/en/5.0.0/guide_platforms_android_webview.md.html</a></li><li><a href="http://richardgilmour.co.uk/2013/03/03/embedding-a-cordova-webview-in-a-native-android-app/" target="_blank" rel="external">http://richardgilmour.co.uk/2013/03/03/embedding-a-cordova-webview-in-a-native-android-app/</a></li><li><a href="https://github.com/Adobe-Marketing-Cloud-Apps/app-sample-android-phonegap/wiki/Embed-Webview-in-Android-Fragment" target="_blank" rel="external">https://github.com/Adobe-Marketing-Cloud-Apps/app-sample-android-phonegap/wiki/Embed-Webview-in-Android-Fragment</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Android实现在当前进程打开网页可以将Cordova中的WebView嵌入Android项目中，实现简单，不需要自己实现，所以掌握如何嵌入WebView对项目快速开发很有帮助&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;官方也有这方面的教程操作，但最新
      
    
    </summary>
    
      <category term="Cordova" scheme="http://samychen.com/categories/Cordova/"/>
    
    
      <category term="Cordova" scheme="http://samychen.com/tags/Cordova/"/>
    
  </entry>
  
  <entry>
    <title>Cordova 添加默认启动图</title>
    <link href="http://samychen.com/2017/03/13/Cordova-%E6%B7%BB%E5%8A%A0%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E5%9B%BE/"/>
    <id>http://samychen.com/2017/03/13/Cordova-添加默认启动图/</id>
    <published>2017-03-13T02:03:08.000Z</published>
    <updated>2017-03-21T09:15:24.988Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Cordova添加默认启动图"><a href="#Cordova添加默认启动图" class="headerlink" title="Cordova添加默认启动图"></a>Cordova添加默认启动图</h4><p>&emsp;&emsp;Cordova默认的启动图是Apache默认的logo，如果需要修改默认启动图需要Splash插件，通过CLI语句<code>cordova plugin add org.apache.cordova.splashscreen</code>添加插件</p><h4 id="1-修改config-xml配置文件"><a href="#1-修改config-xml配置文件" class="headerlink" title="1. 修改config.xml配置文件"></a>1. 修改config.xml配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;preference name=&quot;SplashScreen&quot; value=&quot;screen&quot; /&gt; &lt;!-- 不带后缀png的文件名，默认是screen--&gt;</div><div class="line">    &lt;preference name=&quot;SplashScreenDelay&quot; value=&quot;3000&quot; /&gt; &lt;!-- Splash显示时间，默认是3000ms--&gt;</div><div class="line">    &lt;feature name=&quot;SplashScreen&quot;&gt;</div><div class="line">        &lt;param name=&quot;android-package&quot; value=&quot;org.apache.cordova.splashscreen.SplashScreen&quot; /&gt;</div><div class="line">    &lt;/feature&gt;</div></pre></td></tr></table></figure><h4 id="2-修改启动图片"><a href="#2-修改启动图片" class="headerlink" title="2. 修改启动图片"></a>2. 修改启动图片</h4><p>&emsp;&emsp;可以看到启动图片的名字是screen.png,工程下有一些screen.png默认图片了，上面显示的是cordova logo，下面需要把这些图片换成你自己的启动画面，不需要支持的尺寸图片直接删掉就可以了。</p><h4 id="3-在设备初始化完成后隐藏Splash画面"><a href="#3-在设备初始化完成后隐藏Splash画面" class="headerlink" title="3.在设备初始化完成后隐藏Splash画面"></a>3.在设备初始化完成后隐藏Splash画面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false);  </div><div class="line">function onDeviceReady() &#123;  </div><div class="line">  navigator.splashscreen.hide();  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果使用了ionic框架，直接在app.js 文件的  .run([‘$ionicPlatform’, function ($ionicPlatform) {   … } 里面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">navigator.splashscreen.hide();</div></pre></td></tr></table></figure></p><blockquote><p>Blockquote</p></blockquote><p>&emsp;&emsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Cordova添加默认启动图&quot;&gt;&lt;a href=&quot;#Cordova添加默认启动图&quot; class=&quot;headerlink&quot; title=&quot;Cordova添加默认启动图&quot;&gt;&lt;/a&gt;Cordova添加默认启动图&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Cordova默认的
      
    
    </summary>
    
      <category term="Cordova" scheme="http://samychen.com/categories/Cordova/"/>
    
    
      <category term="Cordova" scheme="http://samychen.com/tags/Cordova/"/>
    
  </entry>
  
  <entry>
    <title>Cordova手动导入第三方插件</title>
    <link href="http://samychen.com/2017/03/12/Cordova%E6%89%8B%E5%8A%A8%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6/"/>
    <id>http://samychen.com/2017/03/12/Cordova手动导入第三方插件/</id>
    <published>2017-03-12T10:24:19.000Z</published>
    <updated>2017-03-21T07:27:17.978Z</updated>
    
    <content type="html"><![CDATA[<h4 id="手动导入第三方插件到Cordova项目中"><a href="#手动导入第三方插件到Cordova项目中" class="headerlink" title="手动导入第三方插件到Cordova项目中"></a>手动导入第三方插件到Cordova项目中</h4><p>&emsp;&emsp;Cordova项目中可以自定义插件，也可以从官方和其他渠道通过命令行导入工程中，因为需求总是在变，有时候第三方插件里面还包含不需要用到的功能，所有我们需要手动导入。</p><p>&emsp;&emsp;采用github中的ImagePicker插件来说明手动导入过程。首先从guihub上查看plugin.xml的内容，我们需要实现图库选择图片的功能只需要ImagePicker这个类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;config-file target=&quot;res/xml/config.xml&quot; parent=&quot;/*&quot;&gt;</div><div class="line">                        &lt;feature name=&quot;ImagePicker&quot;&gt;</div><div class="line">                                &lt;param name=&quot;android-package&quot; value=&quot;com.synconset.ImagePicker&quot;/&gt;</div><div class="line">                        &lt;/feature&gt;</div><div class="line">                &lt;/config-file&gt;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;source-file src=&quot;src/android/com/synconset/ImagePicker/ImagePicker.java&quot; target-dir=&quot;src/com/synconset&quot; /&gt;</div></pre></td></tr></table></figure><p>初步看出需要在config.xml中配置如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;feature name=&quot;ImagePicker&quot;&gt;</div><div class="line">                                &lt;param name=&quot;android-package&quot; value=&quot;com.synconset.ImagePicker&quot;/&gt;</div><div class="line">                        &lt;/feature&gt;</div></pre></td></tr></table></figure></p><p>然后把ImagePicker.java拷贝到工程中，目录结构为/ser/com/synconset/ImagePicker.java。<br>&emsp;&emsp;接着我们需要在把github中的www目录结构中的imagepicker.js文件复制到我们的工程中，目录结构是assets/www/plugins/..，我的目录结构是assets/www/plugins/imagepicker/www/imagepicker.js</p><p><strong>注意：</strong>直接拷贝js文件还需要配置js文件，最外围默认是没有cordova定义语句的，在js文件最外围拷贝如下代码，第三方js文件不知道我们定义的插件ID，需要我们自己配置，我的项目中的ID就是com.synconset.ImagePicker，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cordova.define(&quot;com.synconset.ImagePicker&quot;, function(require, exports, module) &#123;</div><div class="line"></div><div class="line">module.exports = new ImagePicker()</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><blockquote><p>默认创建插件对象的语句是window.imagePicker = new ImagePicker();window.imagePicker 就是我在注册插件时配置好了的，当然也可以用上面的<code>module.exports = new ImagePicker()</code>来创建</p></blockquote><p>&emsp;&emsp;最后我们需要在assets/www/cordova_plugins.js中配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">             &quot;id&quot;: &quot;com.synconset.ImagePicker&quot;,</div><div class="line">             &quot;file&quot;: &quot;plugins/imagepicker/www/imagepicker.js&quot;,</div><div class="line">             &quot;merges&quot;: [</div><div class="line">                 &quot;window.imagePicker&quot;</div><div class="line">             ]</div><div class="line">         &#125;</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后这时候ImagePicker.java报找不到MultiImageChooserActivity类，把需要的类一并拷贝到项目中，导入的Activity需要在清单文件中注册</p><p>&emsp;&emsp;运行到模拟器上，在<br><code>setContentView(fakeR.getId(&quot;layout&quot;, &quot;multiselectorgrid&quot;));</code>出错，因为项目中没有找到multiselectrgrid.xml文件，在res中新建layout文件夹把需要的文件拷贝进去，之后在<br><code>BitmapFactory.decodeResource(getResources(), fakeR.getId(&quot;drawable&quot;, &quot;loading_icon&quot;));</code>报找不到图片，将需要的图片也拷贝进去。</p><blockquote><p>使用getIdentifier()方法可以方便的获各应用包下的指定资源ID。<br>方式一<br>int indentify = getResources().getIdentifier(“com.test.demo:drawable/icon”,null,null);<br>第一个参数格式是：包名 + : +资源文件夹名 + / +资源名；是这种格式 然后其他的可以为null<br>方式二<br>intindentify= getResources().getIdentifier(“icon”, “drawable”, “com.test.demo”);<br>第一个参数为ID名，第二个为资源属性是ID或者是Drawable，第三个为包名。</p></blockquote><pre><code>import java.lang.reflect.Field;import android.content.Context;public class ResourceUtil {    private static Context sContext;    public static void init(Context context) {        if (context != null)            sContext = context;    }    public static int getLayoutId(String paramString) {        if (sContext == null)            return 0;        return sContext.getResources().getIdentifier(paramString, &quot;layout&quot;, sContext.getPackageName());    }    public static int getStringId(String paramString) {        if (sContext == null)            return 0;        return sContext.getResources().getIdentifier(paramString, &quot;string&quot;,                sContext.getPackageName());    }    public static int getDrawableId(String paramString) {        if (sContext == null)            return 0;        return sContext.getResources().getIdentifier(paramString, &quot;drawable&quot;, sContext.getPackageName());    }    public static int getStyleId(String paramString) {        if (sContext == null)            return 0;        return sContext.getResources().getIdentifier(paramString, &quot;style&quot;,                sContext.getPackageName());    }    public static int getId(String paramString) {        if (sContext == null)            return 0;        return sContext.getResources().getIdentifier(paramString, &quot;id&quot;,                sContext.getPackageName());    }    public static int getColorId(String paramString) {        if (sContext == null)            return 0;        return sContext.getResources().getIdentifier(paramString, &quot;color&quot;, sContext.getPackageName());    }    public static int getDimenId(String paramString) {        if (sContext == null)            return 0;        return sContext.getResources().getIdentifier(paramString, &quot;dimen&quot;,                sContext.getPackageName());    }    public static int getAnimId(String paramString) {        if (sContext == null)            return 0;        return sContext.getResources().getIdentifier(paramString, &quot;anim&quot;, sContext.getPackageName());    }    // 通过反射实现    public static final int[] getStyleableIntArray(String name) {        try {            if (sContext == null)                return null;            Field field = Class.forName(sContext.getPackageName() + &quot;.R$styleable&quot;).getDeclaredField(name);            int[] ret = (int[]) field.get(null);            return ret;        } catch (Throwable t) {        }        return null;    }    public static final int getStyleableIntArrayIndex(String name) {        try {            if (sContext == null)                return 0;            // use reflection to access the resource class            Field field = Class.forName(sContext.getPackageName() + &quot;.R$styleable&quot;).getDeclaredField(name);            int ret = (Integer) field.get(null);            return ret;        } catch (Throwable t) {        }        return 0;    }}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;总之，Cordova手动导入第三方插件过程就是这个过程，我们需要的就是拷贝文件然后配置好需要配置的地方就行，项目报找不到插件的方法就一定是配置出了问题，其他大多数问题就是所需要的资源文件问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;手动导入第三方插件到Cordova项目中&quot;&gt;&lt;a href=&quot;#手动导入第三方插件到Cordova项目中&quot; class=&quot;headerlink&quot; title=&quot;手动导入第三方插件到Cordova项目中&quot;&gt;&lt;/a&gt;手动导入第三方插件到Cordova项目中&lt;/h4&gt;&lt;
      
    
    </summary>
    
      <category term="Cordova" scheme="http://samychen.com/categories/Cordova/"/>
    
    
      <category term="Cordova" scheme="http://samychen.com/tags/Cordova/"/>
    
  </entry>
  
</feed>
